#include "BandStructure.h"

#include <omp.h>

#include <algorithm>
#include <cfloat>
#include <chrono>
#include <experimental/iterator>
#include <fstream>
#include <iostream>
#include <iterator>

#include "Hamiltonian.h"

namespace EmpiricalPseudopotential {

std::string BandStructure::get_path_as_string() const {
    std::string path = "";
    for (const auto& point : m_path) {
        path += point;
    }
    return path;
}

bool BandStructure::GenerateBasisVectors(unsigned int nearestNeighborsNumber) {
    static const std::vector<unsigned int> G2{
        0,   3,   4,   8,   11,  12,  16,  19,  20,  24,  27,  32,  35,  36,  40,  43,  44,  48,  51,  52,  56,  59,  67,  68,
        75,  76,  80,  83,  84,  88,  96,  99,  104, 107, 108, 115, 116, 120, 123, 128, 131, 132, 136, 139, 140, 144, 147, 152,
        155, 160, 163, 164, 168, 171, 172, 176, 179, 180, 184, 187, 192, 195, 196, 200, 203, 204, 208, 211, 212, 216, 219, 224,
        227, 228, 232, 236, 243, 244, 248, 251, 259, 260, 264, 267, 268, 272, 275, 276, 280, 283, 291, 296, 299, 300, 304, 307,
        308, 312, 315, 320, 323, 324, 331, 332, 339, 355, 356, 360, 363, 371, 376, 384, 387, 395, 420, 451};

    if (nearestNeighborsNumber < 2 || nearestNeighborsNumber > G2.size()) {
        std::cout << "Error: nearestNeighborsNumber must be between 2 and " << G2.size() << std::endl;
        return false;
    }
    const unsigned int nearestNeighbors = nearestNeighborsNumber - 1;
    basisVectors.clear();
    const int           size = static_cast<int>(ceil(sqrt(static_cast<double>(G2[nearestNeighbors]))));
    const Vector3D<int> b1(-1, 1, 1), b2(1, -1, 1), b3(1, 1, -1);

    for (int i = -size; i <= size; ++i)
        for (int j = -size; j <= size; ++j)
            for (int k = -size; k <= size; ++k) {
                const Vector3D<int> vect        = b1 * i + b2 * j + b3 * k;  // reciprocal lattice vector
                const double        vectSquared = vect * vect;

                if (vectSquared <= G2[nearestNeighbors])  // if it's under the cutoff length, add it
                    basisVectors.push_back(vect);
            }

    return true;
}

void BandStructure::Initialize(const Material&                 material,
                               std::size_t                     nb_bands,
                               const std::vector<std::string>& path,
                               unsigned int                    nbPoints,
                               unsigned int                    nearestNeighborsNumber,
                               bool                            enable_non_local_correction,
                               bool                            enable_soc) {
    m_material                    = material;
    m_nb_bands                    = nb_bands;
    m_path                        = path;
    m_nb_points                   = nbPoints;
    m_nearestNeighborsNumber      = nearestNeighborsNumber;
    m_enable_non_local_correction = enable_non_local_correction;
    m_enable_spin_orbit_coupling  = enable_soc;
    m_kpoints.clear();
    m_results.clear();
    m_kpoints.reserve(m_nb_points);
    m_results.reserve(m_nb_points);

    if (m_enable_spin_orbit_coupling) {
        m_nb_bands *= 2;
        std::cout << "Spin-orbit coupling enabled. Number of bands doubled to " << m_nb_bands << std::endl;
        m_material.get_spin_orbit_parameters().print_parameters();
    }

    if (!GenerateBasisVectors(nearestNeighborsNumber)) {
        throw std::runtime_error("BandStructure::Initialize: GenerateBasisVectors failed");
    }
    m_kpoints   = symmetryPoints.GeneratePoints(m_path, m_nb_points, symmetryPointsPositions);
    m_nb_points = m_kpoints.size();
    if (m_nb_points == 0) {
        throw std::runtime_error(
            "BandStructure::Initialize: GeneratePoints failed. No points generated.\
        \nPlease increase the number of points such as there is twice as many points as the number of symetry points.");
    }
}

void BandStructure::Initialize(const Material&               material,
                               std::size_t                   nb_bands,
                               std::vector<Vector3D<double>> list_k_points,
                               unsigned int                  nearestNeighborsNumber,
                               bool                          enable_non_local_correction,
                               bool                          enable_soc) {
    m_material                    = material;
    m_nb_bands                    = nb_bands;
    m_nb_points                   = list_k_points.size();
    m_nearestNeighborsNumber      = nearestNeighborsNumber;
    m_enable_non_local_correction = enable_non_local_correction;
    m_enable_spin_orbit_coupling  = enable_soc;

    if (m_enable_spin_orbit_coupling) {
        m_nb_bands *= 2;
        std::cout << "Spin-orbit coupling enabled. Number of bands doubled to " << m_nb_bands << std::endl;
        m_material.get_spin_orbit_parameters().print_parameters();

    }

    m_kpoints.clear();
    m_results.clear();
    m_kpoints = list_k_points;

    if (!GenerateBasisVectors(nearestNeighborsNumber)) {
        throw std::runtime_error("BandStructure::Initialize: GenerateBasisVectors failed");
    }
}

void BandStructure::Compute() {
    std::cout << "Computing band structure..." << std::endl;
    auto start = std::chrono::high_resolution_clock::now();

    m_results.clear();

    Hamiltonian hamiltonian(m_material, basisVectors);
    for (unsigned int i = 0; i < m_nb_points; ++i) {
        // std::cout << "\rComputing band structure at point " << i + 1 << "/" << m_nb_points << std::flush;
        // std::cout << "Computing band structure at point " << m_kpoints[i] << std::endl;

        hamiltonian.SetMatrix(m_kpoints[i], m_enable_non_local_correction, m_enable_spin_orbit_coupling);
        hamiltonian.Diagonalize();

        const Eigen::VectorXd& eigenvals = hamiltonian.eigenvalues();

        m_results.emplace_back();
        m_results.back().reserve(m_nb_bands);
        for (unsigned int level = 0; level < m_nb_bands && level < eigenvals.rows(); ++level) {
            m_results.back().push_back(eigenvals(level));
        }
    }
    auto end             = std::chrono::high_resolution_clock::now();
    m_computation_time_s = std::chrono::duration_cast<std::chrono::seconds>(end - start).count();
}

void BandStructure::Compute_parallel(int nb_threads) {
    auto start = std::chrono::high_resolution_clock::now();
    m_results.clear();
    m_results.resize(m_nb_points);
    for (auto& row : m_results) {
        row.resize(m_nb_bands);
    };

    std::vector<Hamiltonian> hamiltonian_per_thread;
    for (int i = 0; i < nb_threads; i++) {
        hamiltonian_per_thread.push_back(Hamiltonian(m_material, basisVectors));
    }

#pragma omp parallel for schedule(dynamic) num_threads(nb_threads)
    for (unsigned int index_k = 0; index_k < m_nb_points; ++index_k) {
        int tid = omp_get_thread_num();
        hamiltonian_per_thread[tid].SetMatrix(m_kpoints[index_k], m_enable_non_local_correction, m_enable_spin_orbit_coupling);
        hamiltonian_per_thread[tid].Diagonalize();

        const Eigen::VectorXd& eigenvals = hamiltonian_per_thread[tid].eigenvalues();
        for (unsigned int level = 0; level < m_nb_bands && level < eigenvals.rows(); ++level) {
            m_results[index_k][level] = eigenvals(level);
        }
    }
    auto end             = std::chrono::high_resolution_clock::now();
    m_computation_time_s = std::chrono::duration_cast<std::chrono::seconds>(end - start).count();
}

double BandStructure::AdjustValues(bool minConductionBandToZero) {
    double maxValValence;
    double minValConduction;

    double band_gap = 0;

    if (FindBandGap(m_results, maxValValence, minValConduction)) {
        band_gap = minValConduction - maxValValence;
    }

    for (std::size_t idx_k = 0; idx_k < m_results.size(); ++idx_k) {
        for (std::size_t idx_band = 0; idx_band < m_results[idx_k].size(); ++idx_band) {
            if (idx_band < 4) {
                m_results[idx_k][idx_band] -= maxValValence;
            } else if (minConductionBandToZero) {
                m_results[idx_k][idx_band] -= minValConduction;
            } else {
                m_results[idx_k][idx_band] -= maxValValence;
            }
        }
    }

    return band_gap;
}

bool BandStructure::FindBandGap(const std::vector<std::vector<double>>& results, double& maxValValence, double& minValConduction) {
    maxValValence = DBL_MIN;
    if (results.empty() || results.front().size() < 2) return false;

    const unsigned int nrLevels       = static_cast<unsigned int>(results.front().size());
    double             fallbackMaxVal = 0;

    for (unsigned int levelLow = 2; levelLow < nrLevels - 1; ++levelLow) {
        maxValValence    = DBL_MIN;
        minValConduction = DBL_MAX;

        for (auto& p : results) {
            const double valLow  = p[levelLow];
            const double valHigh = p[levelLow + 1ULL];

            maxValValence    = std::max(maxValValence, valLow);
            minValConduction = std::min(minValConduction, valHigh);
        }

        if (3 == levelLow) fallbackMaxVal = maxValValence;

        if (maxValValence + 0.35 < minValConduction) return true;
    }

    maxValValence = fallbackMaxVal;

    return false;
}

std::vector<double> BandStructure::get_band(unsigned int band_index) const {
    std::vector<double> res;
    res.reserve(m_results.size());
    for (auto& p : m_results) {
        res.push_back(p[band_index]);
    }
    return res;
}

void BandStructure::print_results() const {
    for (auto& p : m_results) {
        for (auto& v : p)
            std::cout << v << " ";
        std::cout << std::endl;
    }
}

void BandStructure::export_k_points_to_file(std::string filename) const {
    std::ofstream file(filename);
    for (auto& p : m_kpoints) {
        file << p.Y << " " << p.X << " " << p.Z << std::endl;
    }
    file.close();
}

void BandStructure::export_result_in_file(const std::string& filename) const {
    std::cout << "Exporting band structure to file:     " << filename << std::endl;
    std::ofstream file(filename);
    file << "# Path " << get_path_as_string() << std::endl;
    file << "# Material " << m_material.get_name() << std::endl;
    file << "# NBands " << m_nb_bands << std::endl;
    file << "# Nonlocal " << (m_enable_non_local_correction ? "Yes" : "No") << std::endl;

    for (unsigned int i = 0; i < m_results.front().size() - 1; ++i) {
        file << "band_" << i << ",";
    }
    file << "band_" << m_results.front().size() - 1 << std::endl;
    for (unsigned int index_k = 0; index_k < m_nb_points; ++index_k) {
        // file << m_kpoints[index_k].Y << "," << m_kpoints[index_k].X << "," << m_kpoints[index_k].Z << ",";
        std::vector<double> band_values = m_results[index_k];
        std::copy(std::begin(band_values), std::end(band_values), std::experimental::make_ostream_joiner(file, ","));
        file << std::endl;
    }
}

void BandStructure::export_result_in_file_with_kpoints(const std::string& filename) const {
    std::cout << "Exporting band structure to file:     " << filename << std::endl;
    std::ofstream file(filename);
    file << "kx,ky,kz,";

    for (unsigned int i = 0; i < m_results.front().size() - 1; ++i) {
        file << "band_" << i << ",";
    }
    file << "band_" << m_results.front().size() - 1 << std::endl;
    for (unsigned int index_k = 0; index_k < m_nb_points; ++index_k) {
        file << m_kpoints[index_k].Y << "," << m_kpoints[index_k].X << "," << m_kpoints[index_k].Z << ",";
        std::vector<double> band_values = m_results[index_k];
        std::copy(std::begin(band_values), std::end(band_values), std::experimental::make_ostream_joiner(file, ","));
        file << std::endl;
    }
}

std::string BandStructure::path_band_filename() const {
    std::string path_string;
    if (m_path.empty()) {
        path_string = "";
    } else {
        for (auto& point : m_path) {
            path_string += point;
        }
    }
    std::string filename = "EPM_" + m_material.get_name() + "_nb_bands_" + std::to_string(m_results.front().size()) + "_path_" +
                           path_string + "_size_basis_" + std::to_string(basisVectors.size());
    return filename;
}

void export_vector_bands_result_in_file(const std::string& filename, std::vector<std::vector<double>> results) {
    std::cout << "Exporting band structure to file:     " << filename << std::endl;
    std::ofstream file(filename);

    for (auto& p : results) {
        for (auto& v : p)
            file << v << ",";
        file << std::endl;
    }
}

}  // namespace EmpiricalPseudopotential/**
 * @file Constants.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-26
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <cmath>
#include <numbers>

namespace EmpiricalPseudopotential {

namespace Constants {

constexpr double h   = 6.62607015e-34;   // J·s (exact)
constexpr double k_B = 1.380649e-23;     // J/K (exact)
constexpr double q_e = 1.602176634e-19;  // C = J/eV (exact)
constexpr double N_A = 6.02214076e23;    // 1/mol (exact)
constexpr double c   = 299792458.0;      // m/s (exact)

// === Derived fundamentals ===
constexpr double pi       = std::numbers::pi_v<double>;
constexpr double h_bar    = h / (2.0 * pi);   // J·s
constexpr double eV_to_J  = q_e;              // J/eV
constexpr double h_bar_eV = h_bar / eV_to_J;  // eV·s
constexpr double k_b_eV   = k_B / eV_to_J;    // eV/K

constexpr double eps_0 = 8.8541878128e-12;  // F/m
constexpr double m_e   = 9.1093837015e-31;  // kg

constexpr double bohr_radius    = 5.29177210903e-11;    // m
constexpr double Hartree_to_J   = 4.3597447222071e-18;  // J
constexpr double Hartree_to_eV  = Hartree_to_J / eV_to_J;
constexpr double Ryd_to_eV      = Hartree_to_eV / 2.0;  // ~13.605693122994
constexpr double Ryd_to_Hartree = 0.5;

// conversions
constexpr double angstrom_to_m   = 1e-10;              // m/Å
constexpr double eV_to_cm_inv    = 8065.54429;         // cm^-1/eV
constexpr double eV_to_J_per_mol = eV_to_J * N_A;      // J/mol per eV
constexpr double eV_to_kg        = eV_to_J / (c * c);  // kg/eV (~1.78266192e-36)

// Back-conversions
constexpr double eV_to_Hartree = 1.0 / Hartree_to_eV;
constexpr double eV_to_Ryd     = 1.0 / Ryd_to_eV;

}  // namespace Constants
}  // namespace EmpiricalPseudopotential#include "Material.h"

#include <cmath>

#include "Constants.hpp"
#include "bessel_func.hpp"
#include "yaml-cpp/yaml.h"

namespace EmpiricalPseudopotential {

const double Bohr = 0.52917721092;  // in Angstroms

Material::Material(const std::string& Name,
                   double             a,
                   double             V3S,
                   double             V4S,
                   double             V8S,
                   double             V11S,
                   double             V3A,
                   double             V4A,
                   double             V8A,
                   double             V11A)
    : m_name(Name),
      m_lattice_constant(a),
      m_pseudopotential(V3S, V4S, V8S, V11S, V3A, V4A, V8A, V11A) {
}

/**
 * @brief Load material parameters from the passed filename.
 * The file is a YAML file containing the parameters for each material (lattice constant, pseudopotential parameters, etc.).
 *
 * @param filename
 */
void Materials::load_material_parameters(const std::string& filename) {
    YAML::Node config         = YAML::LoadFile(filename);
    auto       list_materials = config["materials"];
    for (const auto& material : list_materials) {
        std::string name                 = material["name"].as<std::string>();
        std::string symbol               = material["symbol"].as<std::string>();
        double      a                    = material["lattice-constant"].as<double>();
        auto        node_pseudopotential = material["pseudo-potential-parameters"];
        double      V3S                  = Constants::Ryd_to_eV * node_pseudopotential["V3S"].as<double>();
        double      V8S                  = Constants::Ryd_to_eV * node_pseudopotential["V8S"].as<double>();
        double      V11S                 = Constants::Ryd_to_eV * node_pseudopotential["V11S"].as<double>();
        double      V3A                  = Constants::Ryd_to_eV * node_pseudopotential["V3A"].as<double>();
        double      V4A                  = Constants::Ryd_to_eV * node_pseudopotential["V4A"].as<double>();
        double      V11A                 = Constants::Ryd_to_eV * node_pseudopotential["V11A"].as<double>();
        double      V4S                  = 0.0;
        double      V8A                  = 0.0;
        if (node_pseudopotential["V4S"]) {
            V4S = Constants::Ryd_to_eV * node_pseudopotential["V4S"].as<double>();
        }
        if (node_pseudopotential["V8A"]) {
            V8A = Constants::Ryd_to_eV * node_pseudopotential["V8A"].as<double>();
        }
        materials[symbol] = Material(symbol, a, V3S, V4S, V8S, V11S, V3A, V4A, V8A, V11A);

        auto node_non_local_parameters = material["non-local-parameters"];
        if (node_non_local_parameters) {
            materials[symbol].populate_non_local_parameters(node_non_local_parameters);
            materials[symbol].set_is_non_local_parameters_populated(true);
        }

        auto node_spin_orbit_parameters = material["spin-orbit-parameters"];
        if (node_spin_orbit_parameters) {
            materials[symbol].populate_spin_orbit_parameters(node_spin_orbit_parameters);
            materials[symbol].set_is_spin_orbit_parameters_populated(true);
            std::cout << "Spin-orbit parameters for " << symbol << " are set." << std::endl;
            // materials[symbol].get_spin_orbit_parameters().print_parameters();
            
        }
    }
}

/**
 * @brief Compute the so called F_l function, which is used in the non-local pseudopotential correction.
 * (See Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
 * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).)
 *
 * For the values of function, see: Bloomfield, J. K., Face, S. H. P. & Moss, Z. Indefinite Integrals of Spherical Bessel
 * Functions. Preprint at http://arxiv.org/abs/1703.06428 (2017). Equations 49 and 59.
 *
 * @param K1
 * @param K2
 * @param atomic_radii
 * @param l
 * @return double
 */
double F_l_function(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii, int l) {
    // This epsilon is used to avoid division by zero in the case of K1 == K2.
    // The value is quite big, but lower values lead to numerical instabilities (noisy bands).
    // Reason: K1 and K2 are of the order of  2PI / a_0 ~ 1e10 !
    constexpr double EPSILON = 1.0e-4;
    const double     norm_K1 = K1.Length();
    const double     norm_K2 = K2.Length();
    if (fabs(norm_K1 - norm_K2) > EPSILON) {
        const double pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
        const double F = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
                         norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
        return pre_factor * F;
    } else if (norm_K1 > EPSILON) {
        const double pre_factor = pow(atomic_radii, 3.0) / (2.0);
        const double F          = pow(generalized_bessel(l, norm_K1 * atomic_radii), 2.0) -
                         generalized_bessel(l - 1, norm_K1 * atomic_radii) * generalized_bessel(l + 1, norm_K1 * atomic_radii);
        return pre_factor * F;
    } else {
        return (l==0) ? pow(atomic_radii, 3.0) / (3.0) : 0.0;
    }
}

double F_2_function_gaussian(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii) {
    const double norm_K1    = K1.Length();
    const double norm_K2    = K2.Length();
    const double bessel_arg = 0.5 * (atomic_radii * atomic_radii) * norm_K1 * norm_K2;
    return bessel_2nd_order_first_kind(bessel_arg) * exp(-0.25 * (norm_K1 * norm_K1 + norm_K2 * norm_K2) * atomic_radii * atomic_radii);
}

/**
 * @brief Compute the non local correction to the EPM Hamiltonian.
 * It follows: Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
 * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).
 * See also: Pötz, W. & Vogl, P. Theory of optical-phonon deformation
 * potentials in tetrahedral semiconductors. Phys. Rev. B 24, 2025–2037 (1981)
 *
 * K1 = (k + G)
 * K2 = (k + G')
 * tau = 1/8 * a * (1, 1, 1)
 *
 * @warning This function aims to be as close as possible to the original implementation of the authors.
 * It might not be the most efficient way, even though the compiler may optimize it for us.
 *
 * @warning Only square well pseudopotential are supported for now on.
 *
 * @param K1
 * @param K2
 * @param tau
 * @return std::complex<double>
 */
std::complex<double> Material::compute_pseudopotential_non_local_correction(const Vector3D<double>& K1_normalized,
                                                                            const Vector3D<double>& K2_normalized,
                                                                            const Vector3D<double>& tau) const {
    const double           diag_factor       = pow(Constants::h_bar, 2) / (2.0 * Constants::m_e * Constants::q_e);
    const double           fourier_factor    = 2.0 * M_PI / get_lattice_constant_meter();
    const Vector3D<double> G_diff_normalized = (K1_normalized - K2_normalized);
    const Vector3D<double> K1                = K1_normalized * fourier_factor;
    const Vector3D<double> K2                = K2_normalized * fourier_factor;
    const double           norm_K1           = K1.Length();
    const double           norm_K2           = K2.Length();
    const double           cos_angle_K1_K2   = compute_cos_angle(K1, K2);
    const double           V_pre_factor      = 4.0 * M_PI / get_atomic_volume();
    const double           legendre_0        = 1.0;
    const double           legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);

    // First atomic species: anion
    double V_anion = 0;
    // l = 0
    const double A_0_anion = m_non_local_parameters.m_alpha_0_anion + diag_factor * m_non_local_parameters.m_beta_0_anion *
                                                                          (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
    const double F_0_anion = (m_non_local_parameters.m_R0_anion == 0.0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_anion, 0);
    V_anion += V_pre_factor * A_0_anion * (2 * 0 + 1) * 1.0 * F_0_anion;
    // l = 2
    double V_anion_2 = 0.0;
    if (m_non_local_parameters.m_A2_anion != 0) {
        const double A_2_anion = m_non_local_parameters.m_A2_anion;
        double       F_2_anion = 0.0;
        if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
            F_2_anion = F_l_function(K1, K2, m_non_local_parameters.m_R2_anion, 2);
            V_anion_2 = V_pre_factor * A_2_anion * (2 * 2 + 1) * legendre_2 * F_2_anion;
        } else {
            F_2_anion = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_anion);
            V_anion_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_anion, 3.0) / get_atomic_volume()) * A_2_anion *
                        legendre_2 * F_2_anion;
        }
        V_anion += V_anion_2;
    }

    // Second atomic species: cation
    double V_cation = 0;
    // l = 0
    const double F_0_cation = (m_non_local_parameters.m_R0_cation == 0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_cation, 0);
    const double A_0_cation = m_non_local_parameters.m_alpha_0_cation + m_non_local_parameters.m_beta_0_cation * diag_factor *
                                                                            (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
    V_cation += V_pre_factor * A_0_cation * (2 * 0 + 1) * legendre_0 * F_0_cation;
    // l = 2
    double V_cation_2 = 0.0;
    if (m_non_local_parameters.m_A2_cation != 0.0) {
        const double A_2_cation = m_non_local_parameters.m_A2_cation;
        double       F_2_cation = 0.0;
        if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
            F_2_cation = F_l_function(K1, K2, m_non_local_parameters.m_R2_cation, 2);
            V_cation_2 = V_pre_factor * A_2_cation * (2 * 2 + 1) * legendre_2 * F_2_cation;
        } else {
            F_2_cation = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_cation);
            V_cation_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_cation, 3.0) / get_atomic_volume()) * A_2_cation *
                         legendre_2 * F_2_cation;
        }
        V_cation += V_cation_2;
    }

    const double V_symmetric     = 1.0 * (V_anion + V_cation) / 2.0;
    const double V_antisymmetric = 1.0 * (V_anion - V_cation) / 2.0;

    constexpr double const_two        = 2.0;
    const double     lattice_constant = this->get_lattice_constant_meter();
    const double     Gtau             = (tau / lattice_constant) * (G_diff_normalized);

    return std::complex<double>(cos(const_two * M_PI * Gtau) * V_symmetric, sin(const_two * M_PI * Gtau) * V_antisymmetric);
}

void Materials::print_materials_list() const {
    for (const auto& material : materials) {
        std::cout << material.first << std::endl;
    }
}

void Materials::print_material_parameters(const std::string& name) const {
    if (materials.find(name) == materials.end()) {
        std::cout << "Material " << name << " not found" << std::endl;
        return;
    }
    const Material& material = materials.at(name);
    std::cout << "Material: " << name << std::endl;
    std::cout << "Lattice constant: " << material.get_lattice_constant_meter() << " Bohr" << std::endl;
    std::cout << "-------------------------------------" << std::endl;
}

void Materials::print_material_parameters() const {
    for (const auto& material : materials) {
        print_material_parameters(material.first);
    }
}

}  // namespace EmpiricalPseudopotential
/**
 * @file bz_mesh.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-07
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "bz_meshfile.hpp"

#include <filesystem>

#include "BandStructure.h"
#include "gmsh.h"
#include "rapidcsv.h"

void bz_mesh_points::add_k_point(Vector3D<double> kpoint) { m_kpoints.push_back(kpoint); }

void bz_mesh_points::add_k_point(double k_x, double k_y, double k_z) { m_kpoints.push_back(Vector3D<double>(k_x, k_y, k_z)); }

void bz_mesh_points::read_mesh_from_csv() {
    m_node_tags.clear();
    m_kpoints.clear();
    m_nb_points = 0;
    std::cout << "Opening file " << m_filename << std::endl;
    rapidcsv::Document  doc(m_filename, rapidcsv::LabelParams(-1, -1), rapidcsv::SeparatorParams(' '));
    std::vector<double> k_x = doc.GetColumn<double>(0);
    std::vector<double> k_y = doc.GetColumn<double>(1);
    std::vector<double> k_z = doc.GetColumn<double>(2);

    std::size_t size_k_x = k_x.size();
    std::size_t size_k_y = k_y.size();
    std::size_t size_k_z = k_z.size();

    if (size_k_x != size_k_y || size_k_x != size_k_z) {
        throw std::runtime_error("Number of k-points in x, y and z are not the same. Abort.");
    }

    for (std::size_t index_k = 0; index_k < size_k_x; ++index_k) {
        add_k_point(k_x[index_k], k_y[index_k], k_z[index_k]);
    }

    std::cout << "Number of k-points read from csv file: " << size_k_x << std::endl;
}

void bz_mesh_points::read_mesh() {
    std::cout << "Opening file " << m_filename << std::endl;
    if (m_filename.substr(m_filename.find_last_of(".") + 1) == "csv") {
        read_mesh_from_csv();
        return;
    }

    gmsh::initialize();
    // gmsh::option::setNumber("General.Verbosity", 1);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);
    // std::vector<std::size_t> nodeTags;
    std::vector<double> nodeCoords;
    std::vector<double> nodeParams;
    gmsh::model::mesh::reclassifyNodes();
    gmsh::model::mesh::getNodes(m_node_tags, nodeCoords, nodeParams, -1, -1, false, false);
    std::size_t size_nodes_tags        = m_node_tags.size();
    std::size_t size_nodes_coordinates = nodeCoords.size();
    if (size_nodes_coordinates != 3 * size_nodes_tags) {
        throw std::runtime_error("Number of coordinates is not 3 times the number of vertices. Abort.");
    }
    for (std::size_t index_vertex = 0; index_vertex < size_nodes_tags; ++index_vertex) {
        add_k_point(nodeCoords[3 * index_vertex], nodeCoords[3 * index_vertex + 1], nodeCoords[3 * index_vertex + 2]);
    }
    gmsh::finalize();
    std::cout << "Number of k-points: " << m_kpoints.size() << std::endl;
}

void bz_mesh_points::add_band_on_mesh(const std::string& band_name, const std::vector<double>& band_values) {
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 99999999);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);

    int data_tag = gmsh::view::add(band_name);
    if (m_node_tags.size() != band_values.size()) {
        std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
        std::cout << "number of values: " << band_values.size() << std::endl;
        throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
    }
    gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, band_values);
    const int   index_view             = gmsh::view::getIndex(data_tag);
    std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
    gmsh::option::setNumber(name_object_visibility, 1);
    gmsh::view::write(data_tag, "band_mesh.msh", true);
    gmsh::finalize();
}

void bz_mesh_points::add_all_bands_on_mesh(const std::string&                             out_filename,
                                           const EmpiricalPseudopotential::BandStructure& my_band,
                                           int                                            nb_valence_bands_to_export,
                                           int                                            nb_conduction_bands_to_export) {
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);
    bool first_view = true;

    // We want to inverse the order of the valence bands so that the highest valence band is band 0
    int nb_valence_bands = my_band.is_soc_enabled() ? 8 : 4;
    int nb_bands         = my_band.get_number_of_bands();

    // Sanity checks
    if (nb_valence_bands_to_export < 0 || nb_valence_bands_to_export > nb_valence_bands) {
        nb_valence_bands_to_export = nb_valence_bands;
        std::cout << "Warning: nb_valence_bands_to_export is not valid. Setting it to " << nb_valence_bands << std::endl;
    }
    if (nb_conduction_bands_to_export < 0 || nb_conduction_bands_to_export > (nb_bands - nb_valence_bands)) {
        nb_conduction_bands_to_export = nb_bands - nb_valence_bands;
        std::cout << "Warning: nb_conduction_bands_to_export is not valid. Setting it to " << (nb_bands - nb_valence_bands) << std::endl;
    }

    int count = 0;
    if (nb_valence_bands_to_export != 0) {
        for (int index_band = nb_valence_bands - 1; index_band >= nb_valence_bands - nb_valence_bands_to_export; --index_band) {
            std::string         band_name   = "band_" + std::to_string(count);
            count++;
            std::vector<double> band_values = my_band.get_band(index_band);
            int                 data_tag    = gmsh::view::add(band_name);
            if (m_node_tags.size() != band_values.size()) {
                std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
                std::cout << "number of values: " << band_values.size() << std::endl;
                throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
            }
            gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, band_values);
            const int   index_view             = gmsh::view::getIndex(data_tag);
            std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
            gmsh::option::setNumber(name_object_visibility, 0);
            gmsh::option::setNumber("PostProcessing.SaveMesh", (first_view) ? 1 : 0);  // Save mesh only once
            gmsh::view::write(data_tag, out_filename, true);
            first_view = false;
        }
    }

    if (nb_conduction_bands_to_export != 0) {
        for (int index_band = nb_valence_bands; index_band < nb_valence_bands + nb_conduction_bands_to_export; ++index_band) {
            std::string         band_name   = "band_" + std::to_string(count);
            count++;
            std::vector<double> band_values = my_band.get_band(index_band);
            int                 data_tag    = gmsh::view::add(band_name);
            if (m_node_tags.size() != band_values.size()) {
                std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
                std::cout << "number of values: " << band_values.size() << std::endl;
                throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
            }
            gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, band_values);
            const int   index_view             = gmsh::view::getIndex(data_tag);
            std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
            gmsh::option::setNumber(name_object_visibility, 0);
            gmsh::option::setNumber("PostProcessing.SaveMesh", (first_view) ? 1 : 0);  // Save mesh only once
            gmsh::view::write(data_tag, out_filename, true);
            first_view = false;
        }
    }
    gmsh::finalize();
}

void bz_mesh_points::add_all_bands_on_mesh_separate_files(const std::string&                             out_dir,
                                                          const EmpiricalPseudopotential::BandStructure& my_band) {
    gmsh::initialize();
    try {
        gmsh::option::setNumber("General.Verbosity", 0);
        // Choose a stable MSH version (2.2 or 4.1 both fine)
        gmsh::option::setNumber("Mesh.MshFileVersion", 4.1);

        const std::size_t nbands = my_band.get_number_of_bands();

        for (std::size_t index_band = 0; index_band < nbands; ++index_band) {
            // Fresh model each band to avoid accumulating views
            gmsh::clear();
            gmsh::open(m_filename);  // load the base mesh

            std::string model_name;
            gmsh::model::getCurrent(model_name);

            // Always get node tags from THIS session/model
            std::vector<std::size_t> nodeTags;
            std::vector<double>      nodeCoords, nodeParams;
            gmsh::model::mesh::reclassifyNodes();
            gmsh::model::mesh::getNodes(nodeTags, nodeCoords, nodeParams);

            const std::vector<double> band_values = my_band.get_band(index_band);
            if (band_values.size() != nodeTags.size()) {
                std::cout << "Band " << index_band << " — node/value size mismatch: " << nodeTags.size() << " vs " << band_values.size()
                          << std::endl;
                throw std::runtime_error("Node/value size mismatch.");
            }

            const std::string band_name = "band_" + std::to_string(index_band);
            const int         view_tag  = gmsh::view::add(band_name);
            gmsh::view::addHomogeneousModelData(view_tag, 0, model_name, "NodeData", nodeTags, band_values);

            // Optional: hide in GUI
            const int index_view = gmsh::view::getIndex(view_tag);
            gmsh::option::setNumber("View[" + std::to_string(index_view) + "].Visible", 0);

            // Write ONE file per band: mesh + this single view
            // out_dir can be a directory path; we build "out_dir/band_<i>.msh"

            std::filesystem::create_directories(out_dir);  // Ensure the directory exists
            const std::string out_file = out_dir + "/band_" + std::to_string(index_band) + ".msh";
            gmsh::view::write(view_tag, out_file, true);
        }
    } catch (...) {
        try {
            gmsh::finalize();
        } catch (...) {
        }
        throw;
    }
    gmsh::finalize();
}

// void bz_mesh_points::add_all_bands_on_mesh(const std::string& out_dir, const EmpiricalPseudopotential::BandStructure& my_band) {
//     gmsh::initialize();
//     try {
//         gmsh::option::setNumber("General.Verbosity", 0);
//         // Choose a stable MSH version (2.2 or 4.1 both fine)
//         gmsh::option::setNumber("Mesh.MshFileVersion", 4.1);

//         const std::size_t nbands = my_band.get_number_of_bands();

//         for (std::size_t index_band = 0; index_band < nbands; ++index_band) {
//             // Fresh model each band to avoid accumulating views
//             gmsh::clear();
//             gmsh::open(m_filename);  // load the base mesh

//             std::string model_name;
//             gmsh::model::getCurrent(model_name);

//             // Always get node tags from THIS session/model
//             std::vector<std::size_t> nodeTags;
//             std::vector<double>      nodeCoords, nodeParams;
//             gmsh::model::mesh::reclassifyNodes();
//             gmsh::model::mesh::getNodes(nodeTags, nodeCoords, nodeParams);

//             const std::vector<double> band_values = my_band.get_band(index_band);
//             if (band_values.size() != nodeTags.size()) {
//                 std::cout << "Band " << index_band << " — node/value size mismatch: " << nodeTags.size() << " vs " << band_values.size()
//                           << std::endl;
//                 throw std::runtime_error("Node/value size mismatch.");
//             }

//             const std::string band_name = "band_" + std::to_string(index_band);
//             const int         view_tag  = gmsh::view::add(band_name);
//             gmsh::view::addHomogeneousModelData(view_tag, 0, model_name, "NodeData", nodeTags, band_values);

//             // Optional: hide in GUI
//             const int index_view = gmsh::view::getIndex(view_tag);
//             gmsh::option::setNumber("View[" + std::to_string(index_view) + "].Visible", 0);

//             // Write ONE file per band: mesh + this single view
//             // out_dir can be a directory path; we build "out_dir/band_<i>.msh"

//             std::filesystem::create_directories(out_dir);  // Ensure the directory exists
//             const std::string out_file = out_dir + "/band_" + std::to_string(index_band) + ".msh";
//             gmsh::view::write(view_tag, out_file, true);
//         }
//     } catch (...) {
//         try {
//             gmsh::finalize();
//         } catch (...) {
//         }
//         throw;
//     }
//     gmsh::finalize();
// }

/**
 * @brief Add band structure energies to gmsh mesh as views.
 * One view per band.
 *
 * The band structure is assumed to be given in band_values vector under the following format:
 * band_values[index_k_point * number_of_bands + index_band] = energy of the band with index index_band at k-point with index index_k_point.
 *
 * @param out_filename
 * @param band_values
 */
void bz_mesh_points::add_all_bands_on_mesh(const std::string& out_filename, const std::vector<double>& band_values, int number_bands) {
    if (band_values.size() != number_bands * m_node_tags.size()) {
        std::cout << "band_values.size(): " << band_values.size() << std::endl;
        std::cout << "number_bands: " << number_bands << std::endl;
        std::cout << "m_node_tags.size(): " << m_node_tags.size() << std::endl;
        std::cout << "m_kpts.size(): " << m_kpoints.size() << std::endl;
        std::cout << "number_bands * m_node_tags.size(): " << number_bands * m_node_tags.size() << std::endl;
        throw std::runtime_error("band_values vector is not the same size as the number of bands times the number of nodes. Abort.");
    }
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);

    for (int index_band = 0; index_band < number_bands; ++index_band) {
        std::string         band_name = "band_" + std::to_string(index_band);
        std::vector<double> current_band_values(m_node_tags.size());
        for (std::size_t index_node = 0; index_node < m_node_tags.size(); ++index_node) {
            current_band_values[index_node] = band_values[index_node * number_bands + index_band];
        }
        int data_tag = gmsh::view::add(band_name);
        if (m_node_tags.size() != current_band_values.size()) {
            std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
            std::cout << "number of values: " << current_band_values.size() << std::endl;
            throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
        }
        gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, current_band_values);
        const int   index_view             = gmsh::view::getIndex(data_tag);
        std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
        gmsh::option::setNumber(name_object_visibility, 0);
        gmsh::view::write(data_tag, out_filename, true);
    }
}

/**
 * @brief Export band structure energies to csv files (one file per band).
 *
 * The band structure is assumed to be given in band_values vector under the following format:
 * band_values[index_k_point * number_of_bands + index_band] = energy of the band with index index_band at k-point with index index_k_point.
 *
 * @param out_filename
 * @param band_values
 */
void bz_mesh_points::export_bands_as_csv(const std::vector<double>& band_values, int number_bands) {
    // if (band_values.size() != number_bands * m_node_tags.size()) {
    //     throw std::runtime_error("band_values vector is not the same size as the number of bands times the number of nodes. Abort.");
    // }
    for (int index_band = 0; index_band < number_bands; ++index_band) {
        std::string         band_name = "band_" + std::to_string(index_band);
        std::vector<double> current_band_values(m_node_tags.size());
        for (std::size_t index_node = 0; index_node < m_node_tags.size(); ++index_node) {
            current_band_values[index_node] = band_values[index_node * number_bands + index_band];
        }
        std::ofstream band_file(band_name + ".csv");
        for (std::size_t index_node = 0; index_node < m_node_tags.size(); ++index_node) {
            band_file << current_band_values[index_node] << std::endl;
        }
        band_file.close();
    }
}
#include "SymmetryPoints.h"

namespace EmpiricalPseudopotential {

SymmetryPoints::SymmetryPoints() {
    symmetryPoints["L"] = SymmetryPoint("L", Vector3D<double>(0.5, 0.5, 0.5));
    symmetryPoints["G"] = SymmetryPoint("G", Vector3D<double>(0., 0., 0.));
    symmetryPoints["X"] = SymmetryPoint("X", Vector3D<double>(1., 0., 0.));
    symmetryPoints["W"] = SymmetryPoint("W", Vector3D<double>(1., 0.5, 0.));
    symmetryPoints["K"] = SymmetryPoint("K", Vector3D<double>(0.75, 0.75, 0.));
    symmetryPoints["U"] = SymmetryPoint("U", Vector3D<double>(1., 0.25, 0.25));
}

/**
 * @brief Generates the list of k points for the given path of "symetry points".
 *
 * The path will be for example {"G", "X", "W", "L", "G", "K", "X"}
 * The number of points will be the total of points in the output.
 * The symmetryPointsPositions will be the positions (indexes) of the symmetry points in the output.
 *
 * The points are spaced in such way that the number of points between two symmetry points is "proportional" to the distance between them.
 *
 * @param path
 * @param nrPoints
 * @param symmetryPointsPositions
 * @return std::vector<Vector3D<double>>
 */
std::vector<Vector3D<double>> SymmetryPoints::GeneratePoints(const std::vector<std::string>& path,
                                                             unsigned int                    nrPoints,
                                                             std::vector<unsigned int>&      symmetryPointsPositions) {
    std::vector<Vector3D<double>> result;

    symmetryPointsPositions.clear();
    symmetryPointsPositions.reserve(path.size());

    if (nrPoints <= path.size() * 2 + 1) {
        std::cout << "Error: nrPoints must be greater than twice the number of symmetry points in the path + 1" << std::endl;
        return result;
    };

    result.reserve(nrPoints);

    // Calculate the length of each path segment, and add it to the total length.
    double length = 0.0;
    for (std::size_t index_HS_point = 1; index_HS_point < path.size(); ++index_HS_point) {
        const Vector3D<double> dif = symmetryPoints[path[index_HS_point]].position - symmetryPoints[path[index_HS_point - 1]].position;
        length += dif.Length();
    }

    const double stepSize = length / (nrPoints - 1.);

    for (std::size_t indexHSpoint = 1; indexHSpoint < path.size(); ++indexHSpoint) {
        const Vector3D<double> startPos  = symmetryPoints[path[indexHSpoint - 1ULL]].position;
        const Vector3D<double> dif       = symmetryPoints[path[indexHSpoint]].position - startPos;
        const double           difLength = dif.Length();

        Vector3D<double> stepVec = dif / difLength * stepSize;

        if (indexHSpoint == 1)
            symmetryPointsPositions.push_back(0.0);
        else
            symmetryPointsPositions.push_back(static_cast<unsigned int>(result.size() + 1));

        // Fill the path segment with k points spaced by stepVec.
        for (Vector3D<double> pos = startPos; (pos - startPos).Length() < difLength; pos += stepVec)
            result.push_back(pos);
    }

    return result;
}

}  // namespace EmpiricalPseudopotential/**
 * @file SpinOrbitFunctions.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-30
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <complex>
#include <iostream>
#include <string>
#include <system_error>
#include <vector>

#include "Constants.hpp"
#include "Material.h"
#include "SpinOrbitParameters.hpp"
#include "Vector3D.h"

namespace EmpiricalPseudopotential {

/**
 * @brief Functor class to compute the spin-orbit Hamiltonian.
 * The name of the functions follow the notation of the paper:
 * Pötz, W. & Vogl, P. Theory of optical-phonon deformation
 * potentials in tetrahedral semiconductors. Phys. Rev. B 24, 2025–2037 (1981).
 *
 */
class SpinOrbitCorrection {
 protected:
    SpinOrbitParameters m_soc_parameters;
    Material            m_material;

 public:
    SpinOrbitCorrection() = delete;
    SpinOrbitCorrection(const Material& material, const SpinOrbitParameters& SpinParams) : m_material(material), m_soc_parameters(SpinParams){
    };

    double compute_B2_cation(const Vector3D<double>& K) const;
    double compute_B2_anion(const Vector3D<double>& K) const;
    double compute_B3_cation(const Vector3D<double>& K) const;
    double compute_B3_anion(const Vector3D<double>& K) const;
    double compute_B4_cation(const Vector3D<double>& K) const;
    double compute_B4_anion(const Vector3D<double>& K) const;

    double compute_lambda_1(const Vector3D<double>& K, const Vector3D<double>& Kp) const;
    double compute_lambda_2(const Vector3D<double>& K, const Vector3D<double>& Kp) const;

    double compute_lambda_sym(const Vector3D<double>& K, const Vector3D<double>& Kp) const;
    double compute_lambda_antisym(const Vector3D<double>& K, const Vector3D<double>& Kp) const;

    Eigen::Matrix<std::complex<double>, 2, 2> compute_soc_contribution(const Vector3D<double>& K,
                                                                       const Vector3D<double>& Kp,
                                                                       const Vector3D<double>& G,
                                                                       const Vector3D<double>& Gp,
                                                                       const Vector3D<double>& tau) const;

    static Eigen::Matrix<std::complex<double>, 2, 2> compute_pauli_state_dot_product(const Vector3D<double>& a);
};

}  // namespace EmpiricalPseudopotential
#include "Options.h"

#include <iostream>

Options::Options()
    : nrThreads(4),
      materialName("Si"),
      nrPoints(60),
      nearestNeighbors(12),
      nrLevels(30),
      pathNo(1),
      paths{{
          {"K", "W", "X", "G", "L", "W"},
          {"W", "G", "X", "W", "L", "G"},
          {"W", "L", "G", "X", "W", "K"},
          {"L", "G", "X", "K", "G"},
          {"L", "G", "X", "W", "K", "G"},
          {"L", "G", "X", "U", "K", "G"},
          {"L", "G", "X", "U", "G"},
          {"L", "K", "W", "G", "X", "W", "L", "G", "K"},
          {"G", "X", "K", "G", "L", "K", "W", "X"},
          {"G", "X", "W", "L", "G", "K", "W", "U"},
          {"G", "X", "W", "L", "G", "K"},
          {"G", "X", "W", "L", "G", "K", "X"},
          {"G", "X", "W", "L", "G", "X"},
          {"G", "X", "W", "G", "U", "X"},
          {"G", "X", "W", "K", "L", "G"},
          {"G", "X", "W", "K", "G", "L", "U", "W", "L", "K"},
          {"G", "X", "U", "K", "G", "L", "W", "X"},
      }},
      m_fileconfig(nullptr) {}

void Options::print_options() {
    std::cout << "Options:" << std::endl;
    std::cout << "nrThreads: " << nrThreads << std::endl;
    std::cout << "materialName: " << materialName << std::endl;
    std::cout << "nrPoints: " << nrPoints << std::endl;
    std::cout << "nearestNeighbors: " << nearestNeighbors << std::endl;
    std::cout << "nrLevels: " << nrLevels << std::endl;
    std::cout << "pathNo: " << pathNo << std::endl;
    // std::cout << "paths: " << std::endl;
    // for (auto& path : paths) {
    //     for (auto& point : path) {
    //         std::cout << point << " ";
    //     }
    //     std::cout << std::endl;
    // }
}


/**
 * @file DielectricFunction.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-11-24
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "DielectricFunction.hpp"

#include <fmt/core.h>
#include <fmt/format.h>
#include <fmt/ostream.h>

#include <algorithm>
#include <chrono>
#include <cmath>
#include <fstream>
#include <iostream>
#include <random>
#include <vector>

#include "Hamiltonian.h"
#include "Material.h"

namespace EmpiricalPseudopotential {

bool is_in_irreducible_wedge(const Vector3D<double>& k) {
    return (k.Z >= 0.0) && (k.Y >= k.Z) && (k.X >= k.Y) && (k.X <= 1.0) && (k.X + k.Y + k.Z <= 3.0 / 2.0);
}

bool is_in_first_BZ(const Vector3D<double>& k, bool one_eighth = false) {
    bool cond_1      = fabs(k.X) <= 1.0 && fabs(k.Y) <= 1.0 && fabs(k.Z) <= 1.0;
    bool cond_2      = fabs(k.X) + fabs(k.Y) + fabs(k.Z) <= 3.0 / 2.0;
    bool cond_eighth = (k.X >= 0.0 && k.Y >= 0.0 && k.Z >= 0.0);
    return cond_1 && cond_2 && (one_eighth ? cond_eighth : true);
}

DielectricFunction::DielectricFunction(const Material& material, const std::vector<Vector3D<int>>& basisVectors, const int nb_bands)
    : m_basisVectors(basisVectors),
      m_material(material),
      m_nb_bands(nb_bands) {}

void DielectricFunction::generate_k_points_random(std::size_t nb_points) {
    std::random_device               rd;
    std::mt19937                     gen(rd());
    std::uniform_real_distribution<> dis(-1, 1.0);
    while (m_kpoints.size() < nb_points) {
        Vector3D<double> k(dis(gen), dis(gen), dis(gen));
        if (is_in_first_BZ(k)) {
            m_kpoints.push_back(k);
        }
    }
}

void DielectricFunction::generate_k_points_grid(std::size_t Nx, std::size_t Ny, std::size_t Nz, double shift, bool irreducible_wedge) {
    m_kpoints.clear();
    double min = -1.0 - shift;
    double max = 1.0 + shift;
    for (std::size_t i = 0; i < Nx - 1; ++i) {
        for (std::size_t j = 0; j < Ny - 1; ++j) {
            for (std::size_t k = 0; k < Nz - 1; ++k) {
                Vector3D<double> k_vect(min + (max - min) * i / static_cast<double>(Nx - 1),
                                        min + (max - min) * j / static_cast<double>(Ny - 1),
                                        min + (max - min) * k / static_cast<double>(Nz - 1));
                if (is_in_first_BZ(k_vect) && (!irreducible_wedge || is_in_irreducible_wedge(k_vect))) {
                    m_kpoints.push_back(k_vect);
                }
            }
        }
    }
}

/**
 * @brief Compute the energy and wave vector dependent dielectric function.
 * The formula used is the one from the paper "
 *
 * @param eta_smearing
 */
void DielectricFunction::compute_dielectric_function(double eta_smearing, int mpi_rank) {
    const int           index_first_conduction_band = 4;
    std::vector<double> iter_dielectric_function(m_kpoints.size());
    const bool          keep_eigenvectors = true;

    std::size_t nb_kpoints = m_kpoints.size();
    m_eigenvalues_k.resize(nb_kpoints);
    m_eigenvectors_k.resize(nb_kpoints);
    auto        start = std::chrono::high_resolution_clock::now();
    Hamiltonian hamiltonian_k(m_material, m_basisVectors);
    Hamiltonian hamiltonian_k_plus_q(m_material, m_basisVectors);
    for (std::size_t index_q = 0; index_q < m_qpoints.size(); ++index_q) {
        Vector3D<double>              q_vect = m_qpoints[index_q];
        if (q_vect.Length() <= 1e-15) {
            q_vect = Vector3D<double>(1e-15, 1e-15, 1e-15);
        }
        std::vector<Vector3D<double>> k_plus_q_vects(m_kpoints.size());
        std::transform(m_kpoints.begin(), m_kpoints.end(), k_plus_q_vects.begin(), [&q_vect](const Vector3D<double>& k) {
            return k + q_vect;
        });
        std::vector<double> list_total_sum(m_energies.size());
        for (std::size_t index_k = m_offset_k_index; index_k < m_offset_k_index + m_nb_kpoints; ++index_k) {
            if (index_q == 0) {
                auto k_vect = m_kpoints[index_k];
                hamiltonian_k.SetMatrix(k_vect, m_nonlocal_epm);
                hamiltonian_k.Diagonalize(keep_eigenvectors);
                m_eigenvalues_k[index_k]  = hamiltonian_k.eigenvalues();
                m_eigenvectors_k[index_k] = hamiltonian_k.get_eigenvectors();
                // Keep only firsts columns
                auto nb_rows = m_eigenvectors_k[index_k].rows();
                m_eigenvectors_k[index_k].conservativeResize(nb_rows, m_nb_bands);
            }
            auto k_plus_q_vect = k_plus_q_vects[index_k];
            hamiltonian_k_plus_q.SetMatrix(k_plus_q_vect, m_nonlocal_epm);
            hamiltonian_k_plus_q.Diagonalize(keep_eigenvectors);
            const auto&         eigenvalues_k_plus_q  = hamiltonian_k_plus_q.eigenvalues();
            const auto&         eigenvectors_k_plus_q = hamiltonian_k_plus_q.get_eigenvectors();
            std::vector<double> list_k_sum(m_energies.size());
            for (int idx_conduction_band = index_first_conduction_band; idx_conduction_band < m_nb_bands; ++idx_conduction_band) {
                for (int idx_valence_band = 0; idx_valence_band < index_first_conduction_band; ++idx_valence_band) {
                    double overlap_integral = pow(
                        std::abs(
                            eigenvectors_k_plus_q.col(idx_conduction_band).adjoint().dot(m_eigenvectors_k[index_k].col(idx_valence_band))),
                        2);
                    double delta_energy = (eigenvalues_k_plus_q[idx_conduction_band]) - m_eigenvalues_k[index_k][idx_valence_band];
                    for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
                        double energy = m_energies[index_energy];
                        double factor_1 =
                            (delta_energy - energy) / ((delta_energy - energy) * (delta_energy - energy) + eta_smearing * eta_smearing);
                        double factor_2 =
                            (delta_energy + energy) / ((delta_energy + energy) * (delta_energy + energy) + eta_smearing * eta_smearing);
                        double total_factor = factor_1 + factor_2;
                        list_k_sum[index_energy] += overlap_integral * total_factor;
                    }
                }
            }
            if (m_qpoints.size() <= 1) {
                // if there is only one q point in the list, we don't keep the eigenvectors, to save memory.
                m_eigenvectors_k[index_k].resize(1, 1);
                m_eigenvalues_k[index_k].resize(1);
            }
            for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
                list_total_sum[index_energy] += list_k_sum[index_energy];
            }
        }
        std::vector<double> list_epsilon(m_energies.size());
        for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
            list_epsilon[index_energy] = list_total_sum[index_energy];
        }
        auto end     = std::chrono::high_resolution_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() / 1000.0;
        if (mpi_rank == 0) {
            std::cout << "Computed dielectric function for q = " << m_qpoints[index_q] << " -> " << index_q + 1 << "/" << m_qpoints.size()
                      << " in " << elapsed << " s" << std::endl;
        }
        start = std::chrono::high_resolution_clock::now();
        m_dielectric_function_real.push_back(list_epsilon);
    }
}

DielectricFunction DielectricFunction::merge_results(DielectricFunction                                  RootDielectricFunction,
                                                     const std::vector<std::vector<std::vector<double>>>& dielectric_function_results,
                                                     std::vector<int>                                    nb_kpoints_per_instance) {
    std::vector<std::vector<double>> total_dielectric_function;
    if (dielectric_function_results.size() == 0) {
        throw std::runtime_error("No results to merge");
    }
    if (dielectric_function_results.size() != nb_kpoints_per_instance.size()) {
        throw std::runtime_error("Number of results and number of k-points per instance do not match");
    }
    std::size_t total_number_kpoints = 0;
    for (std::size_t index_instance = 0; index_instance < nb_kpoints_per_instance.size(); ++index_instance) {
        total_number_kpoints += nb_kpoints_per_instance[index_instance];
    }
    std::cout << "Number total kpoint to the merge : " << total_number_kpoints << std::endl;
    // Add-up the k-contributions.
    for (std::size_t index_instance = 0; index_instance < dielectric_function_results.size(); ++index_instance) {
        // Add the contributions to epsilon for each q-point and energy.
        for (std::size_t index_q = 0; index_q < dielectric_function_results[index_instance].size(); ++index_q) {
            if (index_instance == 0) {
                total_dielectric_function.push_back(dielectric_function_results[index_instance][index_q]);
            } else {
                for (std::size_t index_energy = 0; index_energy < dielectric_function_results[index_instance][index_q].size();
                     ++index_energy) {
                    total_dielectric_function[index_q][index_energy] += dielectric_function_results[index_instance][index_q][index_energy];
                }
            }
        }
    }
    // Renormalization
    double       renormalization = 1.0 / static_cast<double>(total_number_kpoints);
    std::cout << "Renormalization: " << renormalization << std::endl;
    for (std::size_t index_q = 0; index_q < total_dielectric_function.size(); ++index_q) {
        Vector3D<double> q_vect    = RootDielectricFunction.m_qpoints[index_q];
        double           q_squared = pow(q_vect.Length(), 2);
        // TO IMPROVE: This is a hack to avoid division by zero.
        if (q_squared == 0.0) {
            q_squared = 1e-14;
        }
        for (std::size_t index_energy = 0; index_energy < total_dielectric_function[index_q].size(); ++index_energy) {
            total_dielectric_function[index_q][index_energy] *= renormalization;
            total_dielectric_function[index_q][index_energy] =
                1.0 + (2.0 * M_PI / q_squared) * total_dielectric_function[index_q][index_energy];
        }
    }

    DielectricFunction dielectric_function         = RootDielectricFunction;
    dielectric_function.m_dielectric_function_real = total_dielectric_function;
    return dielectric_function;
}

Eigen::MatrixXd create_kramers_matrix(std::size_t N) {
    Eigen::MatrixXd kramers_matrix(N, N);
    for (std::size_t idx_line = 0; idx_line < N; ++idx_line) {
        for (std::size_t idx_col = 0; idx_col < N; ++idx_col) {
            if (idx_line == idx_col) {
                kramers_matrix(idx_line, idx_col) = 0.0;
            } else {
                double a = double(idx_line) / double(static_cast<long>(idx_col * idx_col) - static_cast<long>(idx_line * idx_line));
                kramers_matrix(idx_line, idx_col) = a;
            }
        }
    }
    kramers_matrix *= -2.0 / M_PI;
    return kramers_matrix;
}

void DielectricFunction::apply_kramers_kronig() {
    std::cout << "Applying Kramers-Kronig" << std::endl;
    std::fstream kramers_matrix_file;
    kramers_matrix_file.open("Bkramers_matrix.dat", std::ios::out);
    Eigen::MatrixXd kramers_matrix2 = create_kramers_matrix(6);
    kramers_matrix_file << kramers_matrix2 << std::endl;
    kramers_matrix_file.close();
    std::cout << "Kramers matrix created" << std::endl;
    m_dielectric_function_imag.clear();
    m_dielectric_function_imag.resize(m_dielectric_function_real.size());
    Eigen::MatrixXd kramers_matrix = create_kramers_matrix(m_energies.size());
    for (std::size_t idx_q = 0; idx_q < m_qpoints.size(); ++idx_q) {
        Eigen::VectorXd epsilon(m_energies.size());
        for (std::size_t idx_energy = 0; idx_energy < m_energies.size(); ++idx_energy) {
            epsilon(idx_energy) = m_dielectric_function_real[idx_q][idx_energy] - 1.0;
        }
        Eigen::VectorXd epsilon_imag = kramers_matrix * epsilon;
        m_dielectric_function_imag[idx_q].resize(m_energies.size());
        for (std::size_t idx_energy = 0; idx_energy < m_energies.size(); ++idx_energy) {
            m_dielectric_function_imag[idx_q][idx_energy] = epsilon_imag(idx_energy);
        }
    }
}

void DielectricFunction::export_dielectric_function_at_q(const std::string& filename, std::size_t idx_q, bool name_auto) const {
    std::string outname;
    if (name_auto) {
        // outname = m_export_prefix + '_' + std::to_string(idx_q) + '_' + std::to_string(m_qpoints[idx_q].X) + "_" +
        // std::to_string(m_qpoints[idx_q].Y) + "_" +
        //           std::to_string(m_qpoints[idx_q].Z) + ".csv";
        outname = fmt::format("{}_{:05}_{:.6f}_{:.6f}_{:.6f}.csv",
                              m_export_prefix,
                              idx_q,
                              m_qpoints[idx_q].X,
                              m_qpoints[idx_q].Y,
                              m_qpoints[idx_q].Z);
    } else {
        outname = filename;
    }
    std::ofstream outfile(outname);
    std::cout << m_energies[0] << " " << m_dielectric_function_real[idx_q][0] << std::endl;
    outfile << "Energy (eV),EpsilonReal,EpsilonImaginary" << std::endl;
    for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
        outfile << m_energies[index_energy] << "," << m_dielectric_function_real[idx_q][index_energy] << ","
                << m_dielectric_function_imag[idx_q][index_energy] << std::endl;
    }
    outfile.close();
}

void DielectricFunction::export_dielectric_function(const std::string& filename, bool name_auto) const {
    for (std::size_t index_q = 0; index_q < m_qpoints.size(); ++index_q) {
        export_dielectric_function_at_q(filename, index_q, name_auto);
    }
}

void DielectricFunction::export_kpoints(const std::string& filename) const {
    std::ofstream file(filename);
    file << "X,Y,Z" << std::endl;
    for (const auto& k : m_kpoints) {
        file << k.X << "," << k.Y << "," << k.Z << std::endl;
    }
}

}  // namespace EmpiricalPseudopotential/**
 * @file NonLocalParameters.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-26
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <iostream>
#include <string>
#include <system_error>

#include "Constants.hpp"
#include "yaml-cpp/yaml.h"

namespace EmpiricalPseudopotential {

enum class non_local_well_type { square, gaussian, unknown };

/**
 * @brief Struct to store the non-local parameters.
 *
 * The formalism is taken from: 1. Pötz, W. & Vogl, P. Theory of optical-phonon deformation potentials in tetrahedral semiconductors.
 *  Phys. Rev. B 24, 2025–2037 (1981).
 *
 */
struct NonLocalParameters {
    double              m_alpha_0_cation;
    double              m_beta_0_cation;
    double              m_A2_cation;
    double              m_alpha_0_anion;
    double              m_beta_0_anion;
    double              m_A2_anion;
    double              m_R0_cation;
    double              m_R2_cation;
    double              m_R0_anion;
    double              m_R2_anion;
    non_local_well_type m_well_type;

    NonLocalParameters()
        : m_alpha_0_cation(0.0),
          m_beta_0_cation(0.0),
          m_A2_cation(0.0),
          m_alpha_0_anion(0.0),
          m_beta_0_anion(0.0),
          m_A2_anion(0.0),
          m_R0_cation(0.0),
          m_R2_cation(0.0),
          m_R0_anion(0.0),
          m_R2_anion(0.0),
          m_well_type(non_local_well_type::unknown) {}

    NonLocalParameters(double              alpha_0_cation,
                       double              beta_0_cation,
                       double              A2_cation,
                       double              alpha_0_anion,
                       double              beta_0_anion,
                       double              A2_anion,
                       double              R0_cation,
                       double              R2_cation,
                       double              R0_anion,
                       double              R2_anion,
                       non_local_well_type well_type)
        : m_alpha_0_cation(alpha_0_cation),
          m_beta_0_cation(beta_0_cation),
          m_A2_cation(A2_cation),
          m_alpha_0_anion(alpha_0_anion),
          m_beta_0_anion(beta_0_anion),
          m_A2_anion(A2_anion),
          m_R0_cation(R0_cation),
          m_R2_cation(R2_cation),
          m_R0_anion(R0_anion),
          m_R2_anion(R2_anion),
          m_well_type(well_type) {
        m_alpha_0_cation *= Constants::Ryd_to_eV;
        m_alpha_0_anion *= Constants::Ryd_to_eV;
        m_A2_cation *= Constants::Ryd_to_eV;
        m_A2_anion *= Constants::Ryd_to_eV;

        m_R0_anion *= Constants::angstrom_to_m;
        m_R2_anion *= Constants::angstrom_to_m;
        m_R0_cation *= Constants::angstrom_to_m;
        m_R2_cation *= Constants::angstrom_to_m;
    }

    void populate_non_local_parameters(const YAML::Node& node) {
        m_alpha_0_cation                        = Constants::Ryd_to_eV * node["alpha_0_cation"].as<double>();
        m_beta_0_cation                         = node["beta_0_cation"].as<double>();
        m_A2_cation                             = Constants::Ryd_to_eV * node["A2_cation"].as<double>();
        m_alpha_0_anion                         = Constants::Ryd_to_eV * node["alpha_0_anion"].as<double>();
        m_beta_0_anion                          = node["beta_0_anion"].as<double>();
        m_A2_anion                              = Constants::Ryd_to_eV * node["A2_anion"].as<double>();
        m_R0_cation                             = node["R0_cation"].as<double>();
        m_R2_cation                             = node["R2_cation"].as<double>();
        m_R0_anion                              = node["R0_anion"].as<double>();
        m_R2_anion                              = node["R2_anion"].as<double>();
        const std::string   well_type           = node["well_type"].as<std::string>();
        non_local_well_type non_local_well_type = non_local_well_type::unknown;
        if (well_type == "square") {
            non_local_well_type = non_local_well_type::square;
        } else if (well_type == "gaussian") {
            non_local_well_type = non_local_well_type::gaussian;
        } else {
            throw std::runtime_error("Unknown non-local well type");
        }
        m_well_type = non_local_well_type;
        m_R0_anion *= Constants::angstrom_to_m;
        m_R2_anion *= Constants::angstrom_to_m;
        m_R0_cation *= Constants::angstrom_to_m;
        m_R2_cation *= Constants::angstrom_to_m;
    }

    void print_non_local_parameters() const {
        std::cout << "alpha_0_cation: " << m_alpha_0_cation << std::endl;
        std::cout << "beta_0_cation: " << m_beta_0_cation << std::endl;
        std::cout << "A2_cation: " << m_A2_cation << std::endl;
        std::cout << "alpha_0_anion: " << m_alpha_0_anion << std::endl;
        std::cout << "beta_0_anion: " << m_beta_0_anion << std::endl;
        std::cout << "A2_anion: " << m_A2_anion << std::endl;
        std::cout << "R0_cation: " << m_R0_cation << std::endl;
        std::cout << "R2_cation: " << m_R2_cation << std::endl;
        std::cout << "R0_anion: " << m_R0_anion << std::endl;
        std::cout << "R2_anion: " << m_R2_anion << std::endl;
        std::cout << "well_type: " << static_cast<int>(m_well_type) << std::endl;
    }
};
}  // namespace EmpiricalPseudopotential/**
 * @file bessel_func.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-10
 *
 * @copyright Copyright (c) 2022
 *
 */

#include <cmath>
#include <iostream>

constexpr double pi = M_PI;

inline double J_neg_v(double v, double x) {
    return std::cos(-v * pi) * std::cyl_bessel_j(-v, x) - std::sin(-v * pi) * std::cyl_neumann(-v, x);
}

inline double generalized_bessel_cylindrical(double nu, double x) {
    if (nu >= 0) {
        return std::cyl_bessel_j(nu, x);
    } else {
        return J_neg_v(nu, x);
    }
}

inline double generalized_bessel(double nu, double x) {
    constexpr double epsilon = 1e-14;
    if (x < 0) {
        throw std::invalid_argument("Bessel function x argument must be positive. (x = " + std::to_string(x) + ")");
    }
    if (x < epsilon && nu == 0) {
        return 1.0;
    }
    if (x < epsilon && nu == 1) {
        return 0.0;
    }
    if (x < epsilon && nu >= 2) {
        return 0.0;
    }

    return sqrt(M_PI / (2.0 * x)) * generalized_bessel_cylindrical(nu + 0.5, x);
}

inline double bessel_2nd_order_first_kind(double x) {
    if (x == 0.0) {
        return 0.0;
    }
    return ((x * x + 3) * sinh(x) - 3 * x * cosh(x)) / (x * x * x);
}#include "Hamiltonian.h"

#define _USE_MATH_DEFINES 1
#include <math.h>

#include <complex>
#include <iostream>
#include <vector>

#include "Constants.hpp"
#include "NonLocalFunctional.hpp"
#include "SpinOrbitFunctional.hpp"
#include "Vector3D.h"

namespace EmpiricalPseudopotential {

Hamiltonian::Hamiltonian(const Material& material, const std::vector<Vector3D<int>>& basisVectors)
    : m_material(material),
      m_basisVectors(basisVectors) {
    const unsigned int basisSize   = static_cast<unsigned int>(basisVectors.size());
    m_constant_non_diagonal_matrix = Eigen::MatrixXcd::Zero(basisSize, basisSize);
    SetConstantNonDiagonalMatrix();
    matrix.resize(basisSize, basisSize);
}

/**
 * @brief Set the constant part of the Hamiltonian matrix.
 * The non-diagonal part of the matrix does not depend on the k-point, except for the non-local correction.
 *
 */
void Hamiltonian::SetConstantNonDiagonalMatrix() {
    const std::size_t     basisSize       = static_cast<unsigned int>(m_basisVectors.size());
    const double          latticeConstant = m_material.get_lattice_constant_meter();
    const Pseudopotential pseudopotential = m_material.get_pseudopotential();

    constexpr double one_eight = 1.0 / 8.0;
    Vector3D<double> tau{one_eight * latticeConstant, one_eight * latticeConstant, one_eight * latticeConstant};
    for (unsigned int i = 0; i < basisSize; ++i) {
        for (unsigned int j = 0; j < basisSize; ++j) {
            m_constant_non_diagonal_matrix(i, j) = pseudopotential.GetValue(m_basisVectors[i] - m_basisVectors[j], tau, latticeConstant);
        }
    }
}

void Hamiltonian::SetMatrix(const Vector3D<double>& k, bool add_non_local_correction, bool enable_soc) {
    const unsigned int basisSize       = static_cast<unsigned int>(m_basisVectors.size());
    const double       latticeConstant = m_material.get_lattice_constant_meter();
    constexpr double   one_eight       = 1.0 / 8.0;
    Vector3D<double>   tau{one_eight * latticeConstant, one_eight * latticeConstant, one_eight * latticeConstant};
    const double       fourier_factor = 2.0 * M_PI / latticeConstant;
    matrix                            = m_constant_non_diagonal_matrix;
    // diagonal elements
    const double diag_factor = pow(Constants::h_bar, 2) / (2.0 * Constants::m_e * Constants::q_e);
    for (unsigned int i = 0; i < basisSize; ++i) {
        Vector3D<double> real_k_vector = (k + m_basisVectors[i]);
        const double     KG2           = fourier_factor * fourier_factor * diag_factor * (real_k_vector * real_k_vector);
        matrix(i, i)                   = std::complex<double>(KG2, 0);
        // Non local correction
        if (add_non_local_correction) {
            std::complex<double> nl_correction = m_material.compute_pseudopotential_non_local_correction(real_k_vector, real_k_vector, tau);
            matrix(i, i) += nl_correction;
        }
    }

    // const Pseudopotential pseudopotential = m_material.get_pseudopotential();
    if (add_non_local_correction) {
        for (unsigned int i = 0; i < basisSize; ++i) {
            for (unsigned int j = 0; j < basisSize; ++j) {
                Vector3D<double> k_vector_i = (k + m_basisVectors[i]);
                Vector3D<double> k_vector_j = (k + m_basisVectors[j]);
                matrix(i, j) += m_material.compute_pseudopotential_non_local_correction(k_vector_i, k_vector_j, tau);
            }
        }
    }

    if (enable_soc) {
        // std::cout << "Spin-orbit correction enabled" << std::endl;
        SpinOrbitParameters SpinParams = m_material.get_spin_orbit_parameters();
        SpinOrbitCorrection soc_correction(m_material, SpinParams);
        std::size_t         matrix_size    = matrix.rows();
        Eigen::MatrixXcd    UpDownMatrix   = Eigen::MatrixXcd::Zero(matrix_size, matrix_size);
        Eigen::MatrixXcd    DownUpMatrix   = Eigen::MatrixXcd::Zero(matrix_size, matrix_size);
        Eigen::MatrixXcd    UpUpMatrix     = matrix;
        Eigen::MatrixXcd    DownDownMatrix = matrix;
        for (unsigned int i = 0; i < matrix_size; ++i) {
            for (unsigned int j = 0; j < matrix_size; ++j) {
                Vector3D<double>                          k_vector_i = (k + m_basisVectors[i]);
                Vector3D<double>                          k_vector_j = (k + m_basisVectors[j]);
                Eigen::Matrix<std::complex<double>, 2, 2> soc_contribution =
                    soc_correction.compute_soc_contribution(k_vector_i, k_vector_j, m_basisVectors[i], m_basisVectors[j], tau);
                // std::cout << soc_contribution << std::endl;
                UpUpMatrix(i, j) += soc_contribution(0, 0);
                UpDownMatrix(i, j) += soc_contribution(1, 0);
                DownUpMatrix(i, j) += soc_contribution(0, 1);
                DownDownMatrix(i, j) += soc_contribution(1, 1);
            }
        }
        matrix.resize(2 * matrix_size, 2 * matrix_size);
        matrix << UpUpMatrix, UpDownMatrix, DownUpMatrix, DownDownMatrix;
    }
}

void Hamiltonian::Diagonalize(bool keep_eigenvectors) {
    // Check matrix is Hermitian
    if (!matrix.isApprox(matrix.adjoint())) {
        std::cout << "Matrix is not Hermitian!" << std::endl;
        throw std::runtime_error("Matrix is not Hermitian");
    }
    solver.compute(matrix, keep_eigenvectors ? Eigen::ComputeEigenvectors : Eigen::EigenvaluesOnly);
    if (solver.info() != Eigen::Success) {
        std::cout << matrix << std::endl;
        throw std::runtime_error("Eigenvalue decomposition failed");
    }
}

}  // namespace EmpiricalPseudopotential/**
 * @file SpinOrbitParameters.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-30
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <iostream>
#include <string>
#include <system_error>

#include "Constants.hpp"
#include "yaml-cpp/yaml.h"

namespace EmpiricalPseudopotential {

/**
 * @brief Struct to store the Spin-Orbit Coupling (SOC) parameters.
 *
 */
struct SpinOrbitParameters {
    /**
     * @brief Period of the anion (line number in the periodic table).
     *
     */
    unsigned int m_period_anion = 0;

    /**
     * @brief Period of the cation (line number in the periodic table).
     *
     */
    unsigned int m_period_cation = 0;

    /**
     * @brief Length scale of the radial wave function for the cation.
     *
     */
    double m_radial_extent_cation = 0;

    /**
     * @brief Length scale of the radial wave function for the anion.
     *
     */
    double m_radial_extent_anion = 0;

    /**
     * @brief Fitting parameter alpha.
     *
     */
    double m_alpha = 0;

    /**
     * @brief Fitting parameter beta.
     *
     */
    double m_mu = 0;

    /**
     * @brief Default constructor.
     *
     */
    SpinOrbitParameters() = default;

    // Copy constructor
    SpinOrbitParameters(const SpinOrbitParameters& other) = default;
    SpinOrbitParameters& operator=(const SpinOrbitParameters& other) = default;
    SpinOrbitParameters(SpinOrbitParameters&& other)                 = default;

    /**
     * @brief Populate the spin-orbit parameters from a YAML node.
     *
     * @param node
     */
    void populate_from_yaml(const YAML::Node& node) {
        m_period_anion         = node["period_anion"].as<unsigned int>();
        m_period_cation        = node["period_cation"].as<unsigned int>();
        m_radial_extent_anion  = node["radial_extent_anion"].as<double>();
        m_radial_extent_cation = node["radial_extent_cation"].as<double>();
        m_alpha                = node["alpha_soc"].as<double>();
        m_mu                   = 1.0 * Constants::Ryd_to_eV * node["mu_soc"].as<double>();
        // print_parameters();
    }

    /**
     * @brief Display the spin-orbit parameters.
     *
     */
    void print_parameters() const {
        std::cout << "Spin-Orbit Coupling parameters:" << std::endl;
        std::cout << "Period anion: " << m_period_anion << std::endl;
        std::cout << "Period cation: " << m_period_cation << std::endl;
        std::cout << "Radial extent anion: " << m_radial_extent_anion << std::endl;
        std::cout << "Radial extent cation: " << m_radial_extent_cation << std::endl;
        std::cout << "Alpha: " << m_alpha << std::endl;
        std::cout << "Mu: " << m_mu << std::endl;
    }
};

}  // namespace EmpiricalPseudopotential// /**
//  * @file NonLocalFunctional.cpp
//  * @author remzerrr (remi.helleboid@gmail.com)
//  * @brief
//  * @version 0.1
//  * @date 2022-10-01
//  *
//  * @copyright Copyright (c) 2022
//  *
//  */

// #include "NonLocalFunctional.hpp"

// #include "Vector3D.h"
// #include "bessel_func.hpp"

// namespace EmpiricalPseudopotential {

// /**
//  * @brief Constructor of the NonLocalFunctional functor.
//  *
//  * @param non_local_parameters
//  * @param material
//  * @param tau
//  */
// NonLocalFunctor::NonLocalFunctor(const NonLocalParameters& non_local_parameters, const Material& material, const Vector3D<double>& tau)
//     : m_non_local_parameters(non_local_parameters),
//       m_material(material),
//       m_tau(tau),
//       m_cinetic_factor{(Constants::h_bar * Constants::h_bar) / (2.0 * Constants::m_e * Constants::q_e)},
//       m_fourrier_factor{2.0 * M_PI / m_material.get_lattice_constant_meter()},
//       m_V0_pref_factor(2.0 * M_PI / m_material.get_lattice_constant_meter()),
//       m_V2_square_well_pref_factor{m_V0_pref_factor},
//       m_V2_gaussian_well_pref_factor{pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_anion, 3.0) / m_material.get_atomic_volume())} {}


// /**
//  * @brief Compute the so called F_l function, which is used in the non-local pseudopotential correction.
//  * (See Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
//  * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).)
//  *
//  * For the values of function, see: Bloomfield, J. K., Face, S. H. P. & Moss, Z. Indefinite Integrals of Spherical Bessel
//  * Functions. Preprint at http://arxiv.org/abs/1703.06428 (2017). Equations 49 and 59.
//  *
//  * @param K1
//  * @param K2
//  * @param atomic_radii
//  * @param l
//  * @return double
//  */
// double NonLocalFunctorF_l_function(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii, int l) {
//     // This epsilon is used to avoid division by zero in the case of K1 == K2.
//     // The value is quite big, but lower values lead to numerical instabilities (noisy bands).
//     // Reason: K1 and K2 are of the order of  2PI / a_0 ~ 1e10 !
//     constexpr double EPSILON = 1.0e-4;
//     const double     norm_K1 = K1.Length();
//     const double     norm_K2 = K2.Length();
//     if (fabs(norm_K1 - norm_K2) > EPSILON) {
//         const double pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
//         const double F = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
//                          norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
//         return pre_factor * F;
//     } else if (norm_K1 > EPSILON) {
//         const double pre_factor = pow(atomic_radii, 3.0) / (2.0);
//         const double F          = pow(generalized_bessel(l, norm_K1 * atomic_radii), 2.0) -
//                          generalized_bessel(l - 1, norm_K1 * atomic_radii) * generalized_bessel(l + 1, norm_K1 * atomic_radii);
//         return pre_factor * F;
//     } else {
//         return (l==0) ? pow(atomic_radii, 3.0) / (3.0) : 0.0;
//     }
// }

// double F_2_function_gaussian(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii) {
//     const double norm_K1    = K1.Length();
//     const double norm_K2    = K2.Length();
//     const double bessel_arg = 0.5 * (atomic_radii * atomic_radii) * norm_K1 * norm_K2;
//     return bessel_2nd_order_first_kind(bessel_arg) * exp(-0.25 * (norm_K1 * norm_K1 + norm_K2 * norm_K2) * atomic_radii * atomic_radii);
// }

// /**
//  * @brief Compute the non local correction to the EPM Hamiltonian.
//  * It follows: Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
//  * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).
//  * See also: Pötz, W. & Vogl, P. Theory of optical-phonon deformation
//  * potentials in tetrahedral semiconductors. Phys. Rev. B 24, 2025–2037 (1981)
//  *
//  * K1 = (k + G)
//  * K2 = (k + G')
//  * tau = 1/8 * a * (1, 1, 1)
//  *
//  * @warning This function aims to be as close as possible to the original implementation of the authors.
//  * It might not be the most efficient way, even though the compiler may optimize it for us.
//  *
//  * @warning Only square well pseudopotential are supported for now on.
//  *
//  * @param K1
//  * @param K2
//  * @param tau
//  * @return std::complex<double>
//  */
// std::complex<double> Material::compute_pseudopotential_non_local_correction(const Vector3D<double>& K1_normalized,
//                                                                             const Vector3D<double>& K2_normalized,
//                                                                             const Vector3D<double>& tau) const {
//     const double           diag_factor       = pow(Constants::h_bar, 2) / (2.0 * Constants::m_e * Constants::q_e);
//     const double           fourier_factor    = 2.0 * M_PI / get_lattice_constant_meter();
//     const Vector3D<double> G_diff_normalized = (K1_normalized - K2_normalized);
//     const Vector3D<double> K1                = K1_normalized * fourier_factor;
//     const Vector3D<double> K2                = K2_normalized * fourier_factor;
//     const double           norm_K1           = K1.Length();
//     const double           norm_K2           = K2.Length();
//     const double           cos_angle_K1_K2   = compute_cos_angle(K1, K2);
//     const double           V_pre_factor      = 4.0 * M_PI / get_atomic_volume();
//     const double           legendre_0        = 1.0;
//     const double           legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);

//     // First atomic species: anion
//     double V_anion = 0;
//     // l = 0
//     const double A_0_anion = m_non_local_parameters.m_alpha_0_anion + diag_factor * m_non_local_parameters.m_beta_0_anion *
//                                                                           (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
//     const double F_0_anion = (m_non_local_parameters.m_R0_anion == 0.0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_anion, 0);
//     V_anion += V_pre_factor * A_0_anion * (2 * 0 + 1) * 1.0 * F_0_anion;
//     // l = 2
//     double V_anion_2 = 0.0;
//     if (m_non_local_parameters.m_A2_anion != 0) {
//         const double A_2_anion = m_non_local_parameters.m_A2_anion;
//         double       F_2_anion = 0.0;
//         if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
//             F_2_anion = F_l_function(K1, K2, m_non_local_parameters.m_R2_anion, 2);
//             V_anion_2 = V_pre_factor * A_2_anion * (2 * 2 + 1) * legendre_2 * F_2_anion;
//         } else {
//             F_2_anion = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_anion);
//             V_anion_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_anion, 3.0) / get_atomic_volume()) * A_2_anion *
//                         legendre_2 * F_2_anion;
//         }
//         V_anion += V_anion_2;
//     }

//     // Second atomic species: cation
//     double V_cation = 0;
//     // l = 0
//     const double F_0_cation = (m_non_local_parameters.m_R0_cation == 0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_cation, 0);
//     const double A_0_cation = m_non_local_parameters.m_alpha_0_cation + m_non_local_parameters.m_beta_0_cation * diag_factor *
//                                                                             (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
//     V_cation += V_pre_factor * A_0_cation * (2 * 0 + 1) * legendre_0 * F_0_cation;
//     // l = 2
//     double V_cation_2 = 0.0;
//     if (m_non_local_parameters.m_A2_cation != 0.0) {
//         const double A_2_cation = m_non_local_parameters.m_A2_cation;
//         double       F_2_cation = 0.0;
//         if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
//             F_2_cation = F_l_function(K1, K2, m_non_local_parameters.m_R2_cation, 2);
//             V_cation_2 = V_pre_factor * A_2_cation * (2 * 2 + 1) * legendre_2 * F_2_cation;
//         } else {
//             F_2_cation = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_cation);
//             V_cation_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_cation, 3.0) / get_atomic_volume()) * A_2_cation *
//                          legendre_2 * F_2_cation;
//         }
//         V_cation += V_cation_2;
//     }

//     const double V_symmetric     = 1.0 * (V_anion + V_cation) / 2.0;
//     const double V_antisymmetric = 1.0 * (V_anion - V_cation) / 2.0;

//     constexpr double const_two        = 2.0;
//     const double     lattice_constant = this->get_lattice_constant_meter();
//     const double     Gtau             = (tau / lattice_constant) * (G_diff_normalized);

//     return std::complex<double>(cos(const_two * M_PI * Gtau) * V_symmetric, sin(const_two * M_PI * Gtau) * V_antisymmetric);
// }

// // /**
// //  * @brief Return the value of the F_l function for l = 0, at K1 == K2 == 0.
// //  *
// //  * @param norm_K
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_0_Gamma(double atomic_radii) const { return pow(atomic_radii, 3.0) / 3.0; }

// // /**
// //  * @brief Return the value of the F_l function for l = 0, at K1 == K2 (diagonal term).
// //  *
// //  * @param norm_K1
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_0_diag(double norm_K1, double atomic_radii) const {
// //     constexpr int l          = 0;
// //     const double  pre_factor = pow(atomic_radii, 3.0) / 2.0;
// //     const double  F          = pow(generalized_bessel(l, norm_K1 * atomic_radii), 2.0) -
// //                      generalized_bessel(l - 1, norm_K1 * atomic_radii) * generalized_bessel(l + 1, norm_K1 * atomic_radii);
// //     return m_V0_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 0, at K1 != K2 (coupling term).
// //  *
// //  * @param norm_K1
// //  * @param norm_K2
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_0_coupling(double norm_K1, double norm_K2, double atomic_radii) const {
// //     constexpr int l          = 0;
// //     const double  pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
// //     const double  F          = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
// //                      norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
// //     return m_V0_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 2, at K1 == K2 == 0 for a square potential.
// //  *
// //  * @param norm_K
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_2_diag_square_potential(double norm_K, double atomic_radii) const {
// //     constexpr int l          = 2;
// //     const double  pre_factor = pow(atomic_radii, 3.0) / 2.0;
// //     const double  F          = pow(generalized_bessel(l, norm_K * atomic_radii), 2.0) -
// //                      generalized_bessel(l - 1, norm_K * atomic_radii) * generalized_bessel(l + 1, norm_K * atomic_radii);
// //     return m_V2_square_well_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 2, at K1 =! K2 for a square potential.
// //  *
// //  * @param norm_K1
// //  * @param norm_K2
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_2_coupling_square_potential(double norm_K1, double norm_K2, double atomic_radii) const {
// //     constexpr int l          = 2;
// //     const double  pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
// //     const double  F          = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
// //                      norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
// //     return m_V2_square_well_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 2, at any K1, K2 for a gaussian potential.
// //  *
// //  * @param norm_K
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_2_gaussian(double norm_K1, double norm_K2, double atomic_radii) const {
// //     const double bessel_arg = 0.5 * (atomic_radii * atomic_radii) * norm_K1 * norm_K2;
// //     return m_V2_gaussian_well_pref_factor * bessel_2nd_order_first_kind(bessel_arg) *
// //            exp(-0.25 * (norm_K1 * norm_K1 + norm_K2 * norm_K2) * atomic_radii * atomic_radii);
// // }

// // double NonLocalFunctor::compute_anion_non_local_correction(const Vector3D<double>& K1_normalized,
// //                                                            const Vector3D<double>& K2_normalized) const {
// //     if (m_non_local_parameters.m_R0_anion == 0.0) {
// //         return 0.0;
// //     }
// //     const double cos_angle_K1_K2   = compute_cos_angle(K1_normalized, K2_normalized);
// //     const double legendre_0        = 1.0;
// //     const double legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);
// //     const double norm_K1_normlized = K1_normalized.Length();
// //     const double norm_K2_normlized = K2_normalized.Length();
// //     const double norm_K1           = norm_K1_normlized * m_fourrier_factor;
// //     const double norm_K2           = norm_K2_normlized * m_fourrier_factor;
// //     const double A_0_anion         = m_non_local_parameters.m_alpha_0_anion + m_cinetic_factor * m_non_local_parameters.m_beta_0_anion *
// //                                                                           (norm_K1 * norm_K2 - pow(m_material.get_fermi_momentum(), 2.0));
// //     double F_0 = 0.0;
// //     double F_2 = 0.0;
// //     if (fabs(norm_K1_normlized - norm_K2_normlized) > m_epsilon) {
// //         F_0 = F_0_coupling(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_coupling_square_potential(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //     } else if (norm_K1_normlized > m_epsilon) {
// //         F_0 = F_0_diag(norm_K1, m_non_local_parameters.m_R0_anion);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_diag_square_potential(norm_K1, m_non_local_parameters.m_R0_anion)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //     } else if (norm_K1 < m_epsilon) {
// //         F_0 = F_0_Gamma(m_non_local_parameters.m_R0_anion);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_Gamma_square_potential()
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //     }
// //     return A_0_anion * legendre_0 * F_0 + m_non_local_parameters.m_A2_anion * legendre_2 * F_2;
// // }

// // double NonLocalFunctor::compute_cation_non_local_correction(const Vector3D<double>& K1_normalized,
// //                                                             const Vector3D<double>& K2_normalized) const {
// //     if (m_non_local_parameters.m_R0_cation == 0.0) {
// //         return 0.0;
// //     }
// //     const double cos_angle_K1_K2   = compute_cos_angle(K1_normalized, K2_normalized);
// //     const double legendre_0        = 1.0;
// //     const double legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);
// //     const double norm_K1_normlized = K1_normalized.Length();
// //     const double norm_K2_normlized = K2_normalized.Length();
// //     const double norm_K1           = norm_K1_normlized * m_fourrier_factor;
// //     const double norm_K2           = norm_K2_normlized * m_fourrier_factor;
// //     const double A_0_cation        = m_non_local_parameters.m_alpha_0_cation + m_cinetic_factor * m_non_local_parameters.m_beta_0_cation *
// //                                                                             (norm_K1 * norm_K2 - pow(m_material.get_fermi_momentum(), 2.0));
// //     double F_0 = 0.0;
// //     double F_2 = 0.0;
// //     if (fabs(norm_K1_normlized - norm_K2_normlized) > m_epsilon) {
// //         F_0 = F_0_coupling(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_coupling_square_potential(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //     } else if (norm_K1_normlized > m_epsilon) {
// //         F_0 = F_0_diag(norm_K1, m_non_local_parameters.m_R0_cation);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_diag_square_potential(norm_K1, m_non_local_parameters.m_R0_cation)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //     } else if (norm_K1 < m_epsilon) {
// //         F_0 = F_0_Gamma(m_non_local_parameters.m_R0_cation);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_Gamma_square_potential()
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //     }
// //     return A_0_cation * legendre_0 * F_0 + m_non_local_parameters.m_A2_cation * legendre_2 * F_2;
// // }

// // std::complex<double> NonLocalFunctor::operator()(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized) const {
// //     const Vector3D<double> G_diff_normalized           = K1_normalized - K2_normalized;
// //     const double           anion_non_local_correction  = compute_anion_non_local_correction(K1_normalized, K2_normalized);
// //     const double           cation_non_local_correction = compute_cation_non_local_correction(K1_normalized, K2_normalized);
// //     const double           V_symmetric                 = anion_non_local_correction + cation_non_local_correction;
// //     const double           V_antisymmetric             = anion_non_local_correction - cation_non_local_correction;
// //     constexpr double       const_two                   = 2.0;
// //     const double           lattice_constant            = m_material.get_lattice_constant_meter();
// //     const double           Gtau                        = (m_tau / lattice_constant) * (G_diff_normalized);

// //     return std::complex<double>(cos(const_two * M_PI * Gtau) * V_symmetric, sin(const_two * M_PI * Gtau) * V_antisymmetric);
// // }

// }  // namespace EmpiricalPseudopotential/**
 * @file bz_mesh.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-07
 *
 * @copyright Copyright (c) 2022
 *
 */

#include <iostream>
#include <string>

#include "BandStructure.h"
#include "Vector3D.h"
#include "gmsh.h"

class bz_mesh_points {
 private:
    std::string                   m_filename;
    std::size_t                   m_nb_points = 0;
    std::vector<std::size_t>      m_node_tags;
    std::vector<Vector3D<double>> m_kpoints;

 public:
    explicit bz_mesh_points(const std::string& filename) : m_filename(filename), m_nb_points(0) {};
    ~bz_mesh_points() = default;

    void add_k_point(Vector3D<double> kpoint);
    void add_k_point(double k_x, double k_y, double k_z);

    void                           read_mesh();
    void                           read_mesh_from_csv();
    std::vector<Vector3D<double>>& get_kpoints() { return m_kpoints; };

    void add_band_on_mesh(const std::string& band_name, const std::vector<double>& band_values);
    void add_all_bands_on_mesh_separate_files(const std::string& out_dir, const EmpiricalPseudopotential::BandStructure& my_band);
    void add_all_bands_on_mesh(const std::string&                             out_filename,
                               const EmpiricalPseudopotential::BandStructure& my_band,
                               int                                            nb_valence_bands_to_export,
                               int                                            nb_conduction_bands_to_export);
    void add_all_bands_on_mesh(const std::string& out_filename, const std::vector<double>& band_values, int number_bands);
    void export_bands_as_csv(const std::vector<double>& band_values, int number_bands);
};/**
 * @file DielectricFunction.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-11-24
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <atomic>
#include <vector>

#include "Material.h"
#include "SymmetryPoints.h"
#include "Vector3D.h"

namespace EmpiricalPseudopotential {

class DielectricFunction {
 protected:
    std::vector<Vector3D<int>>    m_basisVectors;
    std::vector<Vector3D<double>> m_kpoints;
    const Material&               m_material;
    const int                     m_nb_bands;
    bool                          m_nonlocal_epm = false;

    std::vector<Vector3D<double>> m_qpoints;
    std::vector<double>           m_energies;

    std::vector<Eigen::VectorXd>  m_eigenvalues_k;
    std::vector<Eigen::MatrixXcd> m_eigenvectors_k;

    std::string m_export_prefix = "dielectric_function";

    /**
     * @brief The index of the first k-point this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the k-points.
     *
     * For a calculation on a single CPU the offset is 0.
     *
     */
    std::size_t m_offset_k_index = 0;

    /**
     * @brief Number of k-points this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the k-points.
     *
     * For a calculation on a single CPU this parameter is equal to the size of the m_list_k_points.
     *
     */
    std::size_t m_nb_kpoints = 0;

    /**
     * @brief m_dielectric_function[idx_q][idx_energy] is the dielectric function
     * q = m_qpoints[idx_q]
     * energy = m_energies[idx_energy]
     *
     */
    std::vector<std::vector<double>> m_dielectric_function_real;

    /**
     * @brief m_dielectric_function_imag[idx_q][idx_energy] is the dielectric function
     * q = m_qpoints[idx_q]
     * energy = m_energies[idx_energy]
     *
     */
    std::vector<std::vector<double>> m_dielectric_function_imag;

 public:
    DielectricFunction(const Material& material, const std::vector<Vector3D<int>>& basisVectors, const int nb_bands);

    DielectricFunction & operator=(const DielectricFunction &) = default;
    DielectricFunction(const DielectricFunction &) = default;


    void set_non_local_epm(const bool new_value) {m_nonlocal_epm = new_value;}

    /**
     * @brief Randomly generate a list of k-points in the irreducible wedge of the first Brillouin zone.
     *
     * @param nb_points
     */
    void generate_k_points_random(std::size_t nb_points);

    /**
     * @brief Generate a list of k-points in the irreducible wedge of the first Brillouin zone, using the
     * Monkhorst-Pack algorithm.
     *
     * @param nb_points
     */
    void generate_k_points_grid(std::size_t Nx, std::size_t Ny, std::size_t Nz, double shift, bool irreducible_wedge);

    /** Get the list of k-points.
     * @return const std::vector<Vector3D<double>>&
     */
    const std::vector<Vector3D<double>>& get_kpoints() const { return m_kpoints; }

    /**
     * @brief Get the offset of the first k-point this class is responsible for.
     *
     * @param offset_k_index
     */
    std::size_t get_offset_k_index() const { return m_offset_k_index; }

    /**
     * @brief Get the nb kpoints the instance of this class is responsible for.
     *
     * @return std::size_t
     */
    std::size_t get_nb_kpoints() const { return m_nb_kpoints; }

    /**
     * @brief Set the offset k index.
     *
     * @param offset_k_index
     */
    void set_offset_k_index(std::size_t offset_k_index) { m_offset_k_index = offset_k_index; }

    /**
     * @brief Set the number of k-points this class is responsible for.
     *
     * @param nb_kpoints
     */
    void set_nb_kpoints(std::size_t nb_kpoints) { m_nb_kpoints = nb_kpoints; }

    /**
     * @brief Set the list of q-points for which the dielectric function will be computed.
     *
     * @param kpoints
     */
    void set_qpoints(const std::vector<Vector3D<double>>& qpoints) { m_qpoints = qpoints; }

    /**
     * @brief Set the list of energies for which the dielectric function will be computed.
     *
     * @param energies
     */
    void set_energies(const std::vector<double>& energies) { m_energies = energies; }

    void set_export_prefix(const std::string& prefix) { m_export_prefix = prefix; }

    /**
     * @brief Compute the dielectric function.
     *
     */
    void compute_dielectric_function(double eta_smearing = 1e-2, int mpi_rank = 0);

    void clear_eigen_states() {
        m_eigenvalues_k.clear();
        m_eigenvectors_k.clear();
    }

    /**
     * @brief Get the dielectric function result.
     *
     * @return const std::vector<std::vector<double>>&
     */
    const std::vector<std::vector<double>>& get_dielectric_function() const { return m_dielectric_function_real; }

    const std::vector<double> get_flat_dielectric_function() const {
        std::vector<double> result;
        for (const auto& q : m_dielectric_function_real) {
            result.insert(result.end(), q.begin(), q.end());
        }
        return result;
    }

    /**
     * @brief Merge the results of multiple instances of this class.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the k-points.
     *
     * @param dielectric_function_results
     * @param nb_kpoints_per_instance
     * @return std::vector<std::vector<double>>
     */
    static DielectricFunction merge_results(DielectricFunction                                  RootDielectricFunction,
                                            const std::vector<std::vector<std::vector<double>>>& dielectric_function_results,
                                            std::vector<int>                                    nb_kpoints_per_instance);

    /**
     * @brief Apply Kramer's Kronig relations to the dielectric function to obtain the real part.
     *
     */
    void apply_kramers_kronig();

    /**
     * @brief Export the grid of k-points to a file.
     *
     * @param filename
     */
    void export_kpoints(const std::string& filename) const;

    /**
     * @brief Export the results of the computation of the dielectric function to a file.
     *
     * @param filename
     */
    void export_dielectric_function_at_q(const std::string& filename, std::size_t idx_q, bool name_auto) const;

    void export_dielectric_function(const std::string& filename, bool name_auto) const;
};

}  // namespace EmpiricalPseudopotential/**
 * @file SpinOrbitDunctional.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-30
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "SpinOrbitFunctional.hpp"

#include <cmath>
#include <iostream>
#include <vector>

namespace EmpiricalPseudopotential {

double SpinOrbitCorrection::compute_B2_cation(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_cation);
    double B2    = 1.0 / std::pow((1.0 + kappa * kappa), 3.0);
    return B2;
}

double SpinOrbitCorrection::compute_B2_anion(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_anion);
    double B2    = 1.0 / std::pow((1.0 + kappa * kappa), 3.0);
    return B2;
}

double SpinOrbitCorrection::compute_B3_cation(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_cation);
    double B3    = (5 - kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 4.0));
    return B3;
}

double SpinOrbitCorrection::compute_B3_anion(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_anion);
    double B3    = (5 - kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 4.0));
    return B3;
}

double SpinOrbitCorrection::compute_B4_cation(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_cation);
    double B4    = (5.0 - 3.0 * kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 5.0));
    return B4;
}

double SpinOrbitCorrection::compute_B4_anion(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_anion);
    double B4    = (5.0 - 3.0 * kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 5.0));
    return B4;
}

double SpinOrbitCorrection::compute_lambda_1(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_1 = m_soc_parameters.m_mu * compute_B3_cation(K) * compute_B3_cation(Kp);
    return lambda_1;
}

double SpinOrbitCorrection::compute_lambda_2(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_2 = m_soc_parameters.m_alpha * m_soc_parameters.m_mu * compute_B3_anion(K) * compute_B3_anion(Kp);
    return lambda_2;
}

double SpinOrbitCorrection::compute_lambda_sym(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_1   = compute_lambda_1(K, Kp);
    double lambda_2   = compute_lambda_2(K, Kp);
    double lambda_sym = (lambda_1 + lambda_2) / 2.0;
    return lambda_sym;
}

double SpinOrbitCorrection::compute_lambda_antisym(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_1       = compute_lambda_1(K, Kp);
    double lambda_2       = compute_lambda_2(K, Kp);
    double lambda_antisym = (lambda_1 - lambda_2) / 2.0;
    return lambda_antisym;
}

Eigen::Matrix<std::complex<double>, 2, 2> SpinOrbitCorrection::compute_pauli_state_dot_product(const Vector3D<double>& myVect) {
    using namespace std::complex_literals;
    std::complex<double>                      a00 = myVect.Z;
    std::complex<double>                      a01 = myVect.X - myVect.Y * 1i;
    std::complex<double>                      a10 = myVect.X + myVect.Y * 1i;
    std::complex<double>                      a11 = -myVect.Z;
    Eigen::Matrix<std::complex<double>, 2, 2> res_matrix;
    res_matrix << a00, a10, a01, a11;
    return res_matrix;
}

Eigen::Matrix<std::complex<double>, 2, 2> SpinOrbitCorrection::compute_soc_contribution(const Vector3D<double>& K,
                                                                                        const Vector3D<double>& Kp,
                                                                                        const Vector3D<double>& G,
                                                                                        const Vector3D<double>& Gp,
                                                                                        const Vector3D<double>& tau) const {
    using namespace std::complex_literals;
    Vector3D<double> Kn = (m_material.get_lattice_constant_meter() / (2.0 * M_PI)) * K;
    Vector3D<double> Knp = (m_material.get_lattice_constant_meter() / (2.0 * M_PI)) * Kp;
    double lambda_sym     = compute_lambda_sym(Kn, Knp);
    double lambda_antisym = compute_lambda_antisym(Kn, Knp);
    Vector3D<double>                          cross_K_Kp       = cross_product(Kn, Knp);
    Eigen::Matrix<std::complex<double>, 2, 2> res_matrix       = compute_pauli_state_dot_product(cross_K_Kp);
    Vector3D<double>                          diff_G           = G - Gp;
    const double                              lattice_constant = m_material.get_lattice_constant_meter();
    const double                              Gtau             = (2 * M_PI / lattice_constant) * tau * diff_G;
    std::complex<double>                      sym_factor       = -1i * lambda_sym * std::cos(Gtau);
    std::complex<double>                      antisym_factor   = lambda_antisym * std::sin(Gtau);
    res_matrix *= (2.0 * M_PI / lattice_constant) * (2.0 * M_PI / lattice_constant) * (sym_factor + antisym_factor);
    return res_matrix;
}

}  // namespace EmpiricalPseudopotential// /**
//  * @file NonLocalFunctional.hpp
//  * @author remzerrr (remi.helleboid@gmail.com)
//  * @brief
//  * @version 0.1
//  * @date 2022-10-01
//  *
//  * @copyright Copyright (c) 2022
//  *
//  */

// #pragma once

// #include <algorithm>
// #include <cmath>
// #include <complex>
// #include <iostream>
// #include <string>
// #include <system_error>
// #include <vector>

// #include "Constants.hpp"
// #include "Material.h"
// #include "NonLocalParameters.hpp"
// #include "Vector3D.h"

// namespace EmpiricalPseudopotential {

// /**
//  * @brief Functor class to compute the non-local correction to the Hamiltonian.
//  * The notation of the functions follow the paper:
//  * Pötz, W. & Vogl, P. Theory of optical-phonon deformation potentials in tetrahedral semiconductors.
//  * Phys. Rev. B 24, 2025–2037 (1981).
//  *
//  */
// class NonLocalFunctor {
//  private:
//     NonLocalParameters      m_non_local_parameters;
//     Material                m_material;
//     Vector3D<double>        m_tau;
//     const double            m_cinetic_factor;
//     const double            m_fourrier_factor;
//     const double            m_V0_pref_factor;
//     const double            m_V2_square_well_pref_factor;
//     const double            m_V2_gaussian_well_pref_factor;
//     static constexpr double m_epsilon = 1e-10;

//  public:
//     NonLocalFunctor() = delete;
//     NonLocalFunctor(const NonLocalParameters& non_local_parameters, const Material& material, const Vector3D<double>& tau);

//     double F_0_Gamma(double atomic_radii) const;
//     double F_0_diag(double norm_K, double atomic_radii) const;
//     double F_0_coupling(double norm_K1, double norm_K2, double atomic_radii) const;

//     double F_2_Gamma_square_potential() const { return 0.0; }
//     double F_2_diag_square_potential(double norm_K, double atomic_radii) const;
//     double F_2_coupling_square_potential(double norm_K1, double norm_K2, double atomic_radii) const;
//     double F_2_gaussian(double norm_K1, double norm_K2, double atomic_radii) const;

//     double compute_anion_non_local_correction(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized2) const;
//     double compute_cation_non_local_correction(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized) const;

//     std::complex<double> operator()(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized) const;
// };

// }  // namespace EmpiricalPseudopotential#include "Pseudopotential.h"

#define _USE_MATH_DEFINES 1
#include <array>
#include <cmath>
#include <complex>
#include <numbers>

#include "Constants.hpp"

namespace EmpiricalPseudopotential {

Pseudopotential::Pseudopotential(double V3S, double V4S, double V8S, double V11S, double V3A, double V4A, double V8A, double V11A)
    : m_V3S(V3S),
      m_V4S(V4S),
      m_V8S(V8S),
      m_V11S(V11S),
      m_V3A(V3A),
      m_V4A(V4A),
      m_V8A(V8A),
      m_V11A(V11A) {}

#include <array>
#include <cmath>
#include <complex>
#include <numbers>

std::complex<double> Pseudopotential::GetValue(const Vector3D<int>& G, const Vector3D<double>& tau, double lattice_constant) const {
    // Optional: enforce fcc selection rule (all-even or all-odd Miller indices)
    const bool same_parity = ((G.X & 1) == (G.Y & 1)) && ((G.Y & 1) == (G.Z & 1));
    if (!same_parity) return {0.0, 0.0};

    const int    G2   = G * G;  // integer dot product h^2 + k^2 + l^2
    const double kfac = 2.0 * std::numbers::pi_v<double> / lattice_constant;
    const double Gtau = kfac * (tau * G);  // dimensionless phase

    double VS = 0.0, VA = 0.0;
    switch (G2) {
        case 3:
            VS = m_V3S;
            VA = m_V3A;
            break;
        case 4:
            VS = m_V4S;
            VA = m_V4A;
            break;
        case 8:
            VS = m_V8S;
            VA = m_V8A;
            break;
        case 11:
            VS = m_V11S;
            VA = m_V11A;
            break;
        default: 
            break;
    }

    // V(G) = VS cos(G·τ) + i VA sin(G·τ)
    const double c = std::cos(Gtau);
    const double s = std::sin(Gtau);
    return {VS * c, VA * s};
}

void Pseudopotential::print_parameters() const {
    std::cout << "V3S = " << m_V3S << std::endl;
    std::cout << "V4S = " << m_V4S << std::endl;
    std::cout << "V8S = " << m_V8S << std::endl;
    std::cout << "V11S = " << m_V11S << std::endl;
    std::cout << "V3A = " << m_V3A << std::endl;
    std::cout << "V4A = " << m_V4A << std::endl;
    std::cout << "V8A = " << m_V8A << std::endl;
    std::cout << "V11A = " << m_V11A << std::endl;
}

}  // namespace EmpiricalPseudopotential/**
 * @file single_part_fbmc.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2025-09-19
 * 
 * @copyright Copyright (c) 2025
 * 
 */


#include <algorithm>
#include <array>
#include <cmath>
#include <fstream>
#include <iostream>
#include <map>
#include <numeric>
#include <random>
#include <vector>

#include "Constants.hpp"
#include "single_part_fbmc.hpp"
namespace fbmc {

Single_particle_simulation::Single_particle_simulation(bz_mesh::ElectronPhonon*     ptr_mesh_bz,
                                                       const Bulk_environment&      bulk_env,
                                                       const Simulation_parameters& sim_params)
    : m_ptr_mesh_bz(ptr_mesh_bz),
      m_bulk_env(bulk_env),
      m_sim_params(sim_params) {
    double m_time = 0.0;
    // Initialize the particle
    const std::size_t index = 0;
    m_particle              = particle(index, particle_type::electron, m_ptr_mesh_bz);
    m_particle.set_position({0.0, 0.0, 0.0});
    const double thermal_energy = bulk_env.m_temperature * EmpiricalPseudopotential::Constants::k_b_eV;
    m_particle.set_energy(thermal_energy);
    m_particle.set_velocity({0.0, 0.0, 0.0});
    std::cout << "Thermal energy at " << bulk_env.m_temperature << " K: " << thermal_energy << " eV" << std::endl;
    vector3 initial_k = m_ptr_mesh_bz->draw_random_k_point_at_energy(thermal_energy, 0, m_particle.get_random_generator());
    m_particle.set_k_vector(initial_k);
    std::cout << "Initial k-vector (drawn at thermal energy): " << initial_k << std::endl;
    bz_mesh::Tetra* containing_tetra = m_ptr_mesh_bz->find_tetra_at_location(m_particle.get_k_vector());
    if (containing_tetra == nullptr) {
        throw std::runtime_error("Initial k-point is out of the Brillouin zone mesh.");
    }
    m_particle.set_containing_bz_mesh_tetra(containing_tetra);
    m_particle.update_group_velocity();
    m_particle.update_energy();

    double init_energy_true = containing_tetra->interpolate_energy_at_band(m_particle.get_k_vector(), 0);

    std::cout << "Initial k-vector: " << m_particle.get_k_vector().x() << " " << m_particle.get_k_vector().y() << " "
              << m_particle.get_k_vector().z() << std::endl;
    std::cout << "Initial energy (set): " << m_particle.get_energy() << " eV" << std::endl;
    std::cout << "Initial energy (true): " << init_energy_true << " eV" << std::endl;
}

void Single_particle_simulation::run_simulation() {
    // Freefligts time in a file
    std::ofstream free_flight_time_file("free_flight_times.txt");
    if (!free_flight_time_file.is_open()) {
        std::cerr << "Could not open free flight time file for writing." << std::endl;
        return;
    }

    // Compute total scattering rate
    const double p_gamma = m_ptr_mesh_bz->compute_P_Gamma();
    std::cout << "Total scattering rate: " << p_gamma << " 1/s" << std::endl;
    if (p_gamma <= 0.0) {
        std::cerr << "Total scattering rate is zero or negative." << std::endl;
        return;
    }

    int nb_foldings = 0;

    while (m_time < m_sim_params.m_simulation_time) {
        // std::cout << "Time: " << m_time << " s" << std::endl;
        m_particle.update_history();

        // Draw free flight time
        m_particle.draw_free_flight_time(p_gamma);
        free_flight_time_file << m_particle.get_current_free_flight_time() << std::endl;

        // Update time
        m_time += m_particle.get_current_free_flight_time();

        // Update k-vector
        m_particle.update_k_vector(m_bulk_env.m_electric_field);
        // std::cout << "New k-vector: " << m_particle.get_k_vector().x() << " " << m_particle.get_k_vector().y() << " "
        //           << m_particle.get_k_vector().z() << std::endl;

        // Find containing tetrahedron
        bz_mesh::Tetra* containing_tetra = m_ptr_mesh_bz->find_tetra_at_location(m_particle.get_k_vector());
        if (containing_tetra == nullptr) {
            // TEST
            bool is_inside_bz = m_ptr_mesh_bz->inside_ws_bcc(m_particle.get_k_vector());
            if (is_inside_bz) {
                std::cout << "ERROR : Particle is inside the Wigner-Seitz cell but outside the mesh." << std::endl;
            } else {
                std::cout << "GOOD : Particle is outside the Wigner-Seitz cell and the mesh." << std::endl;
            }

            std::cerr << "Particle exited the Brillouin zone mesh ("
                      << "k = " << m_particle.get_k_vector().x() << " " << m_particle.get_k_vector().y() << " "
                      << m_particle.get_k_vector().z() << "). Folding back..." << std::endl;
            // Fold back into the first Brillouin zone
            vector3 folded_k = m_ptr_mesh_bz->fold_ws_bcc(m_particle.get_k_vector());
            m_particle.set_k_vector(folded_k);
            containing_tetra = m_ptr_mesh_bz->find_tetra_at_location(m_particle.get_k_vector());
            if (containing_tetra == nullptr) {
                std::cerr << "Particle still outside the Brillouin zone mesh after folding back." << std::endl;
                break;
            } else {
                std::cout << "Particle folded back into the Brillouin zone mesh at k = " << folded_k.x() << " " << folded_k.y() << " "
                          << folded_k.z() << std::endl;
                nb_foldings++;
            }
        }
        m_particle.set_containing_bz_mesh_tetra(containing_tetra);

        m_particle.update_energy();

        // Update group velocity
        m_particle.update_group_velocity();

        // Update position
        vector3 new_position = m_particle.get_position() + m_particle.get_velocity() * m_particle.get_current_free_flight_time();
        m_particle.set_position(new_position);

        // Scatter the particle
        std::array<double, 8> scattering_rates      = m_particle.interpolate_phonon_scattering_rate_at_location(m_particle.get_k_vector());
        double                total_scattering_rate = std::accumulate(scattering_rates.begin(), scattering_rates.end(), 0.0);
        if (total_scattering_rate <= 0.0) {
            std::cerr << "Total scattering rate is zero or negative during scattering." << std::endl;
            break;
        }
        std::uniform_real_distribution<double> distribution(0.0, total_scattering_rate);
        double                                 random_value     = distribution(m_particle.get_random_generator());
        double                                 cumulative_rate  = 0.0;
        std::size_t                            scattering_event = 0;
        bool                                   event_found      = false;
        for (std::size_t idx_mode = 0; idx_mode < scattering_rates.size(); ++idx_mode) {
            cumulative_rate += scattering_rates[idx_mode];
            if (random_value <= cumulative_rate) {
                scattering_event = idx_mode;
                event_found      = true;
                break;
            }
        }
        // std::cout << "Scattering event: " << scattering_event << " at energy " << m_particle.get_energy() << " eV" << std::endl;
        if (!event_found) {
            std::cout << "Self-scattering event." << std::endl;
            continue;
        }
    }
    std::cout << "Simulation finished at time " << m_time << " s" << std::endl;
    std::cout << "Number of foldings: " << nb_foldings << std::endl;
    free_flight_time_file.close();
}

void Single_particle_simulation::export_history(const std::string& filename) {
    std::ofstream history_file(filename);
    if (!history_file.is_open()) {
        std::cerr << "Could not open history file for writing." << std::endl;
        return;
    }
    constexpr double lattice_constant     = 5.43e-10;  // in meters (for silicon)
    constexpr double normalization_factor = 2.0 * M_PI / lattice_constant;

    // Write particle history to file
    auto history = m_particle.get_history();
    history_file << "time,x,y,z,kx,ky,kz,vx,vy,vz,energy\n";
    for (std::size_t step = 0; step < history.get_number_of_steps(); ++step) {
        history_file << history.m_time_history[step] << "," << history.m_positions[step].x() << "," << history.m_positions[step].y() << ","
                     << history.m_positions[step].z() << "," << history.m_k_vectors[step].x() / normalization_factor << ","
                     << history.m_k_vectors[step].y() / normalization_factor << "," << history.m_k_vectors[step].z() / normalization_factor
                     << "," << history.m_velocities[step].x() << "," << history.m_velocities[step].y() << ","
                     << history.m_velocities[step].z() << "," << history.m_energies[step] << "\n";
    }
    history_file.close();
    std::cout << "Particle history exported to " << filename << std::endl;
}

}  // namespace fbmc/**
 * @file single_part_fbmc.hpp
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2025-09-17
 *
 * @copyright Copyright (c) 2025
 *
 */

#pragma once

#include <array>
#include <cmath>
#include <cstddef>

#include "bz_mesh.hpp"
#include "bz_states.hpp"
#include "electron_phonon.hpp"
#include "particle.hpp"
#include "vector.hpp"

namespace fbmc {

struct Bulk_environment {
    double  m_temperature;
    vector3 m_electric_field;
    double  m_doping_concentration;
};

struct Simulation_parameters {
    double      m_simulation_time;
    std::size_t m_export_frequency;
};

class Single_particle_simulation {
 private:
    bz_mesh::ElectronPhonon* m_ptr_mesh_bz;
    Bulk_environment         m_bulk_env;
    Simulation_parameters    m_sim_params;
    particle                 m_particle;

    double m_time = 0.0;

 public:
    double a = 0;
    Single_particle_simulation(bz_mesh::ElectronPhonon*     ptr_mesh_bz,
                               const Bulk_environment&      bulk_env,
                               const Simulation_parameters& sim_params);

    void run_simulation();

    void export_history(const std::string& filename);
};
}  // namespace fbmc/**
 * @file particle.hpp
 * @author your name (you@domain.com)
 * @brief Particle simulation class for the FBMC (Full Band Monte Carlo) method.
 * @version 0.1
 * @date 2025-09-19
 *
 * @copyright Copyright (c) 2025
 *
 */

#pragma once

#include <array>
#include <iostream>
#include <memory>
#include <random>
#include <vector>

#include "bz_mesh.hpp"
#include "vector.hpp"
// #include "particle_history_mc.hpp"
#include "electron_phonon.hpp"
#include "mesh_tetra.hpp"
#include "vector.hpp"

namespace fbmc {

enum class particle_type { electron = -1, hole = 1 };

using vector3 = bz_mesh::vector3;

struct scattering_rate {
    std::array<double, 8> m_phonon_rate;
    double                m_phonon_rate_total      = 0.0;
    double                m_impurity_rate          = 0.0;
    double                m_impact_ionization_rate = 0.0;
};

struct particle_history {
    std::size_t          m_index;
    std::vector<double>  m_time_history;
    std::vector<vector3> m_positions;
    std::vector<vector3> m_k_vectors;
    std::vector<vector3> m_velocities;
    std::vector<double>  m_energies;

    particle_history() : m_index(0), m_positions(), m_k_vectors(), m_velocities(), m_energies() {}
    particle_history(std::size_t index) : m_index(index), m_positions(), m_k_vectors(), m_velocities(), m_energies() {}

    void add_time(double time) { m_time_history.push_back(time); }
    void add_position(const vector3& position) { m_positions.push_back(position); }
    void add_k_vector(const vector3& k_vector) { m_k_vectors.push_back(k_vector); }
    void add_velocity(const vector3& velocity) { m_velocities.push_back(velocity); }
    void add_energy(double energy) { m_energies.push_back(energy); }

    void add_particle_state(const double&  my_time,
                            const vector3& my_position,
                            const vector3& my_k_vector,
                            const vector3& my_velocity,
                            double         my_energy) {
        add_time(my_time);
        add_position(my_position);
        add_k_vector(my_k_vector);
        add_velocity(my_velocity);
        add_energy(my_energy);
    }
    std::size_t get_number_of_steps() const { return m_positions.size(); }
};

class particle {
 protected:
    /**
     * @brief Pointer to the Brillouin Zone Mesh.
     *
     */
    bz_mesh::ElectronPhonon* m_mesh_bz = nullptr;

    /**
     * @brief Index of the particle in the simulation.
     *
     */
    std::size_t m_index = 0;

    /**
     * @brief Type of the particle (electron or hole).
     *
     */
    particle_type m_type = particle_type::electron;

    /**
     * @brief Time of the particle in the simulation.
     *
     */
    double m_time = 0.0;

    /**
     * @brief Position of the particle in the real space.
     *
     */
    vector3 m_position = {0.0, 0.0, 0.0};

    /**
     * @brief Wave vector of the particle.
     *
     */
    vector3 m_k_vector = {0.0, 0.0, 0.0};

    /**
     * @brief Band index of the particle.
     *
     */
    int m_band_index = 0;

    /**
     * @brief Velocity of the particle.
     *
     */
    vector3 m_velocity = {0.0, 0.0, 0.0};

    /**
     * @brief Energy of the particle.
     *
     */
    double m_energy = 0.0;

    /**
     * @brief Free flight time of the particle.
     *
     */
    double m_current_free_flight_time = 0.0;

    /**
     * @brief Pointer to the tetrahedron in which the particle lies.
     *
     */
    bz_mesh::Tetra* m_containing_bz_mesh_tetra = nullptr;

    /**
     * @brief Random number generator.
     *
     */
    std::mt19937 m_random_generator = std::mt19937(std::random_device{}());

    /**
     * @brief Random number distribution.
     *
     */
    std::uniform_real_distribution<double> m_random_distribution = std::uniform_real_distribution<double>(0.0, 1.0);

    /**
     * @brief History of the particle during the simulation.
     *
     */
    particle_history m_history;

 public:
    particle() = default;
    particle(std::size_t index, particle_type type, bz_mesh::ElectronPhonon* mesh);
    particle(const particle& other)            = default;
    particle& operator=(const particle& other) = default;
    ~particle()                                = default;

    std::size_t     get_index() const { return m_index; }
    void            set_index(std::size_t index) { m_index = index; }
    particle_type   get_type() const { return m_type; }
    double          get_charge_sign() const { return static_cast<double>(m_type); }
    double          get_time() const { return m_time; }
    void            set_time(double time) { m_time = time; }
    const vector3&  get_position() const { return m_position; }
    void            set_position(const vector3& position) { m_position = position; }
    const vector3&  get_k_vector() const { return m_k_vector; }
    void            set_k_vector(const vector3& k_vector) { m_k_vector = k_vector; }
    const vector3&  get_velocity() const { return m_velocity; }
    void            set_velocity(const vector3& velocity) { m_velocity = velocity; }
    double          get_energy() const { return m_energy; }
    void            set_energy(double energy) { m_energy = energy; }
    double          get_current_free_flight_time() const { return m_current_free_flight_time; }
    bz_mesh::Tetra* get_containing_bz_mesh_tetra() const { return m_containing_bz_mesh_tetra; }
    void set_containing_bz_mesh_tetra(bz_mesh::Tetra* containing_bz_mesh_tetra) { m_containing_bz_mesh_tetra = containing_bz_mesh_tetra; }
    void set_random_generator(std::mt19937 random_generator) { m_random_generator = random_generator; }

    std::array<double, 8> interpolate_phonon_scattering_rate_at_location(const vector3& location);
    void                  compute_post_phonon_scattering_state();

    void draw_free_flight_time(double p_gamma);
    void update_k_vector(const vector3& v_electric_field);
    void update_energy();
    void update_group_velocity();

    std::mt19937& get_random_generator() { return m_random_generator; }
    void          draw_random_k_point_at_energy(double energy, std::size_t idx_band) {
        m_mesh_bz->draw_random_k_point_at_energy(energy, idx_band, get_random_generator());
    }
    void                    update_history() { m_history.add_particle_state(m_time, m_position, m_k_vector, m_velocity, m_energy); }
    const particle_history& get_history() const { return m_history; }
    void                    reset_history() { m_history = particle_history(m_index); }
};

}  // namespace fbmc/**
 * @file particle.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-10
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "particle.hpp"

#include <random>

#include "Constants.hpp"
namespace fbmc {

particle::particle(std::size_t index, particle_type arg_particle_type, bz_mesh::ElectronPhonon* ptr_mesh_bz)
    : m_index(index),
      m_type(arg_particle_type),
      m_mesh_bz(ptr_mesh_bz) {}

/**
 * @brief Draw a new free flight time for the particle.
 *
 * @param p_gamma
 */
void particle::draw_free_flight_time(double p_gamma) {
    m_current_free_flight_time = -(1.0 / p_gamma) * std::log(m_random_distribution(m_random_generator));
    m_time += m_current_free_flight_time;
}

/**
 * @brief Update the k-vector of the particle based on the electric field.
 *
 * @param v_electric_field The electric field vector.
 */
void particle::update_k_vector(const vector3& v_electric_field) {
    m_k_vector += (get_charge_sign() * EmpiricalPseudopotential::Constants::q_e / EmpiricalPseudopotential::Constants::h_bar) *
                  v_electric_field * m_current_free_flight_time;
}

void particle::update_group_velocity() {
    m_velocity = m_containing_bz_mesh_tetra->get_gradient_energy_at_band(m_band_index);
    m_velocity *= (1.0 / EmpiricalPseudopotential::Constants::h_bar_eV);
}

std::array<double, 8> particle::interpolate_phonon_scattering_rate_at_location(const vector3& location) {
    return m_mesh_bz->interpolate_phonon_scattering_rate_at_location(location, m_band_index);
}

void particle::update_energy() { m_energy = m_containing_bz_mesh_tetra->interpolate_energy_at_band(m_k_vector, m_band_index); }

void compute_post_phonon_scattering_state() {}

}  // namespace fbmc/**
 * @file dielectric_mesh.hpp
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2024-05-17
 *
 * @copyright Copyright (c) 2024
 *
 */

#pragma once

#include <Eigen/Dense>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include "Material.h"
#include "bz_mesh.hpp"

namespace bz_mesh {

typedef std::complex<double> complex_d;

class DielectricMesh : public MeshBZ {
 protected:
    /**
     * @brief Store the energies of the dielectric function.
     *
     */
    std::vector<double> m_energies;

    /**
     * @brief Store the dielectric function for each k-point of the mesh.
     * m_dielectric_function[idx_node][idx_energy]  is the dielectric function at the k-point idx_node and energy idx_energy (from
     * m_energies).
     *
     */
    std::vector<std::vector<complex_d>> m_dielectric_function;

 public:
    DielectricMesh() = default;
    DielectricMesh(const EmpiricalPseudopotential::Material& material) : MeshBZ(material) {}

    /**
     * @brief Read the dielectric function from a .msf file (created by epsilon.epm).
     *
     * @param filename Path to the file containing the dielectric function.
     */
    void read_dielectric_file(const std::string& filename);

    /**
     * @brief Find the closest energy in the list of energies.
     * Return the index (idx) of the stored energy directly below the given energy and the fraction (t) of the distance between the two
     * closest energies. The dielectric function at the given energy can be interpolated as: m_dielectric_function[idx_node][idx] * (1 - t)
     * + m_dielectric_function[idx_node][idx + 1] * t
     *
     *
     * @param energy
     * @return std::pair<std::size_t, double>
     */
    std::pair<std::size_t, double> find_closest_energy(double energy) const;

    /**
     * @brief Interpolate the dielectric function at a given k-point and energy.
     *
     * @param k
     * @param energy
     * @return complex_d
     */
    complex_d interpolate_dielectric_function(const vector3& k, double energy) const;
};

}  // namespace bz_mesh/**
 * @file bz_dielectric.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <array>
#include <memory>

#include "Material.h"
#include "bz_mesh.hpp"
#include "bz_states.hpp"
#include "dielectric_mesh.hpp"

namespace bz_mesh {

typedef std::complex<double>       complex_d;
typedef std::unique_ptr<BZ_States> uptr_BZstates;

class ImpactIonization {
 private:
    /**
     * @brief List of Brillouin Zone with their precomputed electronic states.
     * Each of them correspond to a 1BZ shifted by a vector G of the reciprocal lattice.
     *
     */
    std::vector<uptr_BZstates> m_list_BZ_states;

    /**
     * @brief Path to the initial mesh file (centered at 0,0,0)
     *
     */
    std::string m_initial_mesh_path;

    /**
     * @brief Maximum radius of the Brillouin Zone in the reciprocal space.
     *
     */
    double m_max_radius_G0_BZ = 0.0;

    /**
     * @brief Material of the system.
     *
     */
    EmpiricalPseudopotential::Material m_material;

    /**
     * @brief Mesh of the dielectric function.
     *
     */
    DielectricMesh m_dielectric_mesh;

    /**
     * @brief List of the results of the impact ionization rate.
     *
     */
    std::vector<double> m_impact_ionization_results;

 public:
    ImpactIonization(const EmpiricalPseudopotential::Material& material, const std::string& initial_mesh_path);
    void read_dielectric_file(const std::string& filename);
    void interp_test_dielectric_function(std::string filename);

    double get_max_radius_G0_BZ() const { return m_max_radius_G0_BZ; }
    void   set_max_radius_G0_BZ(double max_radius_G0_BZ) { m_max_radius_G0_BZ = max_radius_G0_BZ; }
    void   compute_eigenstates(int nb_threads = 1);

    std::array<complex_d, 2> compute_direct_indirect_impact_ionization_matrix_element(int idx_n1,
                                                                                      int idx_n1_prime,
                                                                                      int idx_n2,
                                                                                      int idx_n2_prime,
                                                                                      int idx_k1,
                                                                                      int idx_k1_prime,
                                                                                      int idx_k2,
                                                                                      int idx_k2_prime) const;

    double compute_impact_ionization_rate(int idx_n1, std::size_t idx_k1);
};

}  // namespace bz_mesh/**
 * @file electron_phonon.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2025-10-04
 *
 *
 */

#pragma once

#include <Eigen/Sparse>  // needed for member type in class; keep here
#include <algorithm>     // max_element
#include <array>
#include <cmath>
#include <cstdint>
#include <stdexcept>
#include <vector>

#include "bz_states.hpp"  // for vector3, BZ_States, material

namespace bz_mesh {

// ---------- Discrete axes ----------
enum class PhononMode : uint8_t { acoustic = 0, optical = 1, none = 2 };
enum class PhononDirection : uint8_t { longitudinal = 0, transverse = 1, none = 2 };
enum class PhononEvent : uint8_t { absorption = 0, emission = 1, none = 2 };

// Compact index:  m∈{ac,op}, d∈{L,T}, e∈{ab,em}  → [0..7] = (m<<2)|(d<<1)|e
constexpr int rate_index(PhononMode m, PhononDirection d, PhononEvent e) noexcept {
    const int M = (m == PhononMode::acoustic) ? 0 : (m == PhononMode::optical) ? 1 : -1;
    const int D = (d == PhononDirection::longitudinal) ? 0 : (d == PhononDirection::transverse) ? 1 : -1;
    const int E = (e == PhononEvent::absorption) ? 0 : (e == PhononEvent::emission) ? 1 : -1;
    return (M | D | E) < 0 ? -1 : ((M << 2) | (D << 1) | E);
}

constexpr int IDX_AC_L_AB = 0;
constexpr int IDX_AC_T_AB = 1;
constexpr int IDX_OP_L_AB = 2;
constexpr int IDX_OP_T_AB = 3;
constexpr int IDX_AC_L_EM = 4;
constexpr int IDX_AC_T_EM = 5;
constexpr int IDX_OP_L_EM = 6;
constexpr int IDX_OP_T_EM = 7;

// ---------- Compact rate containers ----------
using Rate8           = std::array<double, 8>;
using BandRates       = std::vector<Rate8>;      // per band
using VertexBandRates = std::vector<BandRates>;  // per vertex

struct RateValues {
    Rate8 v{};
    void  add(PhononMode m, PhononDirection d, PhononEvent e, double x) noexcept {
        const int idx = rate_index(m, d, e);
        if (idx >= 0) v[static_cast<size_t>(idx)] += x;
    }
    double&            at(PhononMode m, PhononDirection d, PhononEvent e) { return v[rate_index(m, d, e)]; }
    const double&      at(PhononMode m, PhononDirection d, PhononEvent e) const { return v[rate_index(m, d, e)]; }
    const Rate8&       as_array() const noexcept { return v; }
    static const char* label(int i) {
        static const char* L[8] = {"ac_L_ab", "ac_T_ab", "op_L_ab", "op_T_ab", "ac_L_em", "ac_T_em", "op_L_em", "op_T_em"};
        return (i >= 0 && i < 8) ? L[i] : "invalid";
    }
};

// ---------- Phonon dispersion (uniform lookup + analytic fallback) ----------
struct PhononDispersion {
    PhononMode      mode      = PhononMode::none;
    PhononDirection direction = PhononDirection::none;

    // Analytic ω(q) = w0 + vs*q + c*q^2 (optional fast path)
    double w0 = 0.0, vs = 0.0, c = 0.0;

    // Uniform lookup on q∈[0,qmax]: store only ω; derive indices arithmetically
    double              q0     = 0.0;  // usually 0
    double              inv_dq = 0.0;  // 1/Δq
    double              qmax   = 0.0;
    uint32_t            N      = 0;     // number of samples
    std::vector<double> omega_samples;  // size N

    PhononDispersion() = default;
    PhononDispersion(PhononMode m, PhononDirection d, double w0_, double vs_, double c_) : mode(m), direction(d), w0(w0_), vs(vs_), c(c_) {}

    inline double omega_analytic(double q) const noexcept { return std::fma(c, q * q, std::fma(vs, q, w0)); }

    void build_lookup(double q_max, std::size_t n_points) {
        if (q_max <= 0.0 || n_points < 2) throw std::invalid_argument("bad lookup grid");
        q0              = 0.0;
        qmax            = q_max;
        N               = static_cast<uint32_t>(n_points);
        const double dq = (qmax - q0) / (N - 1);
        inv_dq          = 1.0 / dq;
        omega_samples.resize(N);
        for (uint32_t i = 0; i < N; ++i) {
            const double q   = q0 + i * dq;
            omega_samples[i] = omega_analytic(q);
        }
    }

    inline double omega_lookup(double q) const {
        if (omega_samples.empty()) throw std::runtime_error("phonon lookup empty");
        if (q <= q0) return omega_samples.front();
        if (q >= qmax) return omega_samples.back();
        const double t = (q - q0) * inv_dq;
        uint32_t     i = static_cast<uint32_t>(t);
        if (i >= N - 1) i = N - 2;
        const double frac = t - static_cast<double>(i);
        const double a = omega_samples[i], b = omega_samples[i + 1];
        return std::fma(frac, (b - a), a);
    }

    inline double max_omega() const {
        if (omega_samples.empty()) throw std::runtime_error("phonon lookup empty");
        return *std::max_element(omega_samples.begin(), omega_samples.end());
    }
};

// ---------- Deformation potentials (no i/o in header) ----------
struct DeformationPotential {
    PhononMode mode             = PhononMode::none;
    double     A                = 0.0;
    double     B                = 0.0;
    double     energy_threshold = 1e6;  // eV

    DeformationPotential() = default;
    DeformationPotential(PhononMode m, double A_, double B_, double thr) : mode(m), A(A_), B(B_), energy_threshold(thr) {}

    double get_deformation_potential(const vector3& q, double energy) const {
        const double Ee = (energy < energy_threshold ? energy : energy_threshold);
        return (mode == PhononMode::acoustic) ? std::sqrt(A + Ee * B) * q.norm() : std::sqrt(A + Ee * B);
    }

    double get_fischetti_deformation_potential(const vector3& q, int idx_band) const {
        constexpr double cm_to_m = 1e2;
        const double     boost   = 1.5;
        if (mode == PhononMode::acoustic) {
            return (idx_band == 0 ? boost * 1.2 : 1.0 * 1.7) * q.norm();
        } else {
            return (idx_band == 0 ? boost * 1.75e8 : boost * 2.10e8) * cm_to_m;
        }
    }
};

// ---------- Hole overlap params (fixed arrays instead of linear search) ----------
struct HoleOverlapIntParams {
    // Indices 1..3 used in your logic; we store 0..2 and subtract 1 on access
    std::array<std::array<double, 3>, 3> A{{{{1.0, 3.0, 3.0 / 8.0}}, {{3.0, 1.0, 3.0 / 8.0}}, {{3.0 / 8.0, 3.0 / 8.0, 5.0 / 8.0}}}};
    std::array<std::array<double, 3>, 3> B{{{{3.0, -3.0, 0.0}}, {{-3.0, 3.0, 0.0}}, {{0.0, 0.0, 0.0}}}};

    // returns {A,B} for pair (n1,n2) where n∈{1,2,3}; outside → {0,0}
    std::array<double, 2> get_params(int n1, int n2) const noexcept {
        if (n1 >= 1 && n1 <= 3 && n2 >= 1 && n2 <= 3) {
            return {A[n1 - 1][n2 - 1], B[n1 - 1][n2 - 1]};
        }
        return {0.0, 0.0};
    }
};

// Helper: compact container for 4 (mode×direction) dispersions
inline constexpr int md_index(PhononMode m, PhononDirection d) noexcept {
    const int M = (m == PhononMode::acoustic) ? 0 : (m == PhononMode::optical) ? 1 : -1;
    const int D = (d == PhononDirection::longitudinal) ? 0 : (d == PhononDirection::transverse) ? 1 : -1;
    return (M | D) < 0 ? -1 : ((M << 1) | D);  // 0..3
}

// ---------- Eigen aliases ----------
using EigenSparseMatrix = Eigen::SparseMatrix<double>;
using EigenTriplet      = Eigen::Triplet<double>;

struct Rates_nk_npkp_ctor {
    PhononMode      mode      = PhononMode::none;
    PhononDirection direction = PhononDirection::none;
    PhononEvent     event     = PhononEvent::none;
    /**
     * @brief Preliminary constructor for the rate matrix (n,k) → (n',k') for a given (m,d,e) triplet.
    // (n,k) → (n',k') transition rate matrix. /!\ k' are the barycenters of final tetrahedra, not the mesh vertices!
    // So the size is (nk, n'k') where n'k' are the number of final tetrahedra × number of bands.
     *
     */
    EigenSparseMatrix matrix;  // (nk, n'k')
};

class ElectronPhonon : public BZ_States {
 private:
    double m_temperature        = 300.0;
    double m_rho                = 2.329e3;
    double m_radii_wigner_seitz = 0.0;

    int  m_nb_threads         = 1;
    bool m_parallelize_over_k = true;

    HoleOverlapIntParams m_hole_overlap_int_params;
    DeformationPotential m_ac_defpot_e, m_op_defpot_e;
    DeformationPotential m_ac_defpot_h, m_op_defpot_h;

    // 4 dispersions: (ac/op) × (L/T); index via md_index()
    std::array<PhononDispersion, 4> m_phonon_dispersion;

    // Transport rates. m_phonon_rates_transport[band][k1]
    std::vector<std::vector<double>> m_phonon_rates_transport;  // precomputed 1/τ_tr(E) on uniform grid

    // Precomputed rates on mesh: [vertex][band][8]
    std::vector<std::vector<Rate8>> m_list_phonon_scattering_rates;
    std::vector<double>             m_count_weight_tetra_per_vertex;

    // (n,k) → (n',k') transition rate matrices. /!\ k' are the barycenters of final tetrahedra, not the mesh vertices!
    // So the size is (nk, n'k') where n'k' are the number of final tetrahedra × number of bands.
    // One matrix per (m,d,e) triplet.
    std::vector<Rates_nk_npkp_ctor> m_rates_nk_npkp;

 public:
    explicit ElectronPhonon(const EmpiricalPseudopotential::Material& material) : BZ_States(material) {}

    // .cpp implements these (keep header slim—no YAML/iostream here)
    void   load_phonon_parameters(const std::string& filename);
    void   plot_phonon_dispersion(const std::string& filename) const;
    double get_max_phonon_energy() const;

    inline double bose_einstein_distribution(double energy_eV, double temperature_K) const;  // inline in .cpp
    inline double electron_overlap_integral(const vector3& k1, const vector3& k2) const;
    inline double hole_overlap_integral(int n1, const vector3& k1, int n2, const vector3& k2) const;
    inline double transport_weight_RTA(const vector3& v0, const vector3& v1);  // inline in .cpp

    Rate8      compute_transition_rates_pair(int idx_n1, std::size_t idx_k1, int idx_n2, std::size_t idx_tetra_final, bool push_nk_npkp);
    RateValues compute_electron_phonon_rate(int idx_n1, std::size_t idx_k1, bool populate_nk_npkp = false);
    RateValues compute_hole_phonon_rate(int idx_n1, std::size_t idx_k1);

    void set_nb_threads(int nb_threads) {
        if (nb_threads < 1) throw std::invalid_argument("nb_threads must be >= 1");
        m_nb_threads = nb_threads;
    }
    void set_parallelize_over_k(bool b) noexcept { m_parallelize_over_k = b; }

    void set_temperature(double T) noexcept { m_temperature = T; }
    void set_density(double rho) noexcept { m_rho = rho; }

    void compute_electron_phonon_rates_over_mesh(double energy_max             = 100.0,
                                                 bool   irreducible_wedge_only = false,
                                                 bool   populate_nk_npkp       = false);
    void add_electron_phonon_rates_to_mesh(const std::string& initial_filename, const std::string& final_filename);
    void compute_electron_phonon_rates_over_mesh_nk_npkp(bool irreducible_wedge_only = false);

    std::pair<int, std::size_t> select_final_state(std::size_t     idx_band_initial,
                                                   std::size_t     idx_k_initial,
                                                   PhononMode      mode,
                                                   PhononDirection direction,
                                                   PhononEvent     event) const;

    void export_rate_values(const std::string& filename) const;

    void compute_plot_electron_phonon_rates_vs_energy_over_mesh(int                nb_bands,
                                                                double             max_energy,
                                                                double             energy_step,
                                                                const std::string& filename,
                                                                bool               irreducible_wedge_only = false);

    void          read_phonon_scattering_rates_from_file(const std::filesystem::path& path);
    Rate8         interpolate_phonon_scattering_rate_at_location(const vector3& location, const std::size_t& idx_band) const;
    inline double sum_modes(const Rate8& r) const noexcept;
    double        compute_P_Gamma() const;

    void compute_RTA_mobility();
};

}  // namespace bz_mesh
/**
 * @file box_bz.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-25
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <memory>
#include <random>
#include <vector>

#include "vector.hpp"

namespace bz_mesh {

/**
 * @brief Class representing a box in 3D space.
 * The box is of the form AABB (Axis-Aligned Bounding Box)
 *
 *
 */
class bbox_mesh {
 private:
    double m_x_min{0.0};
    double m_x_max{0.0};
    double m_y_min{0.0};
    double m_y_max{0.0};
    double m_z_min{0.0};
    double m_z_max{0.0};

 public:
    bbox_mesh(){};
    bbox_mesh(double x_min, double x_max, double y_min, double y_max, double z_min, double z_max)
        : m_x_min(x_min),
          m_x_max(x_max),
          m_y_min(y_min),
          m_y_max(y_max),
          m_z_min(z_min),
          m_z_max(z_max) {
        if (!check_order()) {
            throw std::invalid_argument("Order of bbox_mesh corner is bad.");
        }
    }

    bbox_mesh(const vector3 &bottom_left_front_corner, const vector3 &up_right_back_corner)
        : m_x_min(bottom_left_front_corner.x()),
          m_x_max(up_right_back_corner.x()),
          m_y_min(bottom_left_front_corner.y()),
          m_y_max(up_right_back_corner.y()),
          m_z_min(bottom_left_front_corner.z()),
          m_z_max(up_right_back_corner.z()) {
        if (!check_order()) {
            throw std::invalid_argument("Order of bbox_mesh corner is bad.");
        }
    }

    bool check_order() const { return (m_x_min <= m_x_max) && (m_y_min <= m_y_max) && (m_z_min <= m_z_max); }

    double get_x_min() const { return m_x_min; }
    double get_x_max() const { return m_x_max; }
    double get_y_min() const { return m_y_min; }
    double get_y_max() const { return m_y_max; }
    double get_z_min() const { return m_z_min; }
    double get_z_max() const { return m_z_max; }

    double get_x_size() const { return m_x_max - m_x_min; }
    double get_y_size() const { return m_y_max - m_y_min; }
    double get_z_size() const { return m_z_max - m_z_min; }

    double get_diagonal_size() const {
        return sqrt(get_x_size() * get_x_size() + get_y_size() * get_y_size() + get_z_size() * get_z_size());
    }

    double get_volume() const {
        const double surface = fabs(m_x_max - m_x_min) * fabs(m_y_max - m_y_min) * fabs(m_z_max - m_z_min);
        return surface;
    }

    vector3 get_center() const {
        constexpr double one_half = 1.0 / 2.0;
        return {one_half * (m_x_min + m_x_max), one_half * (m_y_min + m_y_max), one_half * (m_z_min + m_z_max)};
    }

    bool is_inside(const vector3 &location) const {
        return (location.x() > m_x_min) && (location.x() < m_x_max) && (location.y() > m_y_min) && (location.y() < m_y_max) &&
               (location.z() > m_z_min) && (location.z() < m_z_max);
    }

    /**
     * @brief Split the box into 8 equal sub-boxes.
     *
     * @return std::array<bbox_mesh, 8>
     */
    std::array<bbox_mesh, 8> split_3d_box_in_octants() const {
        std::array<bbox_mesh, 8> octants;
        const vector3         box_center = get_center();

        octants[0] = bbox_mesh(m_x_min, box_center.x(), m_y_min, box_center.y(), m_z_min, box_center.z());
        octants[1] = bbox_mesh(box_center.x(), m_x_max, m_y_min, box_center.y(), m_z_min, box_center.z());
        octants[2] = bbox_mesh(box_center.x(), m_x_max, box_center.y(), m_y_max, m_z_min, box_center.z());
        octants[3] = bbox_mesh(m_x_min, box_center.x(), box_center.y(), m_y_max, m_z_min, box_center.z());
        octants[4] = bbox_mesh(m_x_min, box_center.x(), m_y_min, box_center.y(), box_center.z(), m_z_max);
        octants[5] = bbox_mesh(box_center.x(), m_x_max, m_y_min, box_center.y(), box_center.z(), m_z_max);
        octants[6] = bbox_mesh(box_center.x(), m_x_max, box_center.y(), m_y_max, box_center.z(), m_z_max);
        octants[7] = bbox_mesh(m_x_min, box_center.x(), box_center.y(), m_y_max, box_center.z(), m_z_max);
        return octants;
    }

    void dilate(double factor) {
        m_x_min *= factor;
        m_x_max *= factor;
        m_y_min *= factor;
        m_y_max *= factor;
        m_z_min *= factor;
        m_z_max *= factor;
    }

    void translate(const vector3 &translation) {
        m_x_min += translation.x();
        m_x_max += translation.x();
        m_y_min += translation.y();
        m_y_max += translation.y();
        m_z_min += translation.z();
        m_z_max += translation.z();
    }

    bool is_overlapping(const bbox_mesh &second_box) const {
        const bool noOverlap = this->m_x_min > second_box.m_x_max || second_box.m_x_min > this->m_x_max ||
                               this->m_y_min > second_box.m_y_max || second_box.m_y_min > this->m_y_max ||
                               this->m_z_min > second_box.m_z_max || second_box.m_z_min > this->m_z_max;
        return !noOverlap;
    }

    friend std::ostream &operator<<(std::ostream &os, const bbox_mesh &my_box) {
        os << "bbox_mesh: x_min = " << my_box.m_x_min << " x_max = " << my_box.m_x_max << " y_min = " << my_box.m_y_min
           << " y_max = " << my_box.m_y_max << " z_min = " << my_box.m_z_min << " z_max = " << my_box.m_z_max;
        return os;
    }
};

}  // namespace bz_mesh/**
 * @file Octree_mesh.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-25
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "octree_bz.hpp"


#include <algorithm>
#include <array>
#include <memory>
#include <vector>

namespace bz_mesh {

Octree_mesh::Octree_mesh(const std::vector<Tetra *> &list_tetras, const bbox_mesh &bounding_box) {
    if (list_tetras.size() <= max_number_of_elements_per_node || bounding_box.get_diagonal_size() < min_size_of_a_node) {
        m_is_leaf     = true;
        m_list_tetras = list_tetras;
        m_node_box    = bounding_box;
        return;
    }

    m_is_leaf                        = false;
    m_node_box                       = bounding_box;
    std::array<bbox_mesh, 8> sub_boxes = m_node_box.split_3d_box_in_octants();

    for (int i = 0; i < 8; i++) {
        m_list_sub_nodes.push_back(
            std::make_unique<Octree_mesh>(Octree_mesh::find_overlapping_tetras(list_tetras, sub_boxes[i]), sub_boxes[i]));
    }
}

/**
 * @brief Find the tetra from the list of tetras that are overlapping with the bounding box.
 *
 * @note The list of pointers to tetras is passed by copy because it is modified during the search.
 * Perf should be compared with a list of pointers to tetras that is passed by reference and copied within the function.
 *
 * @param list_p_tetras
 * @param bounding_box
 * @return std::vector<Tetra *>
 */
std::vector<Tetra *> Octree_mesh::find_overlapping_tetras(const std::vector<Tetra *> &list_p_tetras, const bbox_mesh &bounding_box) {
    std::vector<Tetra *> list_overlapping_tetras;
    for (auto &p_tetra : list_p_tetras) {
        if (bounding_box.is_overlapping(p_tetra->get_bounding_box())) {
            list_overlapping_tetras.push_back(p_tetra);
        }
    }
    return list_overlapping_tetras;
}

/**
 * @brief Find the tetra that contains the location.
 * If none is found, return nullptr, else return a pointer to the tetra.
 *
 * @param location
 * @return Tetra*
 */
Tetra *Octree_mesh::find_tetra_at_location(const vector3 &location) const {
    if (!m_is_leaf) {
        for (auto &&p_sub_node : m_list_sub_nodes) {
            if (p_sub_node->is_inside(location)) {
                return p_sub_node->find_tetra_at_location(location);
            }
        }
    }
    const auto it_tetra =
        std::find_if(m_list_tetras.begin(), m_list_tetras.end(), [&](const Tetra *p_tetra) { return p_tetra->is_location_inside(location); });
    return it_tetra != m_list_tetras.end() ? *it_tetra : nullptr;
}

}  // namespace bz_mesh
/**
 * @file bz_mesh.cpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "bz_mesh.hpp"

#include <algorithm>
#include <chrono>
#include <filesystem>
#include <vector>

#include "gmsh.h"
#include "omp.h"
#include "rapidcsv.h"

#pragma omp declare reduction(merge : std::vector<double> : omp_out.insert(omp_out.end(), omp_in.begin(), omp_in.end()))

namespace bz_mesh {

void MeshBZ::shift_bz_center(const vector3& center) {
    m_center = center;
    for (auto&& vtx : m_list_vertices) {
        vtx.shift_position(center);
    }
}

inline double MeshBZ::si_to_reduced_scale() const {
    // reduced k = (a / (2π)) * k_SI
    return m_material.get_lattice_constant_meter() / (2.0 * M_PI);
}

/**
 * @brief Read the geometry of the mesh from the .msh file: the vertices and the elements are added to
 * the m_list_vertices and m_list_elements lists.
 * All the points coordinates are re-normalized by the lattice constant passed as argument.
 *
 * @param filename
 * @param lattice_constant
 */
void MeshBZ::read_mesh_geometry_from_msh_file(const std::string& filename, bool normalize_by_fourier_factor) {
    std::cout << "Opening file " << filename << std::endl;
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 1000);
    gmsh::open(filename);
    std::vector<std::size_t> nodeTags;
    std::vector<double>      nodeCoords;
    std::vector<double>      nodeParams;
    std::cout << "Reading vertices ..." << std::endl;
    gmsh::model::mesh::reclassifyNodes();
    gmsh::model::mesh::getNodes(nodeTags, nodeCoords, nodeParams, -1, -1, false, false);
    std::size_t size_nodes_tags        = nodeTags.size();
    std::size_t size_nodes_coordinates = nodeCoords.size();
    m_node_tags                        = nodeTags;
    std::cout << "Number of nodes: " << size_nodes_tags << std::endl;

    if (size_nodes_coordinates != 3 * size_nodes_tags) {
        throw std::runtime_error("Number of coordinates is not 3 times the number of vertices. Abort.");
    }

    m_list_vertices.reserve(size_nodes_tags);
    double lattice_constant = m_material.get_lattice_constant_meter();
    std::cout << "Lattice const: " << lattice_constant << std::endl;
    std::cout << "V: " << std::pow(2.0 * M_PI, 3) / std::pow(lattice_constant, 3.0) << std::endl;
    const double fourier_factor = 2.0 * M_PI / lattice_constant;
    // const double fourier_factor       = 1;
    double normalization_factor = normalize_by_fourier_factor ? fourier_factor : 1.0;
    for (std::size_t index_vertex = 0; index_vertex < size_nodes_tags; ++index_vertex) {
        m_list_vertices.push_back(Vertex(index_vertex,
                                         normalization_factor * nodeCoords[3 * index_vertex],
                                         normalization_factor * nodeCoords[3 * index_vertex + 1],
                                         normalization_factor * nodeCoords[3 * index_vertex + 2]));
    }
    std::cout << "Number of k-points vertices: " << m_list_vertices.size() << std::endl;

    // Get the mesh elements for the entity (dim, tag):
    const int                             dim = 3;
    const int                             tag = -1;
    std::vector<int>                      elemTypes;
    std::vector<std::vector<std::size_t>> elemTags, elemNodeTags;
    gmsh::model::mesh::getElements(elemTypes, elemTags, elemNodeTags, dim, tag);
    if (elemTags.empty()) {
        std::cout << "ElementTags is zero when the mesh was imported... Abort.\n";
        throw std::runtime_error("ElementTags is zero when the mesh was imported... Abort.");
    }
    std::size_t number_elements = elemTags[0].size();

    if (elemNodeTags[0].size() != 4 * number_elements) {
        throw std::runtime_error("Number of elements vertices index is not 4 x NumberOfElements. Abort.");
    }

    m_list_tetrahedra.reserve(number_elements);
    m_vertex_to_tetrahedra.resize(m_list_vertices.size());
    for (std::size_t index_element = 0; index_element < number_elements; ++index_element) {
        const std::array<Vertex*, 4> array_element_vertices = {&m_list_vertices[elemNodeTags[0][4 * index_element] - 1],
                                                               &m_list_vertices[elemNodeTags[0][4 * index_element + 1] - 1],
                                                               &m_list_vertices[elemNodeTags[0][4 * index_element + 2] - 1],
                                                               &m_list_vertices[elemNodeTags[0][4 * index_element + 3] - 1]};
        Tetra                        new_tetra(index_element, array_element_vertices);
        m_list_tetrahedra.push_back(new_tetra);
        for (std::size_t i = 0; i < 4; ++i) {
            m_vertex_to_tetrahedra[elemNodeTags[0][4 * index_element + i] - 1].push_back(index_element);
        }
    }
    gmsh::finalize();
    m_total_volume = compute_mesh_volume();
    std::cout << "Total mesh volume: " << m_total_volume << std::endl;
    // Compute the reduced BZ volume
    double       Vcell      = std::pow(m_material.get_lattice_constant_meter(), 3) / 4.0;
    const double VBZ_theory = std::pow(2.0 * M_PI, 3) / Vcell;  // m^-3

    m_reduce_bz_factor = m_total_volume / VBZ_theory;
    std::cout << "Reduce BZ factor: " << m_reduce_bz_factor << std::endl;

    precompute_G_shifts();
    Eigen::Vector3d  b1_SI                = {-1.0, 1.0, 1.0};
    Eigen::Vector3d  b2_SI                = {1.0, -1.0, 1.0};
    Eigen::Vector3d  b3_SI                = {1.0, 1.0, -1.0};
    constexpr double halfwidth_reduced    = 1.0;
    const double     ssi_to_reduced_scale = si_to_reduced_scale();
    init_reciprocal_basis(b1_SI, b2_SI, b3_SI, halfwidth_reduced, ssi_to_reduced_scale);

    // build_search_tree();
}

bbox_mesh MeshBZ::compute_bounding_box() const {
    double x_min = std::numeric_limits<double>::max();
    double y_min = std::numeric_limits<double>::max();
    double z_min = std::numeric_limits<double>::max();
    double x_max = std::numeric_limits<double>::min();
    double y_max = std::numeric_limits<double>::min();
    double z_max = std::numeric_limits<double>::min();
    for (auto&& vtx : m_list_vertices) {
        const vector3& position = vtx.get_position();
        x_min                   = std::min(x_min, position.x());
        y_min                   = std::min(y_min, position.y());
        z_min                   = std::min(z_min, position.z());
        x_max                   = std::max(x_max, position.x());
        y_max                   = std::max(y_max, position.y());
        z_max                   = std::max(z_max, position.z());
    }
    vector3 min_corner(x_min, y_min, z_min);
    vector3 max_corner(x_max, y_max, z_max);
    return bbox_mesh(min_corner, max_corner);
}

void MeshBZ::build_search_tree() {
    bbox_mesh mesh_bbox = compute_bounding_box();
    std::cout << "Mesh bounding box: " << mesh_bbox << std::endl;
    mesh_bbox.dilate(1.05);
    // bbox_mesh.translate({0.0, 0.0, 0.0});
    auto start    = std::chrono::high_resolution_clock::now();
    m_search_tree = std::make_unique<Octree_mesh>(get_list_p_tetra(), mesh_bbox);
    auto end      = std::chrono::high_resolution_clock::now();
    auto total    = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "Octree built in " << total / 1000.0 << "s" << std::endl;
}

Tetra* MeshBZ::find_tetra_at_location(const vector3& location) const { return m_search_tree->find_tetra_at_location(location); }

std::size_t MeshBZ::get_nearest_k_index(const vector3& k) const {
    std::size_t index_nearest_k = 0;
    double      min_distance    = std::numeric_limits<double>::max();
    for (std::size_t index_k = 0; index_k < m_list_vertices.size(); ++index_k) {
        double distance = (k - m_list_vertices[index_k].get_position()).norm();
        if (distance < min_distance) {
            min_distance    = distance;
            index_nearest_k = index_k;
        }
    }
    return index_nearest_k;
}

/**
 * @brief Read the energy values for each band at every k-points (vertices) of the mesh.
 *
 * @param filename
 */
void MeshBZ::read_mesh_bands_from_msh_file(const std::string& filename, int nb_bands_to_load) {
    std::cout << "Opening file " << filename << std::endl;
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::open(filename);
    // std::cout << "Read gmsh views (band energy values) ..." << std::endl;
    std::vector<int> viewTags;
    gmsh::view::getTags(viewTags);
    // std::cout << "Number of view (bands) found: " << viewTags.size() << std::endl;
    int count_band = 0;

    for (auto&& tag : viewTags) {
        if (nb_bands_to_load != -1 && count_band >= nb_bands_to_load) break;

        const int   index_view  = gmsh::view::getIndex(tag);
        std::string name_object = "View[" + std::to_string(index_view) + "].Name";
        std::string name_view;
        try {
            gmsh::option::getString(name_object, name_view);
        } catch (const std::exception& e) {
            std::cerr << e.what() << '\n';
        }

        std::string              type;
        std::vector<std::size_t> tags;
        double                   time;
        int                      numComp;
        std::vector<double>      data_view;
        gmsh::view::getHomogeneousModelData(tag, 0, type, tags, data_view, time, numComp);
        bool is_valence = data_view[0] <= 0.1;
        if (is_valence) {
            m_indices_valence_bands.push_back(count_band);
        } else {
            m_indices_conduction_bands.push_back(count_band);
        }
        count_band++;
        auto minmax_band = std::minmax_element(data_view.begin(), data_view.end());
        m_min_band.push_back(*(minmax_band.first));
        m_max_band.push_back(*(minmax_band.second));
        add_new_band_energies_to_vertices(data_view);
    }
    gmsh::finalize();
    // PRINT INDICES
    std::cout << "Number of bands loaded: " << m_min_band.size() << std::endl;
    std::cout << "Number of valence bands: " << m_indices_valence_bands.size() << std::endl;
    std::cout << "Number of conduction bands: " << m_indices_conduction_bands.size() << std::endl;
    for (auto&& idx : m_indices_valence_bands) {
        std::cout << "Valence band index: " << idx << std::endl;
    }
    for (auto&& idx : m_indices_conduction_bands) {
        std::cout << "Conduction band index: " << idx << std::endl;
    }

    auto_shift_conduction_band_energies();
    auto_set_positive_valence_band_energies();
    compute_min_max_energies_at_tetras();
    compute_energy_gradient_at_tetras();
    set_energy_gradient_at_vertices_by_averaging_tetras();
    for (auto&& tetra : m_list_tetrahedra) {
        tetra.pre_compute_sorted_slots_per_band();
    }

    // Print band info
    std::cout << "Number of bands loaded: " << m_min_band.size() << std::endl;
    std::cout << "Number of valence bands: " << m_indices_valence_bands.size() << std::endl;
    std::cout << "Number of conduction bands: " << m_indices_conduction_bands.size() << std::endl;
    for (std::size_t i = 0; i < m_min_band.size(); ++i) {
        std::cout << "Band " << i << ": min = " << m_min_band[i] << " eV, max = " << m_max_band[i] << " eV";
        if (std::find(m_indices_valence_bands.begin(), m_indices_valence_bands.end(), i) != m_indices_valence_bands.end()) {
            std::cout << " (valence band)";
        } else if (std::find(m_indices_conduction_bands.begin(), m_indices_conduction_bands.end(), i) != m_indices_conduction_bands.end()) {
            std::cout << " (conduction band)";
        }
        std::cout << std::endl;
    }

    export_energies_and_gradients_to_vtk("mesh_energies_gradients.vtk");
}

void MeshBZ::precompute_dos_tetra(double energy_step, double energy_threshold) {
    std::cout << "Precomputing DOS per tetrahedra with energy step = " << energy_step << " eV ..." << std::endl;
    auto start = std::chrono::high_resolution_clock::now();
#pragma omp parallel for schedule(dynamic)
    for (std::size_t i = 0; i < m_list_tetrahedra.size(); ++i) {
        m_list_tetrahedra[i].precompute_dos_on_energy_grid_per_band(energy_step, energy_threshold);
    }
}

void MeshBZ::set_energy_gradient_at_vertices_by_averaging_tetras() {
    std::cout << "Setting energy gradient at vertices by averaging tetrahedra gradients ..." << std::endl;
    for (std::size_t i = 0; i < m_list_vertices.size(); ++i) {
        for (std::size_t b = 0; b < m_list_vertices[i].get_number_bands(); ++b) {
            vector3 gradient_sum(0.0, 0.0, 0.0);
            int     count = 0;
            for (auto&& tetra_idx : m_vertex_to_tetrahedra[i]) {
                gradient_sum += m_list_tetrahedra[tetra_idx].get_gradient_energy_at_band(b);
                count++;
            }
            if (count > 0) {
                gradient_sum /= static_cast<double>(count);
                m_list_vertices[i].push_back_energy_gradient_at_band(gradient_sum);
            } else {
                m_list_vertices[i].push_back_energy_gradient_at_band(vector3(0.0, 0.0, 0.0));
            }
        }
    }
    std::cout << "Done." << std::endl;
}

void MeshBZ::recompute_min_max_energies() {
    m_min_band.clear();
    m_max_band.clear();
    int nb_bands = m_list_vertices[0].get_number_bands();
    m_min_band.resize(nb_bands, std::numeric_limits<double>::max());
    m_max_band.resize(nb_bands, std::numeric_limits<double>::lowest());
    for (auto&& vtx : m_list_vertices) {
        const auto& energies = vtx.get_band_energies();
        for (int i = 0; i < nb_bands; ++i) {
            if (energies[i] < m_min_band[i]) m_min_band[i] = energies[i];
            if (energies[i] > m_max_band[i]) m_max_band[i] = energies[i];
        }
    }
    // Print band info
    std::cout << "Number of bands: " << m_min_band.size() << std::endl;
    for (std::size_t i = 0; i < m_min_band.size(); ++i) {
        std::cout << "Band " << i << ": min = " << m_min_band[i] << " eV, max = " << m_max_band[i] << " eV";
        if (std::find(m_indices_valence_bands.begin(), m_indices_valence_bands.end(), i) != m_indices_valence_bands.end()) {
            std::cout << " (valence band)";
        } else if (std::find(m_indices_conduction_bands.begin(), m_indices_conduction_bands.end(), i) != m_indices_conduction_bands.end()) {
            std::cout << " (conduction band)";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
}

/**
 * @brief Keep only a subset of bands (valence and conduction) in the mesh. Remove higher (relative) bands.
 * @param nb_valence_bands Number of valence bands to keep
 * @param nb_conduction_bands Number of conduction bands to keep
 */
void MeshBZ::keep_only_bands(const int nb_valence_bands, const int nb_conduction_bands) {
    int nb_valence_to_remove    = static_cast<int>(m_indices_valence_bands.size()) - nb_valence_bands;
    int nb_conduction_to_remove = static_cast<int>(m_indices_conduction_bands.size()) - nb_conduction_bands;
    if (nb_valence_to_remove < 0 || nb_conduction_to_remove < 0) {
        throw std::runtime_error("Cannot keep more bands than available.");
    }
    std::cout << "Removing " << nb_valence_to_remove << " valence bands and " << nb_conduction_to_remove << " conduction bands."
              << std::endl;
    // Remove higher valence bands
    for (int i = 0; i < nb_valence_to_remove; ++i) {
        int band_to_remove = m_indices_valence_bands.back();
        m_indices_valence_bands.pop_back();
        for (auto&& vtx : m_list_vertices) {
            vtx.remove_band_energy(band_to_remove);
        }
    }
    // Remove higher conduction bands
    for (int i = 0; i < nb_conduction_to_remove; ++i) {
        int band_to_remove = m_indices_conduction_bands.back();
        m_indices_conduction_bands.pop_back();
        for (auto&& vtx : m_list_vertices) {
            vtx.remove_band_energy(band_to_remove);
        }
    }
    // Recompute min/max band energies
    recompute_min_max_energies();
    std::cout << "After removing bands:" << std::endl;
    std::cout << "Number of valence bands: " << m_indices_valence_bands.size() << std::endl;
    std::cout << "Number of conduction bands: " << m_indices_conduction_bands.size() << std::endl;
}

void MeshBZ::add_new_band_energies_to_vertices(const std::vector<double>& energies_at_vertices) {
    if (energies_at_vertices.size() != m_list_vertices.size()) {
        throw std::invalid_argument("The number of energy values does not match the number of vertices. Abort.");
    }
    for (std::size_t index_vtx = 0; index_vtx < m_list_vertices.size(); ++index_vtx) {
        m_list_vertices[index_vtx].add_band_energy_value(energies_at_vertices[index_vtx]);
    }
}

void MeshBZ::compute_min_max_energies_at_tetras() {
    for (auto&& tetra : m_list_tetrahedra) {
        tetra.compute_min_max_energies_at_bands();
    }
}

void MeshBZ::auto_set_positive_valence_band_energies() {
    for (int vband : m_indices_valence_bands) {
        for (auto&& vtx : m_list_vertices) {
            double energy = vtx.get_energy_at_band(vband);
            vtx.set_band_energy(vband, std::fabs(energy));
        }
    }
}

void MeshBZ::auto_shift_conduction_band_energies() {
    if (m_indices_conduction_bands.empty()) return;

    // Find the highest valence band maximum
    double max_valence = std::numeric_limits<double>::lowest();
    for (int vband : m_indices_valence_bands) {
        max_valence = std::max(max_valence, m_max_band[vband]);
    }
    if (m_indices_valence_bands.empty()) {
        max_valence = 0.0;
    }
    std::cout << "Max valence band energy: " << max_valence << " eV\n";

    // Find the lowest conduction band minimum
    double min_conduction = std::numeric_limits<double>::max();
    for (int cband : m_indices_conduction_bands) {
        min_conduction = std::min(min_conduction, m_min_band[cband]);
    }
    std::cout << "Min conduction band energy: " << min_conduction << " eV\n";

    double band_gap = min_conduction - max_valence;
    std::cout << "Computed band gap: " << band_gap << " eV\n";

    if (band_gap < 0.1) {
        std::cout << "Warning: computed band gap is very small or negative (" << band_gap << " eV). No shift applied.\n";
        return;
    }

    // Shift all conduction bands so that the conduction band minimum aligns with the valence band maximum
    double shift_amount = -min_conduction + max_valence;
    std::cout << "Shifting conduction bands by " << shift_amount << " eV to align CBM with VBM.\n";

    // void set_band_energy(std::size_t index_band, double new_energy) {

    for (auto&& vtx : m_list_vertices) {
        for (int cband : m_indices_conduction_bands) {
            double old_energy = vtx.get_energy_at_band(cband);
            double new_energy = old_energy + shift_amount;
            vtx.set_band_energy(cband, new_energy);
        }
    }

    // Recompute per-band min/max
    m_min_band.clear();
    m_max_band.clear();
    for (std::size_t b = 0; b < m_list_vertices[0].get_number_bands(); ++b) {
        double bmin = std::numeric_limits<double>::max();
        double bmax = std::numeric_limits<double>::lowest();
        for (auto&& vtx : m_list_vertices) {
            double e = vtx.get_energy_at_band(b);
            bmin     = std::min(bmin, e);
            bmax     = std::max(bmax, e);
        }
        m_min_band.push_back(bmin);
        m_max_band.push_back(bmax);
    }

    std::cout << "Post-shift band extrema:\n";
    for (std::size_t b = 0; b < m_min_band.size(); ++b) {
        std::cout << " Band " << b << ": min = " << m_min_band[b] << " eV, max = " << m_max_band[b] << " eV\n";
    }
    std::cout << std::endl;
}

void MeshBZ::set_bands_in_right_order() {
    if (m_indices_valence_bands.empty() || m_indices_conduction_bands.empty()) {
        std::cout << "Warning: valence or conduction band indices are empty. Cannot reorder bands.\n";
        return;
    }

    // DEBUG PROVISOIRE
    for (auto&& vtx : m_list_vertices) {
        vtx.swap_bands(m_indices_valence_bands[0], m_indices_valence_bands.back());
        vtx.swap_bands(m_indices_valence_bands[1], m_indices_valence_bands[m_indices_valence_bands.size() - 2]);
        std::cout << "Swapped bands for vertex " << vtx.get_index() << ": band " << m_indices_valence_bands[0] << " with band "
                  << m_indices_valence_bands.back() << ", band " << m_indices_valence_bands[1] << " with band "
                  << m_indices_valence_bands[m_indices_valence_bands.size() - 2] << std::endl;
    }
    recompute_min_max_energies();
}

void MeshBZ::compute_energy_gradient_at_tetras() {
    for (auto&& tetra : m_list_tetrahedra) {
        tetra.compute_gradient_energy_at_bands();
    }
}

vector3 MeshBZ::interpolate_energy_gradient_at_location(const vector3& location, const std::size_t& idx_band) const {
    Tetra* tetra = find_tetra_at_location(location);
    if (tetra == nullptr) {
        throw std::runtime_error("Location is outside the mesh. Cannot interpolate energy gradient.");
    }
    return tetra->get_gradient_energy_at_band(idx_band);
}

double MeshBZ::compute_mesh_volume() const {
    double total_volume = 0.0;
    for (auto&& tetra : m_list_tetrahedra) {
        total_volume += std::fabs(tetra.get_signed_volume());
        // std::cout << "Tetra " << tetra.get_index() << " volume: " << tetra.get_signed_volume() << std::endl;
    }
    // total_volume *= (1.0 / pow(2.0 * M_PI, 3.0));
    return total_volume;
}

double MeshBZ::compute_iso_surface(double iso_energy, int band_index) const {
    double total_dos = 0.0;
    for (auto&& tetra : m_list_tetrahedra) {
        total_dos += tetra.compute_tetra_iso_surface_energy_band(iso_energy, band_index);
    }

    return total_dos;
}

double MeshBZ::compute_dos_at_energy_and_band(double iso_energy, int band_index, bool use_interp) const {
    double total_dos = 0.0;
    for (auto&& tetra : m_list_tetrahedra) {
        if (use_interp) {
            total_dos += tetra.interpolate_dos_at_energy_per_band(iso_energy, band_index);
        } else {
            total_dos += tetra.compute_tetra_dos_energy_band(iso_energy, band_index);
        }
    }
    total_dos *= get_reduce_bz_factor();
    total_dos *= m_spin_degeneracy;
    return total_dos;
}

std::vector<std::vector<double>> MeshBZ::compute_dos_band_at_band(int         band_index,
                                                                  double      min_energy,
                                                                  double      max_energy,
                                                                  int         num_threads,
                                                                  std::size_t nb_points,
                                                                  bool        use_interp) const {
    auto   start       = std::chrono::high_resolution_clock::now();
    double energy_step = (max_energy - min_energy) / (nb_points - 1);

    std::vector<double> list_energies{};
    std::vector<double> list_dos{};
#pragma omp parallel for schedule(dynamic) num_threads(num_threads) reduction(merge : list_energies) reduction(merge : list_dos)
    for (std::size_t index_energy = 0; index_energy < nb_points; ++index_energy) {
        double energy = min_energy + index_energy * energy_step;
        double dos    = compute_dos_at_energy_and_band(energy, band_index);
        list_energies.push_back(energy);
        list_dos.push_back(dos);
        //         std::cout << "\rComputing density of state at energy " << index_energy << "/" << nb_points << std::flush;
    }
    auto end              = std::chrono::high_resolution_clock::now();
    auto total_time_count = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "\nDOS for 1 band computed in  " << total_time_count / 1000.0 << "s" << std::endl;
    return {list_energies, list_dos};
}

std::vector<std::vector<double>> MeshBZ::compute_dos_band_at_band_auto(int         band_index,
                                                                       std::size_t nb_points,
                                                                       int         num_threads,
                                                                       bool        use_interp) const {
    if (band_index < 0 || band_index >= static_cast<int>(m_min_band.size())) {
        throw std::out_of_range("Band index out of range in compute_dos_band_at_band_auto.");
    }

    const double margin_energy = 0.1;
    double       min_energy    = m_min_band[band_index] - margin_energy;
    double       max_energy    = m_max_band[band_index] + margin_energy;
    auto         start         = std::chrono::high_resolution_clock::now();
    double       energy_step   = (max_energy - min_energy) / (nb_points - 1);

    std::vector<double> list_energies{};
    std::vector<double> list_dos{};
#pragma omp parallel for schedule(dynamic) num_threads(num_threads) reduction(merge : list_energies) reduction(merge : list_dos)
    for (std::size_t index_energy = 0; index_energy < nb_points; ++index_energy) {
        double energy = min_energy + index_energy * energy_step;
        double dos    = compute_dos_at_energy_and_band(energy, band_index, use_interp);
        list_energies.push_back(energy);
        list_dos.push_back(dos);
    }
    auto end              = std::chrono::high_resolution_clock::now();
    auto total_time_count = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "\nDOS for 1 band computed in  " << total_time_count / 1000.0 << "s" << std::endl;
    return {list_energies, list_dos};
}

/**
 * @brief Draw a random tetrahedron index in the mesh, on a iso-energy surface.
 *
 * @param energy
 * @param idx_band
 * @param random_generator
 * @return std::size_t
 */
std::size_t MeshBZ::draw_random_tetrahedron_index_with_dos_probability(double        energy,
                                                                       std::size_t   idx_band,
                                                                       std::mt19937& random_generator) const {
    std::vector<double> list_dos;
    list_dos.reserve(m_list_tetrahedra.size());
    std::cout << "Computing DOS weights for tetrahedra at energy " << energy << " eV ..." << std::endl;
    for (auto&& tetra : m_list_tetrahedra) {
        std::cout << "\rTetra " << tetra.get_index() << "/" << m_list_tetrahedra.size() << std::flush;
        double dos = tetra.compute_tetra_dos_energy_band(energy, idx_band);
        list_dos.push_back(dos);
    }
    std::cout << "\nDrawing tetrahedron with DOS weights ..." << std::endl;
    std::discrete_distribution<std::size_t> distribution(list_dos.begin(), list_dos.end());
    return distribution(random_generator);
}

/**
 * @brief Draw a random k-vector in the mesh, on a iso-energy surface.
 * The k-vector is drawn with a probability locally proportional to the DOS.
 *
 * @param energy
 * @param idx_band
 * @param random_generator
 * @return vector3
 */
vector3 MeshBZ::draw_random_k_point_at_energy(double energy, std::size_t idx_band, std::mt19937& random_generator) const {
    if (energy < m_min_band[idx_band] || energy > m_max_band[idx_band]) {
        throw std::runtime_error("Energy is out of range");
    }
    const std::size_t index_tetra = draw_random_tetrahedron_index_with_dos_probability(energy, idx_band, random_generator);
    std::cout << "Selected tetrahedron index: " << index_tetra << std::endl;
    if (index_tetra >= m_list_tetrahedra.size()) {
        throw std::runtime_error("Selected tetrahedron index is out of range");
    }
    return m_list_tetrahedra[index_tetra].draw_random_uniform_point_at_energy(energy, idx_band, random_generator);
}

void MeshBZ::export_k_points_to_file(const std::string& filename) const {
    std::ofstream file(filename);
    if (!file.is_open()) {
        throw std::invalid_argument("Could not open file " + filename + " for writing.");
    }
    for (auto&& k_point : m_list_vertices) {
        file << k_point.get_position().x() << "," << k_point.get_position().y() << "," << k_point.get_position().z() << std::endl;
    }
    file.close();
}

// helper: half-width in reduced units.
static inline double bz_halfwidth_reduced() { return 1.0; }  // <- your case

bool MeshBZ::is_inside_mesh_geometry(const vector3& k) const {
    const double     s   = si_to_reduced_scale();   // converts SI (1/m) -> reduced (unitless)
    const double     hw  = bz_halfwidth_reduced();  // 1.0 for [-1,1], 0.5 for [-0.5,0.5]
    constexpr double eps = 1e-12;

    const double kx = k.x() * s;
    const double ky = k.y() * s;
    const double kz = k.z() * s;

    const double ax = std::fabs(kx);
    const double ay = std::fabs(ky);
    const double az = std::fabs(kz);

    const bool cond1 = (ax <= hw + eps) && (ay <= hw + eps) && (az <= hw + eps);
    const bool cond2 = (ax + ay + az) <= (1.5 * hw + eps);

    return cond1 && cond2;
}

void MeshBZ::precompute_G_shifts() {
    vector3      b1 = {-1.0, 1.0, 1.0};
    vector3      b2 = {1.0, -1.0, 1.0};
    vector3      b3 = {1.0, 1.0, -1.0};
    const double s  = si_to_reduced_scale();
    b1 /= s;
    b2 /= s;
    b3 /= s;

    const int maxShell = 5;  // adjust as needed

    // shell 0
    m_Gshifts.push_back({0, 0, 0});

    // by increasing |n1|+|n2|+|n3|
    for (int L1 = 1; L1 <= maxShell; ++L1) {
        for (int n1 = -L1; n1 <= L1; ++n1) {
            for (int n2 = -L1; n2 <= L1; ++n2) {
                for (int n3 = -L1; n3 <= L1; ++n3) {
                    if (n1 == 0 && n2 == 0 && n3 == 0) continue;
                    if (std::abs(n1) + std::abs(n2) + std::abs(n3) == L1) {
                        m_Gshifts.push_back(n1 * b1 + n2 * b2 + n3 * b3);
                    }
                }
            }
        }
    }
}

vector3 MeshBZ::retrieve_k_inside_mesh_geometry(const vector3& k) const {
    for (const auto& G : m_Gshifts) {
        const vector3 kG = k + G;
        if (is_inside_mesh_geometry(kG)) {
            return kG;
        }
    }
    std::cout << "No k-point inside the mesh geometry found for k: " << k << std::endl;
    throw std::runtime_error("No k-point inside the mesh geometry found.");
}

// --- O(1) WS-BZ folding (public API) ---
/**
 * @brief Initialize the reciprocal basis and reduced-frame parameters for O(1) folding.
 * @param b1_SI First reciprocal primitive vector (SI, 1/m)
 * @param b2_SI Second reciprocal primitive vector (SI, 1/m)
 * @param b3_SI Third reciprocal primitive vector (SI, 1/m)
 * @param halfwidth_reduced Half-width in reduced coords (0.5 for [-0.5,0.5])
 * @param si_to_reduced Scale factor from SI (1/m) to reduced coords used by plane tests
 */
void MeshBZ::init_reciprocal_basis(const Eigen::Vector3d& b1_SI,
                                   const Eigen::Vector3d& b2_SI,
                                   const Eigen::Vector3d& b3_SI,
                                   double                 halfwidth_reduced,
                                   double                 si_to_reduced) {
    m_recip_B.col(0) = b1_SI;
    m_recip_B.col(1) = b2_SI;
    m_recip_B.col(2) = b3_SI;
    m_recip_Bi       = m_recip_B.inverse();

    m_bz_halfwidth = halfwidth_reduced;  // e.g. 0.5 for [-0.5,0.5]
    m_si2red       = si_to_reduced;      // must match your is_inside_mesh_geometry() scale
}

/**
 * @brief Fold k into the Wigner–Seitz BZ (truncated octahedron of bcc). Pure, no side effects.
 * @param k_SI Input wavevector (SI, 1/m)
 * @return Folded wavevector inside the first BZ (SI, 1/m)
 */
vector3 MeshBZ::fold_ws_bcc(const vector3& k_SI) const noexcept {
    // Convert to Eigen for the tiny linear algebra steps
    Eigen::Vector3d ke(k_SI.x(), k_SI.y(), k_SI.z());

    // A) Nearest-lattice wrap (Babai rounding) into the primitive parallelepiped
    Eigen::Vector3d r  = m_recip_Bi * ke;    // reduced coords in basis of reciprocal vectors
    Eigen::Array3d  n  = r.array().round();  // nearest reciprocal-lattice node
    Eigen::Vector3d k0 = ke - m_recip_B * n.matrix();

    // B) Apply WS (truncated-octahedron) plane tests in your reduced frame
    Eigen::Vector3d kr = m_si2red * k0;

    const double hw      = m_bz_halfwidth;
    const double sum_lim = 1.5 * hw;
    const double eps     = 1e-12 * std::max(1.0, hw);

    // A few corrections always suffice after Babai; 3 passes is plenty.
    for (int it = 0; it < 3; ++it) {
        const double ax = std::abs(kr.x()), ay = std::abs(kr.y()), az = std::abs(kr.z());
        bool         moved = false;

        // 6 square faces: |x|,|y|,|z| ≤ hw
        if (ax > hw + eps) {
            kr.x() -= (kr.x() > 0 ? 1.0 : -1.0) * 2.0 * hw;
            moved = true;
        }
        if (ay > hw + eps) {
            kr.y() -= (kr.y() > 0 ? 1.0 : -1.0) * 2.0 * hw;
            moved = true;
        }
        if (az > hw + eps) {
            kr.z() -= (kr.z() > 0 ? 1.0 : -1.0) * 2.0 * hw;
            moved = true;
        }

        // 8 hex faces: |x| + |y| + |z| ≤ 1.5*hw
        if ((ax + ay + az) > (sum_lim + eps)) {
            const int    idx    = (ax >= ay && ax >= az) ? 0 : (ay >= az ? 1 : 2);
            const double excess = (ax + ay + az) - sum_lim;
            if (idx == 0)
                kr.x() -= (kr.x() > 0 ? 1.0 : -1.0) * excess;
            else if (idx == 1)
                kr.y() -= (kr.y() > 0 ? 1.0 : -1.0) * excess;
            else
                kr.z() -= (kr.z() > 0 ? 1.0 : -1.0) * excess;
            moved = true;
        }

        if (!moved) break;  // inside WS
    }

    // Back to SI and convert to your vector3
    Eigen::Vector3d kf = kr / m_si2red;
    return vector3{kf.x(), kf.y(), kf.z()};
}

/**
 * @brief Check if k is inside the WS BZ using the same plane tests as is_inside_mesh_geometry().
 * @param k_SI Input wavevector (SI, 1/m)
 * @return true if inside, false otherwise
 */
bool MeshBZ::inside_ws_bcc(const vector3& k_SI) const noexcept {
    Eigen::Vector3d kr = m_si2red * Eigen::Vector3d(k_SI.x(), k_SI.y(), k_SI.z());
    const double    hw = m_bz_halfwidth, eps = 1e-12 * std::max(1.0, hw);
    const double    ax = std::abs(kr.x()), ay = std::abs(kr.y()), az = std::abs(kr.z());
    // use bitwise & so all comparisons are evaluated (branchless)
    return (ax <= hw + eps) & (ay <= hw + eps) & (az <= hw + eps) & ((ax + ay + az) <= (1.5 * hw + eps));
}

// bool is_in_first_BZ(const Vector3D<double>& k, bool one_eighth = false) {
//     bool cond_1      = fabs(k.X) <= 1.0 && fabs(k.Y) <= 1.0 && fabs(k.Z) <= 1.0;
//     bool cond_2      = fabs(k.X) + fabs(k.Y) + fabs(k.Z) <= 3.0 / 2.0;
//     bool cond_eighth = (k.X >= 0.0 && k.Y >= 0.0 && k.Z >= 0.0);
//     return cond_1 && cond_2 && (one_eighth ? cond_eighth : true);
// }

// def IsInIrreducibleWedge(k):
//     return (k[2] >= 0.0 and k[2] <= k[1] and k[1] <= k[0] and k[0] <= 1.0) and \
//         (np.sum(k) <= 3.0/2.0)

bool MeshBZ::is_irreducible_wedge(const vector3& k_SI) const noexcept {
    const double x = k_SI.x() * si_to_reduced_scale();
    const double y = k_SI.y() * si_to_reduced_scale();
    const double z = k_SI.z() * si_to_reduced_scale();
    // std::cout << "Checking irreducible wedge for k = (" << x << ", " << y << ", " << z << ")" << std::endl;
    constexpr double eps = 1e-12;
    return (x >= -eps) && (y >= -eps) && (z >= -eps) && (x <= y + eps) && (y <= z + eps) && (z <= 1.0 + eps) && ((x + y + z) <= 1.5 + eps);
}

/**
 * @brief Find the index of the vertex in the irreducible wedge that represents k_SI.
 * In this version, we first first fold k_SI into the first IW, then search for the closest vertex.
 *
 *
 * @param k_SI
 * @return std::size_t
 */
std::size_t MeshBZ::get_index_irreducible_wedge(const vector3& k_SI) const noexcept {
    vector3 k_folded = {std::fabs(k_SI.x()), std::fabs(k_SI.y()), std::fabs(k_SI.z())};
    // Test the 6 permutations of (|kx|, |ky|, |kz|)
    std::array<vector3, 6> permutations = {vector3{k_folded.x(), k_folded.y(), k_folded.z()},
                                           vector3{k_folded.x(), k_folded.z(), k_folded.y()},
                                           vector3{k_folded.y(), k_folded.x(), k_folded.z()},
                                           vector3{k_folded.y(), k_folded.z(), k_folded.x()},
                                           vector3{k_folded.z(), k_folded.x(), k_folded.y()},
                                           vector3{k_folded.z(), k_folded.y(), k_folded.x()}};
    bool                   found        = false;
    for (auto&& perm : permutations) {
        if (is_irreducible_wedge(perm)) {
            k_folded = perm;
            found    = true;
            break;
        }
    }
    std::cout << std::setprecision(6) << std::fixed;
    // std::cout << k_folded*si_to_reduced_scale() << std::endl;
    if (!found) {
        std::cout << "Could not fold k = " << k_SI << " into the irreducible wedge." << std::endl;
        throw std::runtime_error("Could not fold k into the irreducible wedge.");
    }
    // Now search for the closest vertex in the IW
    double       min_dist = std::numeric_limits<double>::max();
    std::size_t  idx_min  = 0;
    const double s        = si_to_reduced_scale();
    for (const auto& vtx : m_list_vertices) {
        if (is_irreducible_wedge(vtx.get_position())) {
            double dist = (vtx.get_position() - k_folded).norm_squared();
            if (dist < min_dist) {
                min_dist = dist;
                idx_min  = vtx.get_index();
            }
        }
    }
    // Scientific notation for very small distances
    // std::cout << "Min dist in IW: " << std::scientific << std::sqrt(min_dist) * si_to_reduced_scale() << std::endl;
    return idx_min;
}

#include <fstream>
#include <iomanip>
#include <map>
#include <stdexcept>
#include <string>

static inline void bz_write_vtk_scalars(std::ofstream&             out,
                                        const std::string&         name,
                                        const std::vector<double>& vals,
                                        const char*                loc_keyword,  // "POINT_DATA" or "CELL_DATA" already emitted
                                        std::size_t                expected_count) {
    if (vals.size() != expected_count) {
        throw std::runtime_error("VTK export: scalar field '" + name + "' has size " + std::to_string(vals.size()) + ", expected " +
                                 std::to_string(expected_count));
    }
    out << "SCALARS " << name << " double 1\n";
    out << "LOOKUP_TABLE default\n";
    out << std::setprecision(17);
    for (double v : vals)
        out << v << "\n";
}

static inline void bz_write_vtk_vectors(std::ofstream&              out,
                                        const std::string&          name,
                                        const std::vector<vector3>& vecs,
                                        const char*                 loc_keyword,
                                        std::size_t                 expected_count) {
    if (vecs.size() != expected_count) {
        throw std::runtime_error("VTK export: vector field '" + name + "' has size " + std::to_string(vecs.size()) + ", expected " +
                                 std::to_string(expected_count));
    }
    out << "VECTORS " << name << " double\n";
    out << std::setprecision(17);
    for (const auto& v : vecs) {
        out << v.x() << " " << v.y() << " " << v.z() << "\n";
    }
}

void MeshBZ::export_to_vtk(const std::string&        filename,
                           const MapStringToDoubles& point_scalars,
                           const MapStringToVectors& point_vectors,
                           const MapStringToDoubles& cell_scalars,
                           const MapStringToVectors& cell_vectors) const {
    const std::size_t n_points = m_list_vertices.size();
    const std::size_t n_cells  = m_list_tetrahedra.size();

    std::ofstream out(filename);
    if (!out) throw std::runtime_error("Cannot open VTK file '" + filename + "' for writing.");

    // --- VTK legacy header (ASCII, UnstructuredGrid) ---
    out << "# vtk DataFile Version 4.2\n";
    out << "BZ mesh export\n";
    out << "ASCII\n";
    out << "DATASET UNSTRUCTURED_GRID\n";

    // --- POINTS ---
    out << "POINTS " << n_points << " double\n";
    out << std::setprecision(17);
    for (const auto& v : m_list_vertices) {
        const auto& p = v.get_position();
        out << p.x() << " " << p.y() << " " << p.z() << "\n";
    }

    // --- CELLS (tetra) ---
    // For legacy VTK: total_indices = n_cells * (1 + 4) because each line: "4 i0 i1 i2 i3"
    const std::size_t total_idx = n_cells * (1 + 4);
    out << "CELLS " << n_cells << " " << total_idx << "\n";
    for (const auto& t : m_list_tetrahedra) {
        const auto ids = t.get_list_indices_vertices();  // assumes 0-based vertex ids
        out << "4 " << ids[0] << " " << ids[1] << " " << ids[2] << " " << ids[3] << "\n";
    }

    // --- CELL_TYPES (tetra = 10) ---
    out << "CELL_TYPES " << n_cells << "\n";
    for (std::size_t i = 0; i < n_cells; ++i)
        out << "10\n";

    // --- Optional per-vertex data ---
    if (!point_scalars.empty() || !point_vectors.empty()) {
        out << "POINT_DATA " << n_points << "\n";
        for (const auto& [name, vals] : point_scalars) {
            bz_write_vtk_scalars(out, name, vals, "POINT_DATA", n_points);
        }
        for (const auto& [name, vecs] : point_vectors) {
            bz_write_vtk_vectors(out, name, vecs, "POINT_DATA", n_points);
        }
    }

    // --- Optional per-cell data ---
    if (!cell_scalars.empty() || !cell_vectors.empty()) {
        out << "CELL_DATA " << n_cells << "\n";
        for (const auto& [name, vals] : cell_scalars) {
            bz_write_vtk_scalars(out, name, vals, "CELL_DATA", n_cells);
        }
        for (const auto& [name, vecs] : cell_vectors) {
            bz_write_vtk_vectors(out, name, vecs, "CELL_DATA", n_cells);
        }
    }
    out.close();
}




void MeshBZ::export_energies_and_gradients_to_vtk(const std::string& filename) const {
    std::map<std::string, std::vector<double>> point_scalars;
    std::map<std::string, std::vector<vector3>> point_vectors;

    // Per-vertex band energies
    for (std::size_t b = 0; b < m_list_vertices[0].get_number_bands(); ++b) {
        std::string               name = "band_energy_" + std::to_string(b);
        std::vector<double>       vals;
        vals.reserve(m_list_vertices.size());
        for (const auto& v : m_list_vertices) {
            vals.push_back(v.get_energy_at_band(b));
        }
        point_scalars[name] = vals;
    }

    // Per-vertex band energy gradients
    for (std::size_t b = 0; b < m_list_vertices[0].get_number_bands(); ++b) {
        std::string               name = "band_grad_" + std::to_string(b);
        std::vector<vector3>      vecs;
        vecs.reserve(m_list_vertices.size());
        for (const auto& v : m_list_vertices) {
            vecs.push_back(v.get_energy_gradient_at_band(b));
        }
        point_vectors[name] = vecs;
    }
    export_to_vtk(filename, point_scalars, point_vectors, {}, {});
}

}  // namespace bz_mesh/**
 * @file iso_triangle.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-16
 *
 * @copyright Copyright (c) 2022
 *
 */

#include <array>
#include <random>
#include <vector>

#include "vector.hpp"

namespace bz_mesh {

/**
 * @brief This class represent the iso energy triangle within a Tetra.
 *
 */
class IsoTriangle {
 private:
    /**
     * @brief The positions of the 3 vertices of the triangle.
     *
     */
    std::array<vector3, 3> m_list_vertices{};

    /**
     * @brief Iso energy the triangle was constructed with.
     *
     */
    double m_iso_energy;

    /**
     * @brief List of the edges vectors of the tetrahedra.
     * Stored as follows: [v01, v02, v12]
     * where for example v12 = m_list_vertices[1] - m_list_vertices[2].
     *
     */
    std::array<vector3, 3> m_list_edges{};

    /**
     * @brief Signed volume of the tetrahedra.
     * The sign depends on the "orientation" of the tetrahedra.
     *
     */
    double m_surface;

 public:
    IsoTriangle() = delete;

    /**
     * @brief Construct a new Iso Triangle object from the list of vertices and the iso energy.
     *
     * @param VtxA
     * @param VtxB
     * @param VtxC
     * @param iso_energy
     */
    IsoTriangle(const vector3& VtxA, const vector3& VtxB, const vector3& VtxC, double iso_energy)
        : m_list_vertices{VtxA, VtxB, VtxC},
          m_iso_energy(iso_energy),
          m_list_edges{VtxA - VtxB, VtxA - VtxC, VtxB - VtxC},
          m_surface{0.5 * (cross_product(m_list_edges[1], m_list_edges[2]).norm())} {}

    /**
     * @brief Get the iso energy of the triangle.
     *
     * @return double
     */
    double get_iso_energy() const { return m_iso_energy; }

    /**
     * @brief Get the surface of the triangle.
     *
     * @return double
     */
    double get_signed_surface() const { return m_surface; }

    /**
     * @brief Draw a random point in the triangle. Uniform distribution.
     * See https://math.stackexchange.com/questions/538458/how-to-sample-points-on-a-triangle-surface-in-3d
     *
     * @param gen
     * @return vector3
     */
    vector3 draw_random_uniform_point_in_triangle(std::mt19937& gen) const {
        std::uniform_real_distribution<> dis_double(0.0, 1.0);
        double                           random_a = dis_double(gen);
        double                           random_b = dis_double(gen);
        double                           lambda_1 = (1.0 - sqrt(random_a));
        double                           lambda_2 = sqrt(random_a) * (1.0 - random_b);
        double                           lambda_3 = sqrt(random_a) * random_b;
        //   return get_center();
        return m_list_vertices[0] * lambda_1 + m_list_vertices[1] * lambda_2 + m_list_vertices[2] * lambda_3;
    }
};

}  // namespace bz_mesh/**
 * @file mesh_tetra.cpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "mesh_tetra.hpp"

#include <algorithm>
#include <array>
#include <cmath>
#include <iomanip>
#include <vector>

#include "Constants.hpp"
#include "bbox_mesh.hpp"
#include "iso_triangle.hpp"

namespace bz_mesh {

bbox_mesh Tetra::compute_bounding_box() const {
    std::array<double, 4> coordinates_x;
    std::array<double, 4> coordinates_y;
    std::array<double, 4> coordinates_z;
    for (int i = 0; i < 4; ++i) {
        coordinates_x[i] = m_list_vertices[i]->get_position().x();
        coordinates_y[i] = m_list_vertices[i]->get_position().y();
        coordinates_z[i] = m_list_vertices[i]->get_position().z();
    }
    auto min_max_x = std::minmax_element(coordinates_x.begin(), coordinates_x.end());
    auto min_max_y = std::minmax_element(coordinates_y.begin(), coordinates_y.end());
    auto min_max_z = std::minmax_element(coordinates_z.begin(), coordinates_z.end());
    return bbox_mesh(*min_max_x.first, *min_max_x.second, *min_max_y.first, *min_max_y.second, *min_max_z.first, *min_max_z.second);
}

const bbox_mesh& Tetra::get_bounding_box() const { return m_bbox; }

/**
 * @brief Construct a new Tetra by passing directly the array of the four pointers to the vertices.
 *
 * @param list_vertices
 */
Tetra::Tetra(std::size_t index, const std::array<Vertex*, 4>& list_vertices)
    : m_index(index),
      m_list_vertices(list_vertices),
      m_nb_bands{m_list_vertices[0]->get_number_bands()} {
    m_list_edges[0] = compute_edge(1, 0);
    m_list_edges[1] = compute_edge(2, 0);
    m_list_edges[2] = compute_edge(3, 0);
    m_list_edges[3] = compute_edge(2, 1);
    m_list_edges[4] = compute_edge(3, 1);
    m_list_edges[5] = compute_edge(3, 2);
    m_signed_volume = compute_signed_volume();
    m_bbox          = compute_bounding_box();
    m_barycenter    = compute_barycenter();
}

vector3 Tetra::compute_barycenter() const {
    return (m_list_vertices[0]->get_position() + m_list_vertices[1]->get_position() + m_list_vertices[2]->get_position() +
            m_list_vertices[3]->get_position()) /
           4.0;
}

/**
 * @brief Compute the gradient of the energy within the tetrahedron.
 *
 * @param values_at_vertices
 * @return vector3
 */
vector3 Tetra::compute_gradient_at_tetra(const array4d& values_at_vertices) const {
    // Edges from vertex 0 to the others: a = v1 - v0, b = v2 - v0, c = v3 - v0
    const vector3 a = m_list_edges[0];  // V0V1
    const vector3 b = m_list_edges[1];  // V0V2
    const vector3 c = m_list_edges[2];  // V0V3

    // Value differences relative to vertex 0
    const double du1 = values_at_vertices[1] - values_at_vertices[0];
    const double du2 = values_at_vertices[2] - values_at_vertices[0];
    const double du3 = values_at_vertices[3] - values_at_vertices[0];

    // det(R) = a · (b × c)  (note: det = 6 * signed_volume)
    const double     det = dot(a, cross_product(b, c));
    constexpr double eps = 1e-14;
    if (std::abs(det) < eps) {
        // Degenerate tetrahedron — return zero gradient (or handle as you prefer)
        return vector3{0.0, 0.0, 0.0};
    }

    // R^{-T} = (1/det) * [ b×c, c×a, a×b ]  (columns)
    // ∇u = R^{-T} * Δu
    const vector3 grad = (cross_product(b, c) * du1 + cross_product(c, a) * du2 + cross_product(a, b) * du3) / det;

    return grad;
}

void Tetra::compute_gradient_energy_at_bands() {
    m_gradient_energy_per_band.clear();
    std::size_t m_nb_bands = m_list_vertices[0]->get_number_bands();
    m_gradient_energy_per_band.reserve(m_nb_bands);
    for (std::size_t band_index = 0; band_index < m_nb_bands; band_index++) {
        const std::array<double, 4> energies_at_vertices = get_band_energies_at_vertices(band_index);
        // const array4d              values_at_vertices   = {energies_at_vertices[0],
        //                                                    energies_at_vertices[1],
        //                                                    energies_at_vertices[2],
        //                                                    energies_at_vertices[3]};
        m_gradient_energy_per_band.push_back(compute_gradient_at_tetra(energies_at_vertices));
    }
}

/**
 * @brief Compute the minimum and maximum energies of the bands within the tetrahedron.
 *  *
 */
void Tetra::compute_min_max_energies_at_bands() {
    m_nb_bands = m_list_vertices[0]->get_number_bands();
    for (std::size_t idx_band = 0; idx_band < m_nb_bands; ++idx_band) {
        auto energies = get_band_energies_at_vertices(idx_band);
        auto minmax   = std::minmax_element(energies.begin(), energies.end());
        m_min_energy_per_band.push_back(*minmax.first);
        m_max_energy_per_band.push_back(*minmax.second);
    }
}

/**
 * @brief Compute the signed volume of the tetrahedron.
 *
 * @return double
 */
double Tetra::compute_signed_volume() const {
    // std::cout << m_list_edges[0] << std::endl;
    // std::cout << m_list_edges[1] << std::endl;
    return (1.0 / 6.0) * scalar_triple_product(m_list_edges[0], m_list_edges[1], m_list_edges[2]);
}

/**
 * @brief Return the values of the energy of the index_band valence band at the 4 vertices of the tetrahedra.
 *
 * @param index_band
 * @return std::vector<double>
 */
std::array<double, 4> Tetra::get_band_energies_at_vertices(std::size_t index_band) const {
    return {m_list_vertices[0]->get_energy_at_band(index_band),
            m_list_vertices[1]->get_energy_at_band(index_band),
            m_list_vertices[2]->get_energy_at_band(index_band),
            m_list_vertices[3]->get_energy_at_band(index_band)};
}

/**
 * @brief Compute the edge vector between two vertices of the tetrahedra.
 * The result is: vtx_1 - vtx_2.
 *
 * @param index_vtx_1
 * @param index_vtx_2
 * @return vector3
 */
vector3 Tetra::compute_edge(std::size_t index_vtx_1, std::size_t index_vtx_2) const {
    if (index_vtx_1 > 3 || index_vtx_2 > 3) {
        throw std::invalid_argument("In Tetra::compute_edge, the index of vertex must be between 0 and 3.");
    }
    return m_list_vertices[index_vtx_1]->get_position() - m_list_vertices[index_vtx_2]->get_position();
}

/**
 * @brief Compute the barycentric coordinate of a given location within the tetrahedra.
 * The returned array of size 4 contains the barycentric coordinates with respect to the vertices in the following order :
 *  0, 1, 2 and 3, respectively.
 *
 * @warning warning message: Do not use this function to check if the location lies in the tetrahedra,
 * The computation relies on the hypothesis that the location do lies in it. Use Tetra::is_location_inside instead.
 *
 * @param location
 * @return std::array<double, 4>
 */
std::array<double, 4> Tetra::compute_barycentric_coordinates(const vector3& location) const {
    const vector3 v_loc1            = location - m_list_vertices[0]->get_position();
    const double  tetra_determinant = 6.0 * m_signed_volume;
    const double  lambda_2          = scalar_triple_product(v_loc1, m_list_edges[1], m_list_edges[2]) / tetra_determinant;
    const double  lambda_3          = scalar_triple_product(v_loc1, m_list_edges[2], m_list_edges[0]) / tetra_determinant;
    const double  lambda_4          = scalar_triple_product(v_loc1, m_list_edges[0], m_list_edges[1]) / tetra_determinant;
    const double  lambda_1          = 1.0 - lambda_2 - lambda_3 - lambda_4;
    return {lambda_1, lambda_2, lambda_3, lambda_4};
}

/**
 * @brief Compute the linear interpolation of the energy of the band band_index at the point location.
 *
 * @param location
 * @param band_index
 * @return double
 */
double Tetra::interpolate_energy_at_band(const vector3& location, std::size_t band_index) const {
    const auto                  barycentric_coord    = compute_barycentric_coordinates(location);
    const std::array<double, 4> energies_at_vertices = get_band_energies_at_vertices(band_index);
    return energies_at_vertices[0] * barycentric_coord[0] + energies_at_vertices[1] * barycentric_coord[1] +
           energies_at_vertices[2] * barycentric_coord[2] + energies_at_vertices[3] * barycentric_coord[3];
}

/**
 * @brief Check if a given location lies inside the tetrahedra.
 *
 * @param location
 * @return true
 * @return false
 */
bool Tetra::is_location_inside(const vector3& location) const {
    const vector3 v_loc1            = location - m_list_vertices[0]->get_position();
    const vector3 v_loc2            = location - m_list_vertices[1]->get_position();
    const double  tetra_determinant = 6.0 * m_signed_volume;
    const double  lambda_1          = scalar_triple_product(v_loc2, m_list_edges[4], m_list_edges[3]) / tetra_determinant;
    const double  lambda_2          = scalar_triple_product(v_loc1, m_list_edges[1], m_list_edges[2]) / tetra_determinant;
    const double  lambda_3          = scalar_triple_product(v_loc1, m_list_edges[2], m_list_edges[0]) / tetra_determinant;
    const double  lambda_4          = scalar_triple_product(v_loc1, m_list_edges[0], m_list_edges[1]) / tetra_determinant;
    return (lambda_1 >= 0 && lambda_2 >= 0 && lambda_3 >= 0 && lambda_4 >= 0);
}

/**
 * @brief Compute the euclidean position from barycentric coordinates.
 *
 * @param barycentric_coordinates
 * @return vector3
 */
vector3 Tetra::compute_euclidean_coordinates(const std::array<double, 4>& barycentric_coordinates) const {
    return (
        barycentric_coordinates[0] * m_list_vertices[0]->get_position() + barycentric_coordinates[1] * m_list_vertices[1]->get_position() +
        barycentric_coordinates[2] * m_list_vertices[2]->get_position() + barycentric_coordinates[3] * m_list_vertices[3]->get_position());
}

/**
 * @brief Compute the euclidean position from barycentric coordinates, with a given vertices order,
 * that might be different from the vertices of the tetrahedra.
 *
 * @param barycentric_coordinates
 * @param indices_vertex
 * @return vector3
 */
vector3 Tetra::compute_euclidean_coordinates_with_indices(const std::array<double, 4>& barycentric_coordinates,
                                                          const std::array<int, 4>&    indices_vertex) const {
    return (barycentric_coordinates[0] * m_list_vertices[indices_vertex[0]]->get_position() +
            barycentric_coordinates[1] * m_list_vertices[indices_vertex[1]]->get_position() +
            barycentric_coordinates[2] * m_list_vertices[indices_vertex[2]]->get_position() +
            barycentric_coordinates[3] * m_list_vertices[indices_vertex[3]]->get_position());
}

/**
 * @brief Precompute a list of indices a, b, c, d such as, for the conduction band with index index_band,
 * we have Vtx_a <= Vtx_b <= Vtx_c <= Vtx_d in term of energy.
 *
 * This function is written explicitely instead of using std::sort functions, because the sorting is done
 * with the minimum number of operations for a 4 values sorting. Other solution might be tested later.
 *
 * @param index_band
 * @return std::array<int, 4>
 */
void Tetra::pre_compute_sorted_slots_per_band() {
    m_sorted_slots_per_band.clear();
    m_sorted_slots_per_band.reserve(m_nb_bands);
    for (std::size_t band_index = 0; band_index < m_nb_bands; band_index++) {
        std::array<double, 4> energies_at_vertices = get_band_energies_at_vertices(band_index);
        std::array<int, 4>    sorted_index         = {0, 1, 2, 3};
        if (energies_at_vertices[0] > energies_at_vertices[1]) {
            std::swap(energies_at_vertices[0], energies_at_vertices[1]);
            std::swap(sorted_index[0], sorted_index[1]);
        }
        if (energies_at_vertices[2] > energies_at_vertices[3]) {
            std::swap(energies_at_vertices[2], energies_at_vertices[3]);
            std::swap(sorted_index[2], sorted_index[3]);
        }
        if (energies_at_vertices[0] > energies_at_vertices[2]) {
            std::swap(energies_at_vertices[0], energies_at_vertices[2]);
            std::swap(sorted_index[0], sorted_index[2]);
        }
        if (energies_at_vertices[1] > energies_at_vertices[3]) {
            std::swap(energies_at_vertices[1], energies_at_vertices[3]);
            std::swap(sorted_index[1], sorted_index[3]);
        }
        if (energies_at_vertices[1] > energies_at_vertices[2]) {
            std::swap(energies_at_vertices[1], energies_at_vertices[2]);
            std::swap(sorted_index[1], sorted_index[2]);
        }
        m_sorted_slots_per_band.push_back(sorted_index);
    }
}

/**
 * @brief Compute the iso-energy surface within the tetrahedra for a given energy of a given band.
 * The surface is returned as a list of points (3 when the surface is a triangle, 4 when it is a quadrangle).
 *
 * The case of energy being smaller than the minimum energy of the tetrahedra is not taken into account.
 * Same thing for the case of energy being greater than the maximum energy of the tetrahedra.
 * Those two cases are handle by the caller function. This is done to avoid computing the sorted index which is computationallly intensive.
 * The minimum and maximum energies are stored in the member variables
 * m_min_energy_at_vertices and m_max_energy_at_vertices at the construction of the tetrahedra.
 *
 * This is very important because those 2 trivial cases represent usually more than 95% of the cases.
 *
 *
 * @param iso_energy
 * @param band_index
 * @return std::vector<vector3>
 */
std::vector<vector3> Tetra::compute_band_iso_energy_surface(double iso_energy, std::size_t band_index) const {
    std::array<double, 4>     energies_at_vertices = get_band_energies_at_vertices(band_index);
    const std::array<int, 4>& indices_sort         = get_index_vertices_with_sorted_energy_at_band(band_index);
    double                    e_0                  = energies_at_vertices[indices_sort[0]];
    double                    e_1                  = energies_at_vertices[indices_sort[1]];
    double                    e_2                  = energies_at_vertices[indices_sort[2]];
    double                    e_3                  = energies_at_vertices[indices_sort[3]];

    bool check_order = (e_0 <= e_1 && e_1 <= e_2 && e_2 <= e_3);
    if (!check_order) {
        std::cerr << "Error: the order of the energies is not correct" << std::endl;
        throw std::runtime_error("Error: the order of the energies is not correct");
    }

    if (iso_energy < e_1 && iso_energy >= e_0) {
        double  lA_U = (iso_energy - e_0) / (e_1 - e_0);
        vector3 U    = compute_euclidean_coordinates_with_indices({1.0 - lA_U, lA_U, 0.0, 0.0}, indices_sort);
        double  lA_V = (iso_energy - e_0) / (e_2 - e_0);
        vector3 V    = compute_euclidean_coordinates_with_indices({1.0 - lA_V, 0.0, lA_V, 0.0}, indices_sort);
        double  lA_W = (iso_energy - e_0) / (e_3 - e_0);
        vector3 W    = compute_euclidean_coordinates_with_indices({1.0 - lA_W, 0.0, 0.0, lA_W}, indices_sort);
        return {U, V, W};
    }
    if (iso_energy < e_2 && iso_energy >= e_1) {
        double  lA_U = (iso_energy - e_0) / (e_2 - e_0);
        vector3 U    = compute_euclidean_coordinates_with_indices({1.0 - lA_U, 0.0, lA_U, 0.0}, indices_sort);
        double  lA_V = (iso_energy - e_0) / (e_3 - e_0);
        vector3 V    = compute_euclidean_coordinates_with_indices({1.0 - lA_V, 0.0, 0.0, lA_V}, indices_sort);
        double  lA_W = (e_2 - iso_energy) / (e_2 - e_1);
        vector3 W    = compute_euclidean_coordinates_with_indices({0.0, lA_W, 1.0 - lA_W, 0.0}, indices_sort);
        double  lA_X = (iso_energy - e_1) / (e_3 - e_1);
        vector3 X    = compute_euclidean_coordinates_with_indices({0.0, 1.0 - lA_X, 0.0, lA_X}, indices_sort);
        return {U, V, W, X};
    }
    if (iso_energy >= e_2) {
        double  lC_U = (e_3 - iso_energy) / (e_3 - e_2);
        vector3 U    = compute_euclidean_coordinates_with_indices({0.0, 0.0, lC_U, 1.0 - lC_U}, indices_sort);
        double  lB_V = (e_3 - iso_energy) / (e_3 - e_1);
        vector3 V    = compute_euclidean_coordinates_with_indices({0.0, lB_V, 0.0, 1.0 - lB_V}, indices_sort);
        double  lA_W = (e_3 - iso_energy) / (e_3 - e_0);
        vector3 W    = compute_euclidean_coordinates_with_indices({lA_W, 0.0, 0.0, 1.0 - lA_W}, indices_sort);
        return {U, V, W};
    } else {
        std::cout << "DATA OUT : " << iso_energy << " " << e_0 << " " << e_1 << " " << e_2 << " " << e_3 << std::endl;
        throw std::runtime_error("ISO SURFACE CASE UNKNOWN IN DOS COMPUTATION... ABORT.");
    }
    return {};
}

// Area of triangle (A,B,C) in 3D: 0.5 * || (B-A) × (C-A) ||
[[nodiscard]] inline double triangle_area(const vector3& A, const vector3& B, const vector3& C) noexcept {
    const vector3 AB = B - A;
    const vector3 AC = C - A;
    return 0.5 * cross_product(AB, AC).norm();
}

// Returns vertices ordered cyclically in the plane they lie on
inline std::vector<vector3> order_cyclic(const std::vector<vector3>& pts) {
    if (pts.size() < 3) return pts;

    // Compute centroid
    vector3 centroid = std::accumulate(pts.begin(), pts.end(), vector3{0, 0, 0});
    centroid /= static_cast<double>(pts.size());

    // Compute polygon normal from first 3 distinct points
    vector3 n   = cross_product(pts[1] - pts[0], pts[2] - pts[0]);
    double  len = n.norm();
    if (len > 0.0) n /= len;  // normalize

    // Choose an in-plane axis u
    vector3 u    = pts[0] - centroid;
    double  ulen = u.norm();
    if (ulen > 0.0)
        u /= ulen;
    else
        u = vector3{1, 0, 0};  // fallback

    // v = n × u (second in-plane axis)
    vector3 v = cross_product(n, u);

    struct VertexAngle {
        vector3 p;
        double  angle;
    };
    std::vector<VertexAngle> with_angles;
    with_angles.reserve(pts.size());

    for (auto& p : pts) {
        vector3 d     = p - centroid;
        double  x     = dot(d, u);
        double  y     = dot(d, v);
        double  angle = std::atan2(y, x);  // -pi .. pi
        with_angles.push_back({p, angle});
    }

    std::sort(with_angles.begin(), with_angles.end(), [](auto& a, auto& b) { return a.angle < b.angle; });

    std::vector<vector3> ordered;
    ordered.reserve(pts.size());
    for (auto& wa : with_angles)
        ordered.push_back(wa.p);

    return ordered;
}

/**
 * @brief Compute the surface of the tetrahedra for a given energy of a given band.
 * The iso-surface is computed by the function compute_band_iso_energy_surface, and then
 * the area of the surface is computed.
 *
 * If the surface is a triangle, the area is computed by the class IsoTriangle class function "get_signed_area".
 * If the surface is a quadrangle, the area is computed by splitting the quadrangle into 2 triangles and then computing the area of each
 * triangle.
 *
 * A more direct way to compute the area in both cases should be tested for performances improvement.
 *  *
 * @param energy
 * @param band_index
 * @return double
 */
double Tetra::compute_tetra_iso_surface_energy_band(double energy, std::size_t band_index) const {
    std::vector<vector3> vertices_iso_surface = compute_band_iso_energy_surface(energy, band_index);
    if (vertices_iso_surface.size() == 3) {
        return triangle_area(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2]);
    } else if (vertices_iso_surface.size() == 4) {
        vertices_iso_surface = order_cyclic(vertices_iso_surface);
        return triangle_area(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[3]) +
               triangle_area(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2]);
    } else {
        return 0.0;
    }
}

double Tetra::compute_tetra_iso_surface_energy_band2(double energy, std::size_t band_index) const {
    std::vector<vector3> vertices_iso_surface = compute_band_iso_energy_surface(energy, band_index);
    if (vertices_iso_surface.empty()) {
        return 0.0;
    } else if (vertices_iso_surface.size() == 3) {
        IsoTriangle triangle(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], energy);
        return fabs(triangle.get_signed_surface());
    } else {
        vertices_iso_surface = order_cyclic(vertices_iso_surface);
        IsoTriangle triangle1(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[3], energy);
        IsoTriangle triangle2(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], energy);
        return fabs(triangle1.get_signed_surface()) + fabs(triangle2.get_signed_surface());
    }
}

inline double polygon_area(const std::vector<vector3>& pts) {
    auto pts_ordered = order_cyclic(pts);
    if (pts_ordered.size() < 3) return 0.0;

    vector3 sum{0, 0, 0};
    for (size_t i = 0; i < pts_ordered.size(); ++i) {
        const vector3& p0 = pts_ordered[i];
        const vector3& p1 = pts_ordered[(i + 1) % pts_ordered.size()];
        sum += cross_product(p0, p1);
    }
    return 0.5 * sum.norm();
}

/**
 * @brief Main function to compute the DOS of the energy energy of the band with index band_index within the tetrahedra.
 *
 * One could try to store the value eps_12, eps_13, eps_14 for each band at the construction step, to avoid computing them each time the
 * function is called.  Returns DOS contribution in states / (eV · m^3)
 * Assumes: k in m^-1; A in m^-2; |∇_k E| in eV·m
 *
 * @param energy
 * @param band_index
 * @return double
 */
double Tetra::compute_tetra_dos_energy_band(double energy_eV, std::size_t band_index) const {
    if (energy_eV < m_min_energy_per_band[band_index] || energy_eV > m_max_energy_per_band[band_index]) {
        return 0.0;
    }

    const double A = polygon_area(compute_band_iso_energy_surface(energy_eV, band_index));  // m^-2

    const double grad = m_gradient_energy_per_band[band_index].norm();  // eV·m
    if (A <= 0.0 || grad <= 0.0) return 0.0;

    constexpr double pref = 1.0 / (8.0 * M_PI * M_PI * M_PI);  // 1/(2π)^3 = 1/(8π^3)

    return pref * (A / grad);
}
void Tetra::precompute_dos_on_energy_grid_per_band(double energy_step, double energy_threshold) {
    m_nb_bands = m_list_vertices[0]->get_number_bands();
    m_dos_per_band.assign(m_nb_bands, UniformDos{});

    for (std::size_t b = 0; b < m_nb_bands; ++b) {
        auto&        T    = m_dos_per_band[b];
        const double Emin = m_min_energy_per_band[b];
        const double Emax = m_max_energy_per_band[b];

        // keep index alignment; mark invalid instead of skipping
        if (!(Emax > Emin) || Emin > energy_threshold) {
            T.valid = false;
            continue;
        }

        // integer number of steps; enforce a small minimum
        std::size_t nb_steps = static_cast<std::size_t>(std::ceil((Emax - Emin) / energy_step));
        if (nb_steps < 5) {
            nb_steps = 5;
        }
        const double dx = (Emax - Emin) / static_cast<double>(nb_steps);

        T.valid  = true;
        T.E0     = Emin;
        T.Emax   = Emax;
        T.inv_dx = 1.0 / dx;
        T.N      = static_cast<uint32_t>(nb_steps + 1);

        T.D.resize(T.N);
        T.D[0]       = 0.0;
        T.D[T.N - 1] = 0.0;

        for (std::size_t idx_energy = 1; idx_energy < nb_steps; ++idx_energy) {
            const double e = Emin + idx_energy * dx;
            T.D[idx_energy] = static_cast<float>(compute_tetra_dos_energy_band(e, b));
            // DEBUG
            // std::cout << e << "," << T.D[idx_energy] / 1e23 << std::endl;
        }
        // std::cout << std::endl;
    }
}

/**
 * @brief Interpolate the density of states (DOS) at a given energy for a specific band.
 * The DOS is precomputed on a uniform energy grid during the tetrahedron initialization.
 * If the energy is outside the precomputed range, the function returns 0.0.
 * The interpolation is linear between the two nearest grid points.
 *
 * @param energy
 * @param band_index
 * @return double
 */
double Tetra::interpolate_dos_at_energy_per_band(double energy, std::size_t band_index) const noexcept {
    return (band_index < m_dos_per_band.size()) ? m_dos_per_band[band_index].sample_or_zero(energy) : 0.0;
}

/**
 * @brief Draw a random point on the iso-energy surface within the tetrahedra.
 *
 * @param iso_energy
 * @param band_index
 * @param rng
 * @return vector3
 */
vector3 Tetra::draw_random_uniform_point_at_energy(double iso_energy, std::size_t band_index, std::mt19937& rng) const {
    std::cout << "Draw random point at energy: " << iso_energy << " in band: " << band_index << std::endl;
    if (iso_energy < m_min_energy_per_band[band_index] || iso_energy > m_max_energy_per_band[band_index]) {
        std::cout << "Band index: " << band_index << std::endl;
        std::cout << "Energie bound: " << m_min_energy_per_band[band_index] << " " << m_max_energy_per_band[band_index] << std::endl;
        std::cout << "iso_energy: " << iso_energy << std::endl;
        throw std::invalid_argument("Energy is not in the band for this tetrahedron. Cannot draw a random point at this energy.");
    }
    const std::vector<vector3> vertices_iso_surface = compute_band_iso_energy_surface(iso_energy, band_index);
    if (vertices_iso_surface.empty()) {
        throw std::invalid_argument("Energy is not in the band for this tetrahedron. Cannot draw a random point at this energy.");
    } else if (vertices_iso_surface.size() == 3) {
        IsoTriangle triangle(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], iso_energy);
        auto        point = triangle.draw_random_uniform_point_in_triangle(rng);
        return point;
    } else {
        // If the iso-energy shape is a quadrilateral, the point is drawn uniformly in the quadrilateral.
        // To do so, we randomly select on of the triangle, with a probability following the area of the triangle.
        // Then we draw a point in the selected triangle, and return the point.
        IsoTriangle  triangle1(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[3], iso_energy);
        IsoTriangle  triangle2(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], iso_energy);
        const double surface_triangle1 = triangle1.get_signed_surface();
        const double surface_triangle2 = triangle2.get_signed_surface();
        std::uniform_real_distribution<double> dist(0.0, surface_triangle1 + surface_triangle2);
        return dist(rng) < surface_triangle1 ? triangle1.draw_random_uniform_point_in_triangle(rng)
                                             : triangle2.draw_random_uniform_point_in_triangle(rng);
    }
}

bool Tetra::is_energy_inside_band(double energy, std::size_t index_band) const {
    return (energy >= m_min_energy_per_band[index_band] && energy <= m_max_energy_per_band[index_band]);
}

bool Tetra::does_intersect_band_energy_range(double e_min, double e_max, std::size_t index_band) const {
    return !(e_max < m_min_energy_per_band[index_band] || e_min > m_max_energy_per_band[index_band]);
}

std::array<double, 8> Tetra::get_tetra_electron_phonon_rates(int band_index) const {
    std::array<double, 8> mean_rates;
    std::fill(mean_rates.begin(), mean_rates.end(), 0.0);
    for (std::size_t i = 0; i < 4; i++) {
        if (band_index >= static_cast<int>(m_list_vertices[i]->get_number_bands())) {
            throw std::invalid_argument("In Tetra::get_tetra_electron_phonon_rates, the band index is out of range.");
        }
        const std::array<double, 8>& rates = m_list_vertices[i]->get_electron_phonon_rates(band_index);
        std::transform(mean_rates.begin(), mean_rates.end(), rates.begin(), mean_rates.begin(), std::plus<double>());
    }
    std::transform(mean_rates.begin(), mean_rates.end(), mean_rates.begin(), [](double val) { return val / 4.0; });
    return mean_rates;
}

}  // namespace bz_mesh/**
 * @file bz_mesh.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <filesystem>
#include <regex>
#include <sstream>
#include <unordered_map>

#include "Material.h"
#include "iso_triangle.hpp"
#include "mesh_tetra.hpp"
#include "mesh_vertex.hpp"
#include "octree_bz.hpp"
#include "vector.hpp"

namespace bz_mesh {

using EigenIntSparseMatrix = Eigen::SparseMatrix<int, Eigen::RowMajor>;
using TripletInt           = Eigen::Triplet<int>;

using MapStringToDoubles = std::map<std::string, std::vector<double>>;
using MapStringToVectors = std::map<std::string, std::vector<vector3>>;

enum class BandType { valence, conduction };

class MeshBZ {
 protected:
    /**
     * @brief The material of the Brillouin zone.
     *
     */
    EmpiricalPseudopotential::Material m_material;

    /**
     * @brief G vector on which the BZ is centered.
     *
     */
    vector3 m_center = {0.0, 0.0, 0.0};

    /**
     * @brief The tags of the nodes in the mesh.
     * These tags are used to identify the vertices in the GMSH files when load is done.
     */
    std::vector<std::size_t> m_node_tags;

    /**
     * @brief List of the vertices of the BZ mesh. Each vertices represent a vector k within the Brillouin Zone.
     *
     */
    std::vector<Vertex> m_list_vertices;

    /**
     * @brief List of the elements (tetrahedra) of the mesh.
     *
     */
    std::vector<Tetra> m_list_tetrahedra;

    /**
     * @brief Stores for each vertex index the list of tetrahedra indices that contains this vertex.
     * For example, m_vertex_to_tetrahedra[5] = {0, 2, 3} means that the vertex with index 5 is part of the tetrahedra with indices 0, 2
     * and 3.
     *
     * This is used to speed up the search of the tetrahedra containing a given vertex.
     */
    std::vector<std::vector<std::size_t>> m_vertex_to_tetrahedra;

    /**
     * @brief Factor applied to each tetra/vertex when we use only a part of the 1st BZ.
     * For example m_reduced_facotr = 48 when we use the irreducible wedge.
     *
     */
    double m_reduce_bz_factor = 1.0;

    /**
     * @brief Octree used to search for the tetrahedra that are overlapping with a given point.
     *
     */
    std::unique_ptr<Octree_mesh> m_search_tree;

    /**
     * @brief The indexes of the valence bands within the Vertex list of energies.
     * For example, if indices_valence_bands = [0, 1, 2] it means that
     * the m_band_energies[0], m_band_energies[1], m_band_energies[2] correspond to valence bands.
     *
     */
    std::vector<int> m_indices_valence_bands{};

    /**
     * @brief The indexes of the conduction bands within the Vertex list of energies.
     * For example, if indices_conduction_bands = [3, 4, 5] it means that
     * the values m_band_energies[3], m_band_energies[4], m_band_energies[5] correspond to conduction bands.
     *
     */
    std::vector<int> m_indices_conduction_bands{};

    /**
     * @brief The value m_min_band[i] is the minimum energy of the band with index i.
     *
     */
    std::vector<double> m_min_band{};

    /**
     * @brief The value m_max_band[i] is the maximum energy of the band with index i.
     *
     */
    std::vector<double> m_max_band{};

    /**
     * @brief Total volume of the BZ mesh in m^3.
     *
     */
    double m_total_volume = 0.0;

    /**
     * @brief Spin degeneracy factor (2 when spin-orbit coupling is not considered).
     *
     */
    double m_spin_degeneracy = 2.0;

    /**
     * @brief Possible G vectors to fold back k vectors within the first BZ.
     *
     */
    std::vector<vector3> m_Gshifts;

    // --- O(1) WS-BZ folding (internal state) ---
    /**
     * @brief Reciprocal primitive basis (columns) in SI [1/m] and its inverse.
     */
    Eigen::Matrix3d m_recip_B  = Eigen::Matrix3d::Identity();
    Eigen::Matrix3d m_recip_Bi = Eigen::Matrix3d::Identity();

    /**
     * @brief Scale from SI k (1/m) to the reduced frame used by plane tests.
     * Keep this consistent with is_inside_mesh_geometry().
     */
    double m_si2red = 1.0;

    /**
     * @brief Half-width in the reduced frame (e.g. 0.5 for [-0.5,0.5]).
     */
    double m_bz_halfwidth = 0.5;

 public:
    MeshBZ() = default;
    MeshBZ(const EmpiricalPseudopotential::Material& material) : m_material(material) {};
    MeshBZ(const MeshBZ&) = default;

    void export_k_points_to_file(const std::string& filename) const;
    void export_to_vtk(const std::string&        filename,
                       const MapStringToDoubles& point_scalars = {},
                       const MapStringToVectors& point_vectors = {},
                       const MapStringToDoubles& cell_scalars  = {},
                       const MapStringToVectors& cell_vectors  = {}) const;
    void export_energies_and_gradients_to_vtk(const std::string& filename) const;

    vector3 get_vertex_position(std::size_t idx_vtx) const { return m_list_vertices[idx_vtx].get_position(); }

    vector3 get_center() const { return m_center; }
    void    shift_bz_center(const vector3& shift);

    double        get_reduce_bz_factor() const { return m_reduce_bz_factor; }
    void          set_reduce_bz_factor(double factor) { m_reduce_bz_factor = factor; }
    inline double si_to_reduced_scale() const;

    bbox_mesh           compute_bounding_box() const;
    void                build_search_tree();
    std::vector<Tetra*> get_list_p_tetra() {
        std::vector<Tetra*> tetra_pointers;
        tetra_pointers.reserve(m_list_tetrahedra.size());
        std::transform(m_list_tetrahedra.begin(), m_list_tetrahedra.end(), std::back_inserter(tetra_pointers), [](Tetra& tetra) {
            return &tetra;
        });
        return tetra_pointers;
    }
    Tetra* find_tetra_at_location(const vector3& location) const;

    void read_mesh_geometry_from_msh_file(const std::string& filename, bool normalize_by_fourier_factor = true);
    void read_mesh_bands_from_msh_file(const std::string& filename, int nb_bands_to_load = -1);
    void read_mesh_bands_from_multi_band_files(const std::string& dir_bands, int nb_bands_to_load = 100);
    void add_new_band_energies_to_vertices(const std::vector<double>& energies_at_vertices);
    void keep_only_bands(const int nb_valence_bands, const int nb_conduction_bands);
    void compute_min_max_energies_at_tetras();
    void compute_energy_gradient_at_tetras();
    void auto_shift_conduction_band_energies();
    void auto_set_positive_valence_band_energies();
    void set_bands_in_right_order();
    void recompute_min_max_energies();
    void precompute_dos_tetra(double energy_step = 0.01, double energy_threshold = 100.0);

    void set_energy_gradient_at_vertices_by_averaging_tetras();

    std::size_t      get_number_vertices() const { return m_list_vertices.size(); }
    std::size_t      get_number_elements() const { return m_list_tetrahedra.size(); }
    double           get_volume() const { return m_total_volume; }
    std::vector<int> get_indices_valence_bands() const { return m_indices_valence_bands; }
    std::vector<int> get_indices_conduction_bands() const { return m_indices_conduction_bands; }
    int              get_nb_bands() const { return m_indices_valence_bands.size() + m_indices_conduction_bands.size(); }

    vector3 interpolate_energy_gradient_at_location(const vector3& location, const std::size_t& idx_band) const;

    void                     precompute_G_shifts();
    bool                     is_inside_mesh_geometry(const vector3& k) const;
    vector3                  retrieve_k_inside_mesh_geometry(const vector3& k) const;
    void                     init_reciprocal_basis(const Eigen::Vector3d& b1_SI,
                                                   const Eigen::Vector3d& b2_SI,
                                                   const Eigen::Vector3d& b3_SI,
                                                   double                 halfwidth_reduced,
                                                   double                 si_to_reduced);
    vector3                  fold_ws_bcc(const vector3& k_SI) const noexcept;
    bool                     inside_ws_bcc(const vector3& k_SI) const noexcept;
    bool                     is_irreducible_wedge(const vector3& k_SI) const noexcept;
    std::size_t              get_index_irreducible_wedge(const vector3& k_SI) const noexcept;
    std::vector<std::size_t> get_all_equivalent_indices_in_bz(const vector3& k_SI) const noexcept;

    vector3                         get_k_at_index(std::size_t index) const { return m_list_vertices[index].get_position(); }
    std::size_t                     get_nearest_k_index(const vector3& k) const;
    const std::vector<std::size_t>& get_tetrahedra_of_vertex(std::size_t vertex_index) const {
        return m_vertex_to_tetrahedra[vertex_index];
    }

    std::size_t               get_number_bands() const { return m_min_band.size(); }
    std::pair<double, double> get_min_max_energy_at_band(const int& band_index) const {
        return std::make_pair(m_min_band[band_index], m_max_band[band_index]);
    }

    const std::vector<Vertex>& get_list_vertices() const { return m_list_vertices; }
    const std::vector<Tetra>&  get_list_elements() const { return m_list_tetrahedra; }

    double      compute_mesh_volume() const;
    double      compute_iso_surface(double iso_energy, int band_index) const;
    double      compute_dos_at_energy_and_band(double iso_energy, int band_index, bool use_interp = false) const;
    std::size_t draw_random_tetrahedron_index_with_dos_probability(double        energy,
                                                                   std::size_t   idx_band,
                                                                   std::mt19937& random_generator) const;

    vector3 draw_random_k_point_at_energy(double energy, std::size_t idx_band, std::mt19937& random_generator) const;

    std::vector<std::vector<double>> compute_dos_band_at_band(int         band_index,
                                                              double      min_energy,
                                                              double      max_energy,
                                                              int         num_threads,
                                                              std::size_t nb_points,
                                                              bool        use_interp = false) const;

    std::vector<std::vector<double>> compute_dos_band_at_band_auto(int         band_index,
                                                                   std::size_t nb_points,
                                                                   int         num_threads,
                                                                   bool        use_interp = false) const;
};

}  // namespace bz_mesh/**
 * @file Octree_mesh.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-25
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <memory>
#include <vector>

#include "mesh_tetra.hpp"
#include "vector.hpp"
#include "bbox_mesh.hpp"

namespace bz_mesh {



class Octree_mesh {
 protected:
    /**
     * @brief Maximum number of elements in a leaf node.
     * If the number of elements in a node is greater than this value, the node is split into 8 children.
     */
    static constexpr int max_number_of_elements_per_node = 32;

    /**
     * @brief Minimum size of a node.
     * If the size of a node is smaller than this value, the node is not split anymore.
     */
    static constexpr double min_size_of_a_node = 1e8;

    /**
     * @brief Bounding box of the node.
     */
    bbox_mesh m_node_box;

    /**
     * @brief A leaf node is a node that has no children.
     *
     */
    bool m_is_leaf = false;

    /**
     * @brief List of pointers to elements overlapping in the node.
     */
    std::vector<Tetra *> m_list_tetras;

    /**
     * @brief List of children of the node.
     */
    std::vector<std::unique_ptr<Octree_mesh>> m_list_sub_nodes;

    std::vector<Tetra *> find_overlapping_tetras(const std::vector<Tetra *> &list_p_tetras, const bbox_mesh &bounding_box);
    bool                    is_inside(const vector3 &location) const { return m_node_box.is_inside(location); }

 public:
    Octree_mesh(){};
    Octree_mesh(const std::vector<Tetra *> &list_tetras, const bbox_mesh &bounding_box);

    Tetra *find_tetra_at_location(const vector3 &location) const;
};

}  // namespace bz_mesh
/**
 * @file mesh_vertex.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "vector.hpp"

namespace bz_mesh {

class Vertex {
 private:
    /**
     * @brief Index of the vertex within the mesh.
     *
     */
    std::size_t m_index;

    /**
     * @brief Position of the k-vector.
     *
     */
    vector3 m_position;

    /**
     * @brief The energy of the band with index b_idx at this vertex
     * is stored as m_band_energies[b_idx].
     * For example, m_band_energies[3] is the energy of the band 3 at the k-point with position m_position.
     *
     */
    std::vector<double> m_band_energies;

    /**
     * @brief The energy gradient at each band at this vertex.
     * The energy gradient is stored as a vector3 for each band.
     * For example, m_energy_gradient_at_bands[3] is the energy gradient of the band 3 at the k-point with position m_position.
     *
     */
    std::vector<vector3> m_energy_gradient_at_bands = {};

    /**
     * @brief Electron-phonon rates for each band.
     * The rates are stored as an array of 8 values:
     * [ALO, ALA, ATO, ATA, ELO, ELA, ETO, ETA] (ALO: absorption longitudinal optical, ALA: absorption longitudinal acoustic, ...)
     *
     */
    std::vector<std::array<double, 8>> m_electron_phonon_rates = {};

 public:
    /**
     * @brief Default constructor of a new Vertex object.
     *
     */
    Vertex() : m_index{0}, m_position{} {}

    /**
     * @brief Construct a new Vertex object with a given index.
     *
     * @param index
     */
    explicit Vertex(std::size_t index) : m_index(index), m_position{} {}

    /**
     * @brief Construct a new Vertex object with a given index and position.
     *
     * @param index
     * @param postion
     */
    Vertex(std::size_t index, const vector3& position) : m_index(index), m_position{position} {}

    /**
     * @brief Construct a new Vertex object with a given index and position (x, y, z).
     *
     * @param index
     * @param x
     * @param y
     * @param z
     */
    Vertex(std::size_t index, double x, double y, double z) : m_index(index), m_position{x, y, z} {}

    /**
     * @brief Get the index of the vertex.
     *
     * @return std::size_t
     */
    std::size_t get_index() const { return m_index; }

    /**
     * @brief Get the position of the vertex.
     *
     * @return vector3
     */
    const vector3& get_position() const { return m_position; }

    /**
     * @brief Set the position of the vertex.
     *
     * @param position
     */
    void set_position(const vector3& position) { m_position = position; }

    /**
     * @brief Shift the position of the vertex by a given vector.
     *
     * @param shift
     */
    void shift_position(const vector3& shift) { m_position += shift; }

    /**
     * @brief Add an energy at the end of the list of energy. (One energy per band).
     *
     * @param energy
     */
    void add_band_energy_value(double energy) { m_band_energies.push_back(energy); }

    void remove_band_energy(std::size_t band_index) {
        if (band_index >= m_band_energies.size()) {
            throw std::invalid_argument("The energy of band " + std::to_string(band_index) +
                                        " cannot be removed because it does not exists.");
        }
        m_band_energies.erase(m_band_energies.begin() + band_index);
    }

    /**
     * @brief Set the band energy at a given band index.
     *
     * @param index_band
     * @param new_energy
     */
    void set_band_energy(std::size_t index_band, double new_energy) {
        if (index_band >= m_band_energies.size()) {
            throw std::invalid_argument("The energy of band " + std::to_string(index_band) +
                                        " cannot be modify because it does not exist.");
        }
        m_band_energies[index_band] = new_energy;
    }

    /**
     * @brief Swap the energy of two bands.
     *
     * @param old_index
     * @param new_index
     */
    void swap_bands(std::size_t old_index, std::size_t new_index) {
        if (old_index >= m_band_energies.size() || new_index >= m_band_energies.size()) {
            throw std::invalid_argument("The energy of band " + std::to_string(old_index) + " or " + std::to_string(new_index) +
                                        " cannot be swapped because it does not exists.");
        }
        std::swap(m_band_energies[old_index], m_band_energies[new_index]);
    }

    /**
     * @brief Get the number of band energies stored in the Vertex object.
     *
     * @return std::size_t
     */
    std::size_t get_number_bands() const { return m_band_energies.size(); }

    /**
     * @brief Get the energy at band index.
     *
     * @param band_index
     * @return double
     */
    double get_energy_at_band(std::size_t band_index) const { return m_band_energies[band_index]; }

    /**
     * @brief Get the list of band energies.
     *
     * @return const std::vector<double>&
     */
    const std::vector<double>& get_band_energies() const { return m_band_energies; }

    const std::vector<vector3>& get_energy_gradient_at_bands() const { return m_energy_gradient_at_bands; }

    const vector3& get_energy_gradient_at_band(std::size_t band_index) const { return m_energy_gradient_at_bands[band_index]; }
    void           set_energy_gradient_at_bands(const std::vector<vector3>& gradients) { m_energy_gradient_at_bands = gradients; }
    void           set_energy_gradient_at_band(std::size_t band_index, const vector3& gradient) {
        if (band_index >= m_energy_gradient_at_bands.size()) {
            throw std::invalid_argument("The energy gradient of band " + std::to_string(band_index) +
                                        " cannot be modify because it does not exist.");
        }
        m_energy_gradient_at_bands[band_index] = gradient;
    }
    void resize_energy_gradient_at_bands(std::size_t new_size) { m_energy_gradient_at_bands.resize(new_size); }
    void push_back_energy_gradient_at_band(const vector3& gradient) { m_energy_gradient_at_bands.push_back(gradient); }

    /**
     * @brief Add the electron-phonon rates for a given band.
     *
     * @param rates
     */
    void add_electron_phonon_rates(const std::array<double, 8>& rates) { m_electron_phonon_rates.push_back(rates); }

    /**
     * @brief Get the electron-phonon rates for a given band.
     *
     * @param band_index
     * @return const std::array<double, 8>&
     */
    const std::array<double, 8>& get_electron_phonon_rates(std::size_t band_index) const { return m_electron_phonon_rates[band_index]; }

    const std::vector<std::array<double, 8>>& get_electron_phonon_rates_all_bands() const { return m_electron_phonon_rates; }
};

}  // namespace bz_mesh/**
 * @file vector.hpp
 * @author Rémi Helleboid (remi@helleboid.net)
 * @brief Vector class header.
 * @version 0.1
 * @date 2021-07-10
 *
 * @copyright Copyright (c) 2021
 *
 */

#pragma once

#include <algorithm>
#include <cmath>
#include <iostream>
#include <optional>
#include <vector>

namespace bz_mesh {

enum class permutaion_type { XY, XZ, YZ, XYZ, YZX, ZXY };

class alignas(32) vector3 {
 private:
    double m_x;
    double m_y;
    double m_z;

 public:
    vector3() : m_x(0.0), m_y(0.0), m_z(0.0) {}
    vector3(double x, double y) : m_x(x), m_y(y), m_z(0.0) {}
    vector3(double x, double y, double z) : m_x(x), m_y(y), m_z(z) {}
    vector3(const vector3 &)            = default;
    vector3 &operator=(const vector3 &) = default;
    vector3(vector3 &&)                 = default;
    vector3 &operator=(vector3 &&)      = default;
    ~vector3()                          = default;

    double x() const { return m_x; }
    double y() const { return m_y; }
    double z() const { return m_z; }

    void set_x(double x) { m_x = x; }
    void set_y(double y) { m_y = y; }
    void set_z(double z) { m_z = z; }
    void set_coordinates(double x, double y, double z) {
        m_x = x;
        m_y = y;
        m_z = z;
    }

    vector3 to_2d() const { return vector3{m_x, m_y, 0.0}; }

    double norm() const { return std::sqrt(m_x * m_x + m_y * m_y + m_z * m_z); }
    double norm_squared() const { return (m_x * m_x + m_y * m_y + m_z * m_z); }

    void re_normalize() {
        const double v_norm = norm();
        if (v_norm == 0.0) return;  // avoid division by zero
        m_x /= v_norm;
        m_y /= v_norm;
        m_z /= v_norm;
    }

    /**
     * @brief Apply a reflection on the vector.
     * (x_reflection, y_reflection, z_reflection) should typically be in {-1, 1}.
     */
    void apply_reflection(int x_reflection, int y_reflection, int z_reflection) {
        m_x = x_reflection * m_x;
        m_y = y_reflection * m_y;
        m_z = z_reflection * m_z;
    }

    /**
     * @brief Apply a permutation on the vector (6 possibilities).
     * XY, XZ, YZ are simple swaps; XYZ is identity; YZX and ZXY are 3-cycles.
     */
    void apply_permutation(permutaion_type permutation) {
        switch (permutation) {
            case permutaion_type::XY:
                std::swap(m_x, m_y);
                break;
            case permutaion_type::XZ:
                std::swap(m_x, m_z);
                break;
            case permutaion_type::YZ:
                std::swap(m_y, m_z);
                break;
            case permutaion_type::XYZ:
                // identity
                break;
            case permutaion_type::YZX: {
                // (x, y, z) -> (y, z, x)
                const double ox = m_x, oy = m_y, oz = m_z;
                m_x = oy;
                m_y = oz;
                m_z = ox;
                break;
            }
            case permutaion_type::ZXY: {
                // (x, y, z) -> (z, x, y)
                const double ox = m_x, oy = m_y, oz = m_z;
                m_x = oz;
                m_y = ox;
                m_z = oy;
                break;
            }
        }
    }

    double dot(const vector3 &rhs) const { return (m_x * rhs.m_x + m_y * rhs.m_y + m_z * rhs.m_z); }

    friend double dot(const vector3 &lhs, const vector3 &rhs) { return (lhs.m_x * rhs.m_x + lhs.m_y * rhs.m_y + lhs.m_z * rhs.m_z); }

    friend vector3 middle(const vector3 &lhs, const vector3 &rhs) {
        constexpr double one_half = 1.0 / 2.0;
        return vector3{one_half * (rhs.m_x + lhs.m_x), one_half * (rhs.m_y + lhs.m_y), one_half * (rhs.m_z + lhs.m_z)};
    }

    friend vector3 point_pair_to_vector(const vector3 &lhs, const vector3 &rhs) {
        return vector3{rhs.m_x - lhs.m_x, rhs.m_y - lhs.m_y, rhs.m_z - lhs.m_z};
    }

    friend double distance(const vector3 &lhs, const vector3 &rhs) { return point_pair_to_vector(lhs, rhs).norm(); }

    friend inline vector3 cross_product(const vector3 &lhs, const vector3 &rhs) {
        return vector3(lhs.m_y * rhs.m_z - lhs.m_z * rhs.m_y, lhs.m_z * rhs.m_x - lhs.m_x * rhs.m_z, lhs.m_x * rhs.m_y - lhs.m_y * rhs.m_x);
    }

    friend inline double scalar_triple_product(const vector3 &v1, const vector3 &v2, const vector3 &v3) {
        return v1.dot(cross_product(v2, v3));
    }

    friend inline double compute_cos_angle(const vector3 &V1, const vector3 &V2) {
        const double dot_product  = V1.dot(V2);
        const double norm_product = V1.norm() * V2.norm();
        return (norm_product < 1.0e-13) ? 1.0 : dot_product / norm_product;
    }

    friend inline bool is_point_between_two_others(const vector3 &A, const vector3 &B, const vector3 &P, double epsilon = 1e-9) {
        const double d_AB  = distance(A, B);
        const double d_sum = distance(A, P) + distance(P, B);
        return (d_AB <= d_sum + epsilon && d_AB >= d_sum - epsilon);
    }

    friend double double_scalar_product_2d(const vector3 &v1, const vector3 &v2) {
        // 2D determinant using (x,y) components
        return v1.m_x * v2.m_y - v1.m_y * v2.m_x;
    }

    /**
     * @brief Compute the intersection between two 2D segments [A B] and [C D] (using x,y only).
     * Returns std::nullopt if parallel/colinear or if intersection lies outside either segment.
     */
    friend std::optional<vector3> compute_line_line_intersection(const vector3 &A, const vector3 &B, const vector3 &C, const vector3 &D) {
        constexpr double eps = 1e-14;
        const vector3    r   = B - A;  // segment 1
        const vector3    s   = D - C;  // segment 2
        const vector3    qmp = C - A;  // from A to C

        const double rxs = double_scalar_product_2d(r, s);
        if (std::fabs(rxs) < eps) {
            // Parallel (or colinear) in 2D
            return {};
        }

        // Barycentric parameters:
        // A + t*r  intersects  C + u*s
        const double t = double_scalar_product_2d(qmp, s) / rxs;
        const double u = double_scalar_product_2d(qmp, r) / rxs;

        if (t >= -eps && t <= 1.0 + eps && u >= -eps && u <= 1.0 + eps) {
            const vector3 P = A + t * r;
            return {P};
        }
        return {};
    }

    vector3 &operator+=(const vector3 &lhs) {
        m_x += lhs.m_x;
        m_y += lhs.m_y;
        m_z += lhs.m_z;
        return *this;
    }

    vector3 &operator-=(const vector3 &lhs) {
        m_x -= lhs.m_x;
        m_y -= lhs.m_y;
        m_z -= lhs.m_z;
        return *this;
    }

    vector3 &operator*=(const double lambda) {
        m_x *= lambda;
        m_y *= lambda;
        m_z *= lambda;
        return *this;
    }

    vector3 &operator/=(const double lambda) {
        m_x /= lambda;
        m_y /= lambda;
        m_z /= lambda;
        return *this;
    }

    friend vector3 operator+(const vector3 &lhs, const vector3 &rhs) {
        vector3 v = lhs;
        v += rhs;
        return v;
    }

    friend vector3 operator-(const vector3 &lhs, const vector3 &rhs) {
        vector3 v = lhs;
        v -= rhs;
        return v;
    }

    friend vector3 operator*(const vector3 &lhs, const double lambda) {
        vector3 v = lhs;
        v *= lambda;
        return v;
    }

    friend vector3 operator*(const double lambda, const vector3 &lhs) {
        vector3 v = lhs;
        v *= lambda;
        return v;
    }

    friend vector3 operator/(const vector3 &lhs, const double lambda) {
        vector3 v = lhs;
        v /= lambda;
        return v;
    }

    friend std::ostream &operator<<(std::ostream &os, const vector3 &vect) {
        os << vect.m_x << ',' << vect.m_y << ',' << vect.m_z;
        return os;
    }
};

static_assert(std::is_trivially_copyable_v<vector3>, "vector3 must be trivially copyable");
static_assert(std::is_standard_layout_v<vector3>, "vector3 must be standard-layout");

}  // namespace bz_mesh/**
 * @file bz_states.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "bz_states.hpp"

#include <Eigen/Dense>
#include <filesystem>
#include <fstream>

#include "Hamiltonian.h"
#include "bz_mesh.hpp"
#include "omp.h"

namespace bz_mesh {

void BZ_States::compute_eigenstates(int nb_threads) {
    double     normalization_factor = 2.0 * M_PI / m_material.get_lattice_constant_meter();
    const bool m_nonlocal_epm       = false;
    const bool keep_eigenvectors    = true;
    m_eigenvalues_k.resize(m_list_vertices.size());
    m_eigenvectors_k.resize(m_list_vertices.size());
    std::vector<EmpiricalPseudopotential::Hamiltonian> hamiltonian_per_thread;
    for (int i = 0; i < nb_threads; i++) {
        hamiltonian_per_thread.push_back(EmpiricalPseudopotential::Hamiltonian(m_material, m_basisVectors));
    }
#pragma omp parallel for schedule(dynamic) num_threads(nb_threads)
    for (std::size_t idx_k = 0; idx_k < m_list_vertices.size(); ++idx_k) {
        if (omp_get_thread_num() == 0) {
            std::cout << "\rComputing eigenstates for k = " << idx_k << "/" << m_list_vertices.size() << std::flush;
        }
        auto k_point    = Vector3D<double>(m_list_vertices[idx_k].get_position().x(),
                                        m_list_vertices[idx_k].get_position().y(),
                                        m_list_vertices[idx_k].get_position().z());
        k_point         = k_point * 1.0 / normalization_factor;
        auto idx_thread = omp_get_thread_num();
        hamiltonian_per_thread[idx_thread].SetMatrix(k_point, m_nonlocal_epm);
        hamiltonian_per_thread[idx_thread].Diagonalize(keep_eigenvectors);
        m_eigenvalues_k[idx_k]  = hamiltonian_per_thread[idx_thread].eigenvalues();
        m_eigenvectors_k[idx_k] = hamiltonian_per_thread[idx_thread].get_eigenvectors();
        auto nb_rows            = m_eigenvectors_k[idx_k].rows();
        m_eigenvectors_k[idx_k].conservativeResize(nb_rows, m_nb_bands);
    }
    std::cout << std::endl;
}

void BZ_States::compute_shifted_eigenstates(const Vector3D<double>& q_shift, int nb_threads) {
    m_q_shift                       = q_shift;
    double     normalization_factor = 2.0 * M_PI / m_material.get_lattice_constant_meter();
    m_q_shift                      = m_q_shift * normalization_factor;
    const bool m_nonlocal_epm       = false;
    const bool keep_eigenvectors    = true;
    m_eigenvalues_k_plus_q.resize(m_list_vertices.size());
    m_eigenvectors_k_plus_q.resize(m_list_vertices.size());
    std::vector<EmpiricalPseudopotential::Hamiltonian> hamiltonian_per_thread;
    for (int i = 0; i < nb_threads; i++) {
        hamiltonian_per_thread.push_back(EmpiricalPseudopotential::Hamiltonian(m_material, m_basisVectors));
    }
#pragma omp parallel for schedule(dynamic) num_threads(nb_threads)
    for (std::size_t idx_k = 0; idx_k < m_list_vertices.size(); ++idx_k) {
        if (omp_get_thread_num() == 0) {
            std::cout << "\rComputing eigenstates for k = " << idx_k << "/" << m_list_vertices.size() << std::flush;
        }
        auto k_point = Vector3D<double>(m_list_vertices[idx_k].get_position().x(),
                                        m_list_vertices[idx_k].get_position().y(),
                                        m_list_vertices[idx_k].get_position().z());
        k_point      = k_point * 1.0 / normalization_factor;
        k_point += q_shift;
        auto idx_thread = omp_get_thread_num();
        hamiltonian_per_thread[idx_thread].SetMatrix(k_point, m_nonlocal_epm);
        hamiltonian_per_thread[idx_thread].Diagonalize(keep_eigenvectors);
        m_eigenvalues_k_plus_q[idx_k]  = hamiltonian_per_thread[idx_thread].eigenvalues();
        m_eigenvectors_k_plus_q[idx_k] = hamiltonian_per_thread[idx_thread].get_eigenvectors();
        auto nb_rows                   = m_eigenvectors_k[idx_k].rows();
        m_eigenvectors_k_plus_q[idx_k].conservativeResize(nb_rows, m_nb_bands);
    }
    std::cout << std::endl;
}

/**
 * @brief Compute the dielectric function for a given list of energies and a given smearing.
 * The integration is performed by summing the contribution of each tetrahedron to the dielectric function.
 *
 * @param energies
 * @param eta_smearing
 * @param nb_threads
 */
void BZ_States::compute_dielectric_function(const std::vector<double>& list_energies, double eta_smearing, int nb_threads) {


    m_list_energies                         = list_energies;
    const int   index_first_conduction_band = 4;
    std::size_t nb_tetra                    = m_list_tetrahedra.size();
    m_dielectric_function_real.resize(list_energies.size());
    constexpr double one_fourth = 1.0 / 4.0;

    std::vector<double> dielectric_function_real_at_energies(list_energies.size(), 0.0);
    double              total_volume = 0.0;
#pragma omp parallel for schedule(dynamic) num_threads(nb_threads) reduction(+:total_volume)
    for (std::size_t idx_tetra = 0; idx_tetra < nb_tetra; ++idx_tetra) {
        if (omp_get_thread_num() == 0) {
            std::cout << "\rComputing dielectric function for tetrahedron " << idx_tetra << "/" << nb_tetra << std::flush;
        }
        std::array<std::size_t, 4>    list_idx_vertices = m_list_tetrahedra[idx_tetra].get_list_indices_vertices();
        const std::array<Vertex*, 4>& list_vertices     = m_list_tetrahedra[idx_tetra].get_list_vertices();
        double                        volume_tetra      = std::fabs(m_list_tetrahedra[idx_tetra].compute_signed_volume());
        total_volume += volume_tetra;
        // std::cout << "Volume tetra = " << volume_tetra << std::endl;
        std::vector<double> sum_dielectric_function_real_tetra_at_energies(list_energies.size(), 0.0);
        // Loop over the vertices of the tetrahedron
        for (std::size_t idx_vertex = 0; idx_vertex < 4; ++idx_vertex) {
            std::size_t index_k = list_idx_vertices[idx_vertex];
            for (int idx_conduction_band = index_first_conduction_band; idx_conduction_band < m_nb_bands; ++idx_conduction_band) {
                for (int idx_valence_band = 0; idx_valence_band < index_first_conduction_band; ++idx_valence_band) {
                    double overlap_integral = pow(std::fabs(m_eigenvectors_k_plus_q[index_k]
                                                                .col(idx_conduction_band)
                                                                .adjoint()
                                                                .dot(m_eigenvectors_k[index_k].col(idx_valence_band))),
                                                  2);
                    double delta_energy = m_eigenvalues_k_plus_q[index_k][idx_conduction_band] - m_eigenvalues_k[index_k][idx_valence_band];
                    for (std::size_t index_energy = 0; index_energy < list_energies.size(); ++index_energy) {
                        double energy = list_energies[index_energy];
                        double factor_1 =
                            (delta_energy - energy) / ((delta_energy - energy) * (delta_energy - energy) + eta_smearing * eta_smearing);
                        double factor_2 =
                            (delta_energy + energy) / ((delta_energy + energy) * (delta_energy + energy) + eta_smearing * eta_smearing);
                        double total_factor = factor_1 + factor_2;
                        sum_dielectric_function_real_tetra_at_energies[index_energy] += overlap_integral * total_factor;
                    }
                }
            }
        }
        for (std::size_t index_energy = 0; index_energy < list_energies.size(); ++index_energy) {
            sum_dielectric_function_real_tetra_at_energies[index_energy] *= volume_tetra * one_fourth;
            dielectric_function_real_at_energies[index_energy] += sum_dielectric_function_real_tetra_at_energies[index_energy];
        }
    }
    std::cout << "\n";
    std::cout << "Total volume (k-space) integrated: " << total_volume << std::endl;

    double a          = m_material.get_lattice_constant_meter();  // (m), for Si cubic cell
    double Omega_cell = a * a * a;                                // if your grid is on the simple cubic cell
    double V_BZ       = std::pow(2.0 * M_PI, 3) / Omega_cell;
    std::cout << "Expected BZ volume: " << V_BZ << "\n";
    std::cout << "Integrated volume: " << total_volume << "\n";
    std::cout << "Ratio (integrated / expected): " << (total_volume / V_BZ) << "\n";

    double q_squared = m_q_shift.Length() * m_q_shift.Length();

    // // prefactor in SI, with J→eV conversion
    // double prefactor = (EmpiricalPseudopotential::Constants::q_e * EmpiricalPseudopotential::Constants::q_e) /
    //                    (EmpiricalPseudopotential::Constants::eps_0 * q_squared) / EmpiricalPseudopotential::Constants::q_e *
    //                    (2.0 / std::pow(2.0 * M_PI, 3));

    double coulomb_prefactor_eV = (EmpiricalPseudopotential::Constants::q_e * EmpiricalPseudopotential::Constants::q_e) /
                                   (EmpiricalPseudopotential::Constants::eps_0 * q_squared)  // J·m
                                  / EmpiricalPseudopotential::Constants::q_e;                                                      // → eV·m
    double prefactor = coulomb_prefactor_eV * (2.0 / std::pow(2.0 * M_PI, 3));

    for (std::size_t index_energy = 0; index_energy < list_energies.size(); ++index_energy) {
        m_dielectric_function_real[index_energy] = 1.0 + prefactor * dielectric_function_real_at_energies[index_energy];
    }

    std::cout << "EPS[0] = " << m_dielectric_function_real[0] << std::endl;
}

// Export the dielectric function to a file in the format (energy, dielectric function) (csv format).
void BZ_States::export_dielectric_function(const std::string& prefix) const {
    std::ofstream dielectric_function_file(prefix + "_dielectric_function.csv");
    dielectric_function_file << "Energy (eV),Dielectric function" << std::endl;
    for (std::size_t index_energy = 0; index_energy < m_dielectric_function_real.size(); ++index_energy) {
        dielectric_function_file << m_list_energies[index_energy] << "," << m_dielectric_function_real[index_energy] << std::endl;
    }
    dielectric_function_file.close();
}

void BZ_States::export_full_eigenstates() const {
    std::filesystem::remove_all("eigenstates");
    std::filesystem::create_directory("eigenstates");
    std::filesystem::create_directory("eigenstates/eigenvectors");
    std::filesystem::create_directory("eigenstates/eigenvalues");
    for (std::size_t idx_k = 0; idx_k < m_list_vertices.size(); ++idx_k) {
        std::ofstream eigenvalues_file("eigenstates/eigenvalues/eigenvalues_" + std::to_string(idx_k) + ".txt");
        eigenvalues_file << m_eigenvalues_k[idx_k].transpose() << std::endl;
        eigenvalues_file.close();
        std::ofstream shiftedeigenvalues_file("eigenstates/eigenvalues/shiftedeigenvalues_" + std::to_string(idx_k) + ".txt");
        shiftedeigenvalues_file << m_eigenvalues_k_plus_q[idx_k].transpose() << std::endl;
        shiftedeigenvalues_file.close();

        std::ofstream eigenvectors_file("eigenstates/eigenvectors/eigenvectors_" + std::to_string(idx_k) + ".txt");
        eigenvectors_file << m_eigenvectors_k[idx_k] << std::endl;
        eigenvectors_file.close();
        std::ofstream shiftedeigenvectors_file("eigenstates/eigenvectors/shiftedeigenvectors_" + std::to_string(idx_k) + ".txt");
        shiftedeigenvectors_file << m_eigenvectors_k_plus_q[idx_k] << std::endl;
        shiftedeigenvectors_file.close();
    }
}

// void BZ_States::populate_vtx_dielectric_function(const std::vector<double>& energies, double eta_smearing);

}  // namespace bz_mesh/**
 * @file dielectric_mesh.cpp
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2024-05-17
 *
 * @copyright Copyright (c) 2024
 *
 */

#include "dielectric_mesh.hpp"

#include <regex>

#include "gmsh.h"

namespace bz_mesh {

void DielectricMesh::read_dielectric_file(const std::string& filename) {
    std::cout << "Opening file " << filename << std::endl;
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::open(filename);
    std::vector<int> viewTags;
    gmsh::view::getTags(viewTags);
    int nb_energies = viewTags.size();
    if (nb_energies % 2 != 0) {
        // The number of viewTags should be even because we have the real and imaginary part of the dielectric function for each energy.
        std::cerr << "The number of energies is not even. The file is corrupted." << std::endl;
        return;
    }
    nb_energies /= 2;
    int                              count_energy = 0;
    std::vector<double>              energies;
    std::vector<std::vector<double>> real_dielectric;
    std::vector<std::vector<double>> imag_dielectric;
    for (auto&& tag : viewTags) {
        const int   index_view  = gmsh::view::getIndex(tag);
        std::string name_object = "View[" + std::to_string(index_view) + "].Name";
        std::string name_view;
        try {
            gmsh::option::getString(name_object, name_view);
        } catch (const std::exception& e) {
            std::cerr << e.what() << '\n';
        }

        std::string energy_str = name_view.substr(name_view.find_last_of("_") + 1, name_view.size());
        double      energy     = std::stod(energy_str);
        if (count_energy % 2 == 0) {
            energies.push_back(energy);
        }

        // If the name of the view starts with "eps_r" we store the data in the real part of the dielectric function.
        // If the name of the view starts with "eps_i" we store the data in the imaginary part of the dielectric function.
        std::regex re_real("eps_r");
        std::regex re_imag("eps_i");

        std::smatch              match_real;
        std::smatch              match_imag;
        std::string              type;
        std::vector<std::size_t> tags;
        double                   time;
        int                      numComp;
        std::vector<double>      data_view;
        gmsh::view::getHomogeneousModelData(tag, 0, type, tags, data_view, time, numComp);
        // std::cout << "View " << name_view << " has " << data_view.size() << " values." << std::endl;
        if (std::regex_search(name_view, match_real, re_real)) {
            real_dielectric.push_back(data_view);
        } else if (std::regex_search(name_view, match_imag, re_imag)) {
            imag_dielectric.push_back(data_view);
        }
        count_energy++;
    }
    std::cout << "Number of energies: " << nb_energies << std::endl;
    std::cout << "Number of energies in the real part: " << energies.size() << std::endl;
    std::cout << "Number of dielectric functions in the real part: " << real_dielectric.size() << std::endl;
    std::cout << "Number of dielectric functions in the imaginary part: " << imag_dielectric.size() << std::endl;
    if (energies.size() != nb_energies) {
        std::cerr << "The number of energies is not the same in the real and imaginary part of the dielectric function." << std::endl;
        return;
    }
    gmsh::finalize();
    m_energies = energies;
    m_dielectric_function.resize(m_list_vertices.size());
    for (std::size_t idx_node = 0; idx_node < m_list_vertices.size(); ++idx_node) {
        m_dielectric_function[idx_node].resize(energies.size());
        for (std::size_t idx_energy = 0; idx_energy < energies.size(); ++idx_energy) {
            m_dielectric_function[idx_node][idx_energy] =
                std::complex<double>(real_dielectric[idx_energy][idx_node], imag_dielectric[idx_energy][idx_node]);
        }
    }
    std::cout << "Size of the dielectric function: " << m_dielectric_function.size() << " x " << m_dielectric_function[0].size()
              << std::endl;
    std::cout << "Dielectric function read." << std::endl;
}

std::pair<std::size_t, double> DielectricMesh::find_closest_energy(double energy) const {
    if (m_energies.empty()) {
        return std::make_pair(0, 0.0);
    }
    if (energy < m_energies.front()) {
        return std::make_pair(0, 0.0);
    }
    if (energy > m_energies.back()) {
        return std::make_pair(m_energies.size() - 1, 0.0);
    }
    auto it = std::lower_bound(m_energies.begin(), m_energies.end(), energy);
    if (it == m_energies.begin()) {
        return std::make_pair(0, 0.0);
    }
    if (it == m_energies.end()) {
        return std::make_pair(m_energies.size() - 1, 0.0);
    }
    std::size_t idx = std::distance(m_energies.begin(), it);
    double      t   = (energy - m_energies[idx - 1]) / (m_energies[idx] - m_energies[idx - 1]);
    return std::make_pair(idx - 1, t);
}

complex_d DielectricMesh::interpolate_dielectric_function(const vector3& k, double energy) const {
    auto   k_positive{vector3{std::abs(k.x()), std::abs(k.y()), std::abs(k.z())}};
    Tetra* p_tetra = find_tetra_at_location(k_positive);
    if (p_tetra == nullptr) {
        std::cerr << "Tetra not found at location " << k_positive << std::endl;
        return 0.0;
    }
    std::array<double, 4> barycentric_coordinates = p_tetra->compute_barycentric_coordinates(k_positive);

    std::array<std::size_t, 4>          list_indices_vertices = p_tetra->get_list_indices_vertices();
    std::pair<std::size_t, double>      closest_energy        = find_closest_energy(energy);
    std::size_t                         idx_energy            = closest_energy.first;
    double                              t                     = closest_energy.second;
    std::vector<std::complex<double>> dielectric_function_low(4);
    std::vector<std::complex<double>> dielectric_function_high(4);
    for (std::size_t idx_vertex = 0; idx_vertex < 4; ++idx_vertex) {
        std::cout << "Vertex: " << list_indices_vertices[idx_vertex] << std::endl;
        dielectric_function_low[idx_vertex]  = m_dielectric_function[idx_energy][list_indices_vertices[idx_vertex]];
        dielectric_function_high[idx_vertex] = m_dielectric_function[idx_energy + 1][list_indices_vertices[idx_vertex]];
    }
    std::complex<double> dielectric_function_interpolated_low =
        p_tetra->interpolate_at_position(barycentric_coordinates, dielectric_function_low);
    std::complex<double> dielectric_function_interpolated_high =
        p_tetra->interpolate_at_position(barycentric_coordinates, dielectric_function_high);

    std::cout << "Idx energy: " << idx_energy << std::endl;
    std::cout << "Energy: " << energy << std::endl;
    std::cout << "Closest energy: " << m_energies[idx_energy] << std::endl;
    std::cout << "Interpolated energy: " << (1 - t) * m_energies[idx_energy] + t * m_energies[idx_energy + 1] << std::endl;
    return (1 - t) * dielectric_function_interpolated_low + t * dielectric_function_interpolated_high;
}

}  // namespace bz_mesh/**
 * @file mesh_tetra.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */
#pragma once

#include <array>
#include <complex>
#include <functional>
#include <iostream>
#include <numeric>
#include <string>
#include <vector>

#include "bbox_mesh.hpp"
#include "mesh_vertex.hpp"

namespace bz_mesh {

using array4d = std::array<double, 4>;

struct UniformDos {
    bool               valid{false};
    double             E0{0.0};
    double             Emax{0.0};
    double             inv_dx{0.0};  // 1 / dx
    uint32_t           N{0};         // number of knots = nb_steps + 1
    std::vector<float> D;            // try float to halve bandwidth; use double if needed

    inline double sample_or_zero(double E) const noexcept {
        if (!valid || E < E0 || E > Emax) {
            return 0.0;
        }
        const double t   = (E - E0) * inv_dx;
        int          idx = static_cast<int>(t);  // floor
        // clamp to [0, N-2]
        const int last = static_cast<int>(N) - 2;
        if (idx < 0) idx = 0;
        if (idx > last) idx = last;

        const float  d0   = D[static_cast<size_t>(idx)];
        const float  d1   = D[static_cast<size_t>(idx + 1)];
        const double frac = t - static_cast<double>(idx);
        // one FMA; cast once to double to keep precision in math path
        return std::fma(frac, static_cast<double>(d1 - d0), static_cast<double>(d0));
    }
};

class Tetra {
 private:
    /**
     * @brief Element index.
     *
     */
    std::size_t m_index;

    /**
     * @brief The 4 vertices of the tetrahedra are stored as an array of pointers on Vertices object.
     *
     */
    std::array<Vertex*, 4> m_list_vertices{nullptr, nullptr, nullptr, nullptr};

    /**
     * @brief List of the edges vectors of the tetrahedra.
     * Stored as follows: [v01, v02, v03, v12, v13, v23]
     * where for example v13 = m_list_vertices[1] - m_list_vertices[3].
     *
     */
    std::array<vector3, 6> m_list_edges{};

    /**
     * @brief Bounding box of the tetrahedra.
     *
     */
    bbox_mesh m_bbox;

    /**
     * @brief Barycenter of the tetrahedra.
     *
     */
    vector3 m_barycenter;

    /**
     * @brief Signed volume of the tetrahedra.
     * The sign depends on the "orientation" of the tetrahedra.
     *
     */
    double m_signed_volume = 0.0;

    /**
     * @brief Number of conduction bands.
     *
     */
    std::size_t m_nb_bands = 0;

    /**
     * @brief The value min_energy_per_band[k] is the minimum energy of the k-th band on the tetrahedra.
     * It is pre-computed and stored for optimization purposes.
     *
     */
    std::vector<double> m_min_energy_per_band;

    /**
     * @brief The value max_energy_per_band[k] is the maximum energy of the k-th band on the tetrahedra.
     * It is pre-computed and stored for optimization purposes.
     *
     */
    std::vector<double> m_max_energy_per_band;

    /**
     * @brief G>radient of the energy at the vertices of the tetrahedra for each band.
     * It is pre-computed and stored for optimization purposes.
     *
     */
    std::vector<vector3> m_gradient_energy_per_band;

    /**
     * @brief For each band, store the indices of the vertices sorted by increasing energy.
     * For example, if for band k, vertex 2 has the lowest energy, then vertex 0, then vertex 3, then vertex 1,
     * then m_sorted_slots_per_band[k] = {2, 0, 3, 1}.
     *
     */
    std::vector<std::array<int, 4>> m_sorted_slots_per_band;

    /**
     * @brief Precomputed DOS on a uniform energy grid for each band.
     *
     */
    std::vector<UniformDos> m_dos_per_band;

 public:
    /**
     * @brief There is not default constructor for Tetra class.
     *
     */
    Tetra() = delete;

    Tetra(std::size_t index, const std::array<Vertex*, 4>& list_vertices);

    const bbox_mesh& get_bounding_box() const;
    bbox_mesh        compute_bounding_box() const;
    void             compute_min_max_energies_at_bands();
    vector3          get_barycenter() const { return m_barycenter; }

    std::size_t                   get_index() const { return m_index; }
    const std::array<Vertex*, 4>& get_list_vertices() const { return m_list_vertices; }
    std::array<std::size_t, 4>    get_list_indices_vertices() const {
        return {m_list_vertices[0]->get_index(),
                   m_list_vertices[1]->get_index(),
                   m_list_vertices[2]->get_index(),
                   m_list_vertices[3]->get_index()};
    }
    std::array<vector3, 6> get_list_edges() const { return m_list_edges; }
    std::size_t            get_nb_bands() const { return m_nb_bands; }

    std::array<double, 4> get_band_energies_at_vertices(std::size_t index_band) const;

    double  compute_signed_volume() const;
    double  get_signed_volume() const { return m_signed_volume; }
    vector3 compute_edge(std::size_t index_vtx_1, std::size_t index_vtx_2) const;
    void    compute_gradient_energy_at_bands();
    vector3 compute_gradient_at_tetra(const array4d& values_at_vertices) const;

    vector3               compute_barycenter() const;
    bool                  is_location_inside(const vector3& location) const;
    std::array<double, 4> compute_barycentric_coordinates(const vector3& location) const;
    vector3               compute_euclidean_coordinates(const std::array<double, 4>& barycentric_coordinates) const;
    vector3               compute_euclidean_coordinates_with_indices(const std::array<double, 4>& barycentric_coordinates,
                                                                     const std::array<int, 4>&    indices_vertex) const;

    void                      pre_compute_sorted_slots_per_band();
    const std::array<int, 4>& get_index_vertices_with_sorted_energy_at_band(std::size_t index_band) const {
        return m_sorted_slots_per_band[index_band];
    }

    void   precompute_dos_on_energy_grid_per_band(double energy_step, double energy_threshold);
    double interpolate_dos_at_energy_per_band(double energy, std::size_t band_index) const noexcept;

    vector3 get_gradient_energy_at_band(std::size_t band_index) const { return m_gradient_energy_per_band[band_index]; }

    bool                 is_energy_inside_band(double energy, std::size_t index_band) const;
    bool                 does_intersect_band_energy_range(double e_min, double e_max, std::size_t index_band) const;
    std::vector<vector3> compute_band_iso_energy_surface(double iso_energy, std::size_t band_index) const;
    double               compute_tetra_iso_surface_energy_band(double energy, std::size_t band_index) const;
    double               compute_tetra_iso_surface_energy_band2(double energy, std::size_t band_index) const;
    double               compute_tetra_dos_energy_band(double energy, std::size_t band_index) const;
    vector3              draw_random_uniform_point_at_energy(double iso_energy, std::size_t band_index, std::mt19937& rng) const;

    std::array<double, 8> get_tetra_electron_phonon_rates(int band_index) const;

    double interpolate_scalar_at_position(const std::array<double, 4>& barycentric_coordinates,
                                          const std::vector<double>&   scalar_field) const;
    double interpolate_energy_at_band(const vector3& location, std::size_t band_index) const;

    vector3 interpolate_vector_at_position(const std::array<double, 4>& barycentric_coordinates,
                                           const std::vector<vector3>&  vector_field) const;
    template <typename T>
    T interpolate_at_position(const std::array<double, 4>& barycentric_coordinates, const std::vector<T>& field) const {
        T interpolated_value = T::Zero();
        for (std::size_t idx_vtx = 0; idx_vtx < 4; ++idx_vtx) {
            interpolated_value += barycentric_coordinates[idx_vtx] * field[idx_vtx];
        }
        return interpolated_value;
    }
    std::complex<double> interpolate_at_position(const std::array<double, 4>&             barycentric_coordinates,
                                                 const std::vector<std::complex<double>>& field) const {
        std::complex<double> interpolated_value = 0.0;
        for (std::size_t idx_vtx = 0; idx_vtx < 4; ++idx_vtx) {
            interpolated_value += barycentric_coordinates[idx_vtx] * field[idx_vtx];
        }

        return interpolated_value;
    }
};

}  // namespace bz_mesh/**
 * @file bz_states.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "impact_ionization.hpp"

#include <Eigen/Dense>
#include <filesystem>
#include <fstream>

#include "BandStructure.h"
#include "Constants.hpp"
#include "Hamiltonian.h"
#include "Material.h"
#include "Options.h"
#include "bz_mesh.hpp"
#include "bz_states.hpp"
#include "omp.h"

namespace bz_mesh {

ImpactIonization::ImpactIonization(const EmpiricalPseudopotential::Material& material, const std::string& initial_mesh_path) {
    std::filesystem::path path(initial_mesh_path);
    if (!std::filesystem::exists(path)) {
        std::cerr << "Error: file " << initial_mesh_path << " does not exist." << std::endl;
        exit(1);
    }
    std::ifstream file(initial_mesh_path);
    if (!file.is_open()) {
        std::cerr << "Error: could not open file " << initial_mesh_path << std::endl;
        exit(1);
    }
    m_material          = material;
    m_initial_mesh_path = initial_mesh_path;
}

void ImpactIonization::read_dielectric_file(const std::string& filename) {
    bool normalize_by_fourier_factor = false;
    m_dielectric_mesh.read_mesh_geometry_from_msh_file(filename, normalize_by_fourier_factor);
    m_dielectric_mesh.build_search_tree();
    m_dielectric_mesh.read_dielectric_file(filename);
}

void ImpactIonization::interp_test_dielectric_function(std::string filename) {
    double        eps = 1e-6;
    double        x0  = eps;
    double        y0  = eps;
    double        z0  = eps;
    double        x1  = 3.0;
    double        y1  = 3.0;
    double        z1  = 3.0;
    int           nx  = 20;
    int           ny  = 20;
    int           nz  = 20;
    double        dx  = (x1 - x0) / nx;
    double        dy  = (y1 - y0) / ny;
    double        dz  = (z1 - z0) / nz;
    std::ofstream file(filename);
    for (int i = 0; i < nx; ++i) {
        for (int j = 0; j < ny; ++j) {
            for (int k = 0; k < nz; ++k) {
                double    x = x0 + i * dx;
                double    y = y0 + j * dy;
                double    z = z0 + k * dz;
                vector3   position(x, y, z);
                complex_d epsilon = m_dielectric_mesh.interpolate_dielectric_function(position, 0.0102);
                file << x << ", " << y << ", " << z << ", " << epsilon.real() << ", " << epsilon.imag() << std::endl;
                std::cout << "Position: " << position << " epsilon: " << epsilon << std::endl;
            }
        }
    }
    file.close();
}

void ImpactIonization::compute_eigenstates(int nb_threads) {
    int                nb_bands_to_use = 16;
    bz_mesh::BZ_States my_bz_mesh(m_material);
    my_bz_mesh.set_nb_bands(nb_bands_to_use);
    EmpiricalPseudopotential::BandStructure band_structure{};
    int                                     nb_nearest_neighbors = 10;
    bool                                    nonlocal_epm         = false;
    bool                                    enable_soc           = false;
    band_structure.Initialize(m_material, nb_bands_to_use, {}, nb_nearest_neighbors, nonlocal_epm, enable_soc);
    auto basis = band_structure.get_basis_vectors();
    my_bz_mesh.set_basis_vectors(basis);

    my_bz_mesh.read_mesh_geometry_from_msh_file(m_initial_mesh_path);

    const vector3 b1 = {-1.0, 1.0, 1.0};
    const vector3 b2 = {1.0, -1.0, 1.0};
    const vector3 b3 = {1.0, 1.0, -1.0};

    // std::cout << "k: " << k << std::endl;
    double factor = 2.0 * M_PI / m_material.get_lattice_constant_meter();
    // test k + G
    std::vector<int> list_n_k = {0, 1, -1, 2, -2, 3, -3, 4, -4};
    // std::vector<int> list_n_k = {0, 1, -1, 2, -2};

    std::cout << "Max radius G0 BZ: " << m_max_radius_G0_BZ << std::endl;
    for (auto&& n_k_x : list_n_k) {
        for (auto&& n_k_y : list_n_k) {
            for (auto&& n_k_z : list_n_k) {
                vector3 G_BZ = n_k_x * b1 + n_k_y * b2 + n_k_z * b3;
                if (G_BZ.norm() > m_max_radius_G0_BZ) {
                    continue;
                }
                std::cout << "G_BZ: " << G_BZ << " --> " << G_BZ.norm() << std::endl;
                G_BZ = G_BZ * factor;

                auto ptr_BZ_states = std::make_unique<BZ_States>(m_material);
                ptr_BZ_states->set_nb_bands(nb_bands_to_use);
                ptr_BZ_states->set_basis_vectors(basis);
                ptr_BZ_states->read_mesh_geometry_from_msh_file(m_initial_mesh_path);
                ptr_BZ_states->shift_bz_center(G_BZ);
                ptr_BZ_states->compute_eigenstates(nb_threads);
                m_list_BZ_states.push_back(std::move(ptr_BZ_states));
            }
        }
    }
    std::cout << "Number of BZ states: " << m_list_BZ_states.size() << std::endl;
}

double ImpactIonization::compute_impact_ionization_rate(int idx_n1, std::size_t idx_k1) {
    constexpr int                     nb_valence_bands    = 3;
    constexpr int                     nb_conduction_bands = 4;
    constexpr int                     min_conduction_band = 4;
    const std::size_t                 nb_vtx              = m_list_BZ_states[0]->get_list_vertices().size();
    const std::vector<Vector3D<int>>& basis_vector_G      = m_list_BZ_states[0]->get_basis_vectors();

    std::cout << "Start computing impact ionization rate for band " << idx_n1 << " and k-point " << idx_k1 << std::endl;
    auto start_precompute = std::chrono::high_resolution_clock::now();
    std::cout << "Nb of Bz states: " << m_list_BZ_states.size() << std::endl;
    std::cout << "Nb cols: " << m_list_BZ_states[0]->get_eigen_states()[0].cols() << std::endl;

    // Sum_2_prime[idx_band][idx_node]
    std::vector<std::vector<complex_d>> Sum_2_prime(nb_conduction_bands);
    for (int idx_n2_prime = 0; idx_n2_prime < nb_conduction_bands; ++idx_n2_prime) {
        int n2_prime = idx_n2_prime + min_conduction_band;
        Sum_2_prime[idx_n2_prime].resize(nb_vtx);
        for (std::size_t idx_node = 0; idx_node < nb_vtx; ++idx_node) {
            const Eigen::MatrixXcd& A_2_prime   = m_list_BZ_states[0]->get_eigen_states()[idx_node];
            Sum_2_prime[idx_n2_prime][idx_node] = A_2_prime.col(n2_prime).sum();
        }
    }
    std::cout << "Sum_2_prime done" << std::endl;
    // Sum_2[idx_band][idx_node]
    std::vector<std::vector<complex_d>> Sum_2(nb_valence_bands);
    for (int idx_n2 = 0; idx_n2 < nb_valence_bands; ++idx_n2) {
        Sum_2_prime[idx_n2].resize(nb_vtx);
        for (std::size_t idx_node = 0; idx_node < nb_vtx; ++idx_node) {
            const Eigen::MatrixXcd& A_2   = m_list_BZ_states[0]->get_eigen_states()[idx_node];
            Sum_2_prime[idx_n2][idx_node] = A_2.col(idx_n2).sum();
        }
    }

    std::cout << "Sum_2 done" << std::endl;

    // Sum_2_prime[idx_band][idx_node] (n1, k1 are in an outter loop)
    std::vector<std::vector<complex_d>> Sum_1_prime_1(nb_conduction_bands);
    for (int idx_n1_prime = 0; idx_n1_prime < nb_conduction_bands; ++idx_n1_prime) {
        std::size_t n1_prime = idx_n1_prime + min_conduction_band;
        Sum_1_prime_1[idx_n1_prime].resize(nb_vtx);
        for (std::size_t idx_k1_prime = 0; idx_k1_prime < nb_vtx; ++idx_k1_prime) {
            const Eigen::MatrixXcd& A_1_prime = m_list_BZ_states[0]->get_eigen_states()[idx_k1_prime];
            const Eigen::MatrixXcd& A_1       = m_list_BZ_states[0]->get_eigen_states()[idx_k1];
            int                     nb_Gvect  = A_1_prime.rows();
            complex_d               sum       = 0.0;
            for (int idx_G1_prime = 0; idx_G1_prime < nb_Gvect; ++idx_G1_prime) {
                for (int idx_G1 = 0; idx_G1 < nb_Gvect; ++idx_G1) {
                    auto    G1_prime = basis_vector_G[idx_G1_prime];
                    auto    GG1      = basis_vector_G[idx_G1];
                    vector3 GA       = vector3(G1_prime.X + GG1.X, G1_prime.Y + GG1.Y, G1_prime.Z + GG1.Z);
                    vector3 GA_prime = vector3(G1_prime.X, G1_prime.Y, G1_prime.Z);
                    auto    k1       = m_list_BZ_states[0]->get_vertex_position(idx_k1);
                    auto    k1_prime = m_list_BZ_states[0]->get_vertex_position(idx_k1_prime);
                    // auto    q_a      = k1 - k1_prime + G1 + (-1 * G1_prime);
                    double  energy_w = m_list_BZ_states[0]->get_energies()[idx_n1] - m_list_BZ_states[0]->get_energies()[n1_prime];
                    // complex_d epsilon    = m_dielectric_mesh.interpolate_dielectric_function(q_a, energy_w);
                    // complex_d epsilon    = 1.0;
                    // complex_d factor_eps = EmpiricalPseudopotential::Constants::q_e * EmpiricalPseudopotential::Constants::q_e /
                    //                        (EmpiricalPseudopotential::Constants::eps_0 * epsilon * q_a.norm() * q_a.norm());
                    // sum += std::conj(A_1_prime(idx_G1_prime, n1_prime)) * A_1(idx_G1, idx_n1) * factor_eps;
                }
            }
            Sum_1_prime_1[idx_n1_prime][idx_k1_prime] = sum;
        }
    }

    auto end_precompute = std::chrono::high_resolution_clock::now();
    std::cout << "Precompute time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end_precompute - start_precompute).count()
              << " ms" << std::endl;
    std::cout << "DONE PRECOMPUTE\n Start computing matrix element" << std::endl;

    auto start_compute = std::chrono::high_resolution_clock::now();

    const std::vector<Vertex>& list_vertices = m_list_BZ_states[0]->get_list_vertices();

    for (int idx_n2 = 0; idx_n2 < nb_valence_bands; ++idx_n2) {
        for (int idx_n1_prime = 0; idx_n1_prime < nb_conduction_bands; ++idx_n1_prime) {
            std::size_t n1_prime = idx_n1_prime + min_conduction_band;
            for (int idx_n2_prime = 0; idx_n2_prime < nb_conduction_bands; ++idx_n2_prime) {
                std::size_t n2_prime = idx_n2_prime + min_conduction_band;
                for (std::size_t idx_k1_prime = 0; idx_k1_prime < nb_vtx; ++idx_k1_prime) {
                    std::cout << "idx_n1: " << idx_n1 << " idx_n1_prime: " << idx_n1_prime << " idx_n2: " << idx_n2
                              << " idx_n2_prime: " << idx_n2_prime << " idx_k1: " << idx_k1 << " idx_k1_prime: " << idx_k1_prime
                              << std::endl;
                    std::vector<double> FullMatrixElement(nb_vtx);
                    for (std::size_t idx_k2_prime = 0; idx_k2_prime < nb_vtx; ++idx_k2_prime) {
                        // std::cout << "\r" << idx_k1_prime << " / " << nb_vtx << " --> " << idx_k2_prime << " / " << nb_vtx << std::flush;
                        vector3 k_2_momentum = list_vertices[idx_k1].get_position() - list_vertices[idx_k1_prime].get_position() -
                                               list_vertices[idx_k2_prime].get_position();
                        if (k_2_momentum.norm() > m_max_radius_G0_BZ || k_2_momentum.norm() < 1e-12) {
                            continue;
                        }
                        std::size_t idx_k2 = 18;
                        complex_d   Ma =
                            Sum_2_prime[idx_n2_prime][idx_k2_prime] * Sum_1_prime_1[idx_n1_prime][idx_k1_prime] * Sum_2[idx_n2][idx_k2];
                        complex_d Mb =
                            Sum_2_prime[idx_n1_prime][idx_k1_prime] * Sum_1_prime_1[idx_n2_prime][idx_k2_prime] * Sum_2[idx_n2][idx_k2];
                        FullMatrixElement[idx_k2_prime] =
                            std::abs(Ma) * std::abs(Ma) + std::abs(Mb) * std::abs(Mb) + std::abs(Ma - Mb) * std::abs(Ma - Mb);
                    }
                }
            }
        }
    }
    std::cout << std::endl;
    auto end_compute = std::chrono::high_resolution_clock::now();
    std::cout << "Compute time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end_compute - start_compute).count() << " ms"
              << std::endl;
    return 0.0;
}

}  // namespace bz_mesh/**
 * @file bz_dielectric.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>

#include "Material.h"
#include "bz_mesh.hpp"

namespace bz_mesh {

class BZ_States : public MeshBZ {
 protected:
    int m_nb_bands = 0;

    std::vector<Vector3D<int>> m_basisVectors;

    std::vector<Eigen::VectorXd> m_eigenvalues_k;
    std::vector<Eigen::VectorXd> m_eigenvalues_k_plus_q;

    std::vector<Eigen::MatrixXcd> m_eigenvectors_k;
    std::vector<Eigen::MatrixXcd> m_eigenvectors_k_plus_q;

    Vector3D<double>    m_q_shift;
    std::vector<double> m_list_energies;

    /**
     * @brief Real part of the dielectric function.
     * m_dielectric_function_real[idx_energy] is the real part of the dielectric function at the energy m_energies[idx_energy].
     *
     */
    std::vector<double> m_dielectric_function_real;

    // m_vtx_dielectric_function_real[idx_vtx][idx_energy] is the real part of the dielectric function at the energy m_energies[idx_energy]
    // and at the vertex m_vertices[idx_vtx].
    std::vector<std::vector<double>> m_vtx_dielectric_function_real;

    /**
     * @brief The index of the first q-point this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the q-points of the mesh.
     *
     * For a calculation on a single CPU the offset is 0.
     *
     */
    std::size_t m_offset_q_index = 0;

    /**
     * @brief Number of q-points this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the q-points.
     *
     * For a calculation on a single CPU this parameter is equal to the size of the m_vertices.size().
     *
     */
    std::size_t m_nb_kpoints = 0;

 public:
    BZ_States(const EmpiricalPseudopotential::Material& material) : MeshBZ(material) {}
    BZ_States(const BZ_States& other) = default;

    void                              set_nb_bands(int nb_bands) { m_nb_bands = nb_bands; }
    void                              set_basis_vectors(const std::vector<Vector3D<int>>& basis_vectors) { m_basisVectors = basis_vectors; }
    const std::vector<Vector3D<int>>& get_basis_vectors() const { return m_basisVectors; }
    void                              compute_eigenstates(int nb_threads = 1);
    void                              compute_shifted_eigenstates(const Vector3D<double>& q_shift, int nb_threads = 1);

    const std::vector<double>& get_energies() const { return m_list_energies; }
    void                       set_energies(const std::vector<double>& energies) { m_list_energies = energies; }

    const std::vector<Eigen::MatrixXcd>& get_eigen_states() const { return m_eigenvectors_k; }

    void compute_dielectric_function(const std::vector<double>& energies, double eta_smearing, int nb_threads = 1);
    void export_dielectric_function(const std::string& prefix) const;

    void populate_vtx_dielectric_function(const std::vector<double>& energies, double eta_smearing);

    std::complex<double> get_dielectric_function(const vector3& q, double energy) const {
        // TODO: implement this function
        return 1.0;
    }

    void export_full_eigenstates() const;
};

}  // namespace bz_mesh/**
 * @file elelectron_phonon.cpp
 * @brief Electron–phonon implementation (matches refactored header: m_phonon_dispersion[4], RateValues::add)
 * @date 2024-02-09
 */

#include "electron_phonon.hpp"

#include <Eigen/Dense>
#include <array>
#include <atomic>
#include <cassert>
#include <cmath>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <random>
#include <sstream>
#include <tuple>
#include <vector>

#include "Constants.hpp"
#include "Vector3D.h"
#include "bz_states.hpp"
#include "gmsh.h"
#include "omp.h"
#include "yaml-cpp/yaml.h"

namespace bz_mesh {

// ----- OpenMP custom reduction for std::array<double,8> -----
static inline void arr8_add(std::array<double, 8>& __restrict out, const std::array<double, 8>& __restrict in) noexcept {
    for (int i = 0; i < 8; ++i)
        out[i] += in[i];
}
#pragma omp declare reduction(merge : std::array<double, 8> : arr8_add(omp_out, omp_in)) initializer(omp_priv = std::array<double, 8>{})

// -------------------- Small inline helpers --------------------

inline double ElectronPhonon::bose_einstein_distribution(double energy_eV, double temperature_K) const {
    // N0 = 1 / (exp(E / kT) - 1)
    const double x = energy_eV / (EmpiricalPseudopotential::Constants::k_b_eV * temperature_K);
    return 1.0 / std::expm1(x);  // stable for small x
}

inline double ElectronPhonon::electron_overlap_integral(const vector3& k1, const vector3& k2) const {
    // Spherical j1-like: 3 (sin x - x cos x)/x^3 with x = |k1-k2| * R_WS
    constexpr double R_Wigner_Seitz = 2.122e-10;  // m
    const double     x              = (k1 - k2).norm() * R_Wigner_Seitz;

    if (std::abs(x) < 1e-6) {
        const double x2 = x * x;
        return 1.0 - 0.1 * x2;  // 1 - x^2/10 + O(x^4)
    }
    return 3.0 * (std::sin(x) - x * std::cos(x)) / (x * x * x);
}

inline double ElectronPhonon::hole_overlap_integral(int n1, const vector3& k1, int n2, const vector3& k2) const {
    const double cos_angle_k1_k2   = compute_cos_angle(k1, k2);
    const double cos_angle_k1_k2_2 = cos_angle_k1_k2 * cos_angle_k1_k2;
    auto         A_B_params        = m_hole_overlap_int_params.get_params(n1, n2);
    double       integral          = 0.5 * std::sqrt(A_B_params[0] + A_B_params[1] * cos_angle_k1_k2_2);
    return integral;
}

inline double ElectronPhonon::get_max_phonon_energy() const {
    double max_energy = std::numeric_limits<double>::lowest();
    for (const auto& disp : m_phonon_dispersion) {
        double max_w = disp.max_omega();  // ω_max [1/s]
        if (max_w > max_energy) max_energy = max_w;
    }
    return max_energy * EmpiricalPseudopotential::Constants::h_bar_eV;  // ħω → eV
}

/**
 * @brief Transport weight factor 1 - cos(θ) where θ is the angle between v0 and v1, the group velocities.
 *
 * @param v0
 * @param v1
 * @return double
 */
inline double ElectronPhonon::transport_weight_RTA(const vector3& v0, const vector3& v1) {
    const double norm_v0 = v0.norm_squared();
    const double norm_v1 = v1.norm_squared();
    if (norm_v0 < 1e-24 || norm_v1 < 1e-24) return 1.0;  // degeneracy/edge guard
    double cos_theta = v0.dot(v1) / std::sqrt(norm_v0 * norm_v1);
    if (cos_theta > 1.0) cos_theta = 1.0;
    if (cos_theta < -1.0) cos_theta = -1.0;
    return 1.0 - cos_theta;  // = 1 - cos θ
}

// --- Pairwise kernel: one (n1,k1) → (n2, bary(t)) transition, returns 8 channels ---
// Uses tetra barycenter for k2 and your DOS(Ef) per band at that tetra.
Rate8 ElectronPhonon::compute_transition_rates_pair(int         idx_n1,
                                                    std::size_t idx_k1,
                                                    int         idx_n2,
                                                    std::size_t idx_t /* tetra index */,
                                                    bool        push_nk_npkp /* optional sparse fill */) {
    Rate8 out{};

    const auto& vtx1  = m_list_vertices[idx_k1];
    const auto& tetra = m_list_tetrahedra[idx_t];

    const double  Ei_eV = vtx1.get_energy_at_band(idx_n1);
    const vector3 k1    = vtx1.get_position();
    const vector3 k2    = tetra.compute_barycenter();

    // Overlap once
    const double I  = electron_overlap_integral(k1, k2);
    const double I2 = I * I;

    // q = k2 - k1, fold to 1st BZ if needed (normal processes only)
    vector3 q = k2 - k1;
    if (!is_inside_mesh_geometry(q)) q = retrieve_k_inside_mesh_geometry(q);
    if (!is_inside_mesh_geometry(q)) return out;  // nothing to do

    const double qn = q.norm();

    // Row/col for optional sparse insert (compact conduction indexing assumed)
    Eigen::Index Nk = static_cast<Eigen::Index>(m_list_vertices.size());
    Eigen::Index Nt = static_cast<Eigen::Index>(m_list_tetrahedra.size());

    // If you compact bands for matrices, map full band → compact band index
    auto band_to_comp = [&](int n) -> int {
        auto it = std::find(m_indices_conduction_bands.begin(), m_indices_conduction_bands.end(), n);
        return (it == m_indices_conduction_bands.end()) ? -1 : int(it - m_indices_conduction_bands.begin());
    };
    const int          n1c = band_to_comp(idx_n1);
    const int          n2c = band_to_comp(idx_n2);
    const Eigen::Index row = (n1c >= 0) ? (Eigen::Index)n1c * Nk + (Eigen::Index)idx_k1 : -1;
    const Eigen::Index col = (n2c >= 0) ? (Eigen::Index)n2c * Nt + (Eigen::Index)idx_t : -1;

    constexpr double SMALL_OMEGA_CUTOFF = 1.0;  // [1/s]
    const double     pi                 = EmpiricalPseudopotential::Constants::pi;
    const double     qe                 = EmpiricalPseudopotential::Constants::q_e;       // J/eV
    const double     hbar_eV            = EmpiricalPseudopotential::Constants::h_bar_eV;  // eV·s

    double       inv_mrta_rate          = 0.0;
    vector3      vnk                    = vtx1.get_energy_gradient_at_band(idx_n1) * (1.0 / hbar_eV);   // m/s
    vector3      v_npkp                 = tetra.get_gradient_energy_at_band(idx_n2) * (1.0 / hbar_eV);  // m/s
    const double transport_weight_value = this->transport_weight_RTA(vnk, v_npkp);

    // Loop 4 branches: md=0..3 → (ac/op)×(L/T)
    for (int md = 0; md < 4; ++md) {
        const auto&           disp = m_phonon_dispersion[md];
        const PhononMode      mode = ((md >> 1) == 0) ? PhononMode::acoustic : PhononMode::optical;
        const PhononDirection dir  = ((md & 1) == 0) ? PhononDirection::longitudinal : PhononDirection::transverse;

        // ω(|q|) [1/s] — use your lookup or analytic
        const double omega = disp.omega_lookup(qn);
        if (omega <= SMALL_OMEGA_CUTOFF) continue;

        const double Eph_eV = hbar_eV * omega;
        const double N0     = bose_einstein_distribution(Eph_eV, m_temperature);

        // Deformation potential (J)
        const DeformationPotential& defpot  = (mode == PhononMode::acoustic) ? m_ac_defpot_e : m_op_defpot_e;
        const double                Delta_J = defpot.get_fischetti_deformation_potential(q, idx_n1) * qe;

        // Common prefactor
        const double pref = (pi / (m_rho * omega)) * (Delta_J * Delta_J) * I2 / m_reduce_bz_factor * m_spin_degeneracy;

        // --- Emission (Ef = Ei - ħω), bose = N0 + 1 ---
        {
            const double Ef_eV = Ei_eV - Eph_eV;
            if (tetra.is_energy_inside_band(Ef_eV, idx_n2)) {
                const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                if (dos_eV > 0.0) {
                    const double val = pref * (N0 + 1.0) * (dos_eV / qe);
                    const int    b   = rate_index(mode, dir, PhononEvent::emission);
                    out[static_cast<std::size_t>(b)] += val;
                    inv_mrta_rate += val * transport_weight_value;  // for 1/τ_tr
                }
            }
        }
        // --- Absorption (Ef = Ei + ħω), bose = N0 ---
        {
            const double Ef_eV = Ei_eV + Eph_eV;
            if (tetra.is_energy_inside_band(Ef_eV, idx_n2)) {
                const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                if (dos_eV > 0.0) {
                    const double val = pref * (N0) * (dos_eV / qe);
                    const int    b   = rate_index(mode, dir, PhononEvent::absorption);
                    out[static_cast<std::size_t>(b)] += val;
                    inv_mrta_rate += val * transport_weight_value;  // for 1/τ_tr
                }
            }
        }
    }
    m_phonon_rates_transport[idx_n1][idx_k1] += inv_mrta_rate;  // accumulate 1/τ_tr(E) on uniform grid
    return out;
}

RateValues ElectronPhonon::compute_electron_phonon_rate(int idx_n1, std::size_t idx_k1, bool populate_nk_npkp) {
    RateValues acc;

    const double Ei_eV   = m_list_vertices[idx_k1].get_energy_at_band(idx_n1);
    const double Eph_max = get_max_phonon_energy();
    const double Ef_min  = Ei_eV - Eph_max;
    const double Ef_max  = Ei_eV + Eph_max;

    std::size_t nnz = 0;

    for (int idx_n2 : m_indices_conduction_bands) {
        // Quick reject band window
        if (Ef_min > m_max_band[idx_n2] || Ef_max < m_min_band[idx_n2]) continue;

        for (std::size_t t = 0; t < m_list_tetrahedra.size(); ++t) {
            const auto& tetra = m_list_tetrahedra[t];
            if (!tetra.does_intersect_band_energy_range(Ef_min, Ef_max, idx_n2)) continue;

            const Rate8 r = compute_transition_rates_pair(idx_n1, idx_k1, idx_n2, t, /*push=*/populate_nk_npkp);
            nnz += (r != Rate8{});  // count non-zero contributions
            for (int i = 0; i < 8; ++i)
                acc.v[i] += r[i];
        }
    }
    // std::cout << "Computed rates for (n,k)=(" << idx_n1 << "," << idx_k1 << ") Ei=" << std::setprecision(6) << Ei_eV
    //           << " eV, non-zero contributions: " << nnz << " / " << m_indices_conduction_bands.size() * m_list_tetrahedra.size() << " = "
    //           << (100.0 * nnz / (m_indices_conduction_bands.size() * m_list_tetrahedra.size())) << "%\n";
    return acc;
}

// -------------------- Hole rates --------------------

RateValues ElectronPhonon::compute_hole_phonon_rate(int idx_n1, std::size_t idx_k1) {
    RateValues  rates_k1_n1;
    const auto& list_tetrahedra       = m_list_tetrahedra;
    const auto& indices_valence_bands = m_indices_valence_bands;

    const double  Ei_eV = m_list_vertices[idx_k1].get_energy_at_band(idx_n1);
    const vector3 k1    = m_list_vertices[idx_k1].get_position();

    constexpr double SMALL_OMEGA_CUTOFF = 1.0;

    for (int idx_n2 : indices_valence_bands) {
        for (const auto& tetra : list_tetrahedra) {
            const vector3 k2 = tetra.compute_barycenter();

            const double overlap  = hole_overlap_integral(idx_n1, k1, idx_n2, k2);
            const double overlap2 = overlap * overlap;

            vector3 q = k2 - k1;
            if (!is_inside_mesh_geometry(q)) q = retrieve_k_inside_mesh_geometry(q);
            if (!is_inside_mesh_geometry(q)) continue;

            const double q_norm = q.norm();

            for (int md = 0; md < 4; ++md) {
                const auto&           disp = m_phonon_dispersion[md];
                const PhononMode      mode = (md < 2) ? PhononMode::acoustic : PhononMode::optical;
                const PhononDirection dir  = (md & 1) ? PhononDirection::transverse : PhononDirection::longitudinal;

                const double omega = disp.omega_lookup(q_norm);
                if (omega <= SMALL_OMEGA_CUTOFF) continue;

                const double Eph_eV = EmpiricalPseudopotential::Constants::h_bar_eV * omega;
                const double N0     = bose_einstein_distribution(Eph_eV, m_temperature);

                const DeformationPotential& defpot = (mode == PhononMode::acoustic) ? m_ac_defpot_h : m_op_defpot_h;
                const double Delta_J = defpot.get_fischetti_deformation_potential(q, idx_n1) * EmpiricalPseudopotential::Constants::q_e;

                // Emission
                {
                    const double Ef_eV  = Ei_eV - Eph_eV;
                    const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                    if (dos_eV > 0.0) {
                        const double dos_per_J = dos_eV / EmpiricalPseudopotential::Constants::q_e;
                        double rate_value = (EmpiricalPseudopotential::Constants::pi / (m_rho * omega)) * (Delta_J * Delta_J) * overlap2 *
                                            (N0 + 1.0) * dos_per_J;
                        rate_value /= m_reduce_bz_factor;
                        rate_value *= m_spin_degeneracy;

                        rates_k1_n1.add(mode, dir, PhononEvent::emission, rate_value);
                    }
                }
                // Absorption
                {
                    const double Ef_eV  = Ei_eV + Eph_eV;
                    const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                    if (dos_eV > 0.0) {
                        const double dos_per_J = dos_eV / EmpiricalPseudopotential::Constants::q_e;
                        double       rate_value =
                            (EmpiricalPseudopotential::Constants::pi / (m_rho * omega)) * (Delta_J * Delta_J) * overlap2 * (N0)*dos_per_J;
                        rate_value /= m_reduce_bz_factor;
                        rate_value *= m_spin_degeneracy;

                        rates_k1_n1.add(mode, dir, PhononEvent::absorption, rate_value);
                    }
                }
            }  // md
        }  // tetra
    }  // bands

    return rates_k1_n1;
}

// -------------------- Mesh sweeps & exporters --------------------

void ElectronPhonon::compute_electron_phonon_rates_over_mesh(double energy_max, bool irreducible_wedge_only, bool populate_nk_npkp) {
    auto indices_conduction_bands = m_indices_conduction_bands;
    auto min_idx_conduction_band  = *std::min_element(indices_conduction_bands.begin(), indices_conduction_bands.end());
    auto max_idx_conduction_band  = *std::max_element(indices_conduction_bands.begin(), indices_conduction_bands.end());

    std::cout << "Min index conduction band: " << min_idx_conduction_band << "\n";
    std::cout << "Max index conduction band: " << max_idx_conduction_band << "\n";
    std::cout << "Computing electron-phonon rates over mesh for " << m_list_vertices.size() << " k-points.\n";

    // --- Decide band set for rows/cols (compact conduction example) ---
    const std::vector<int>& rows_bands = m_indices_conduction_bands;  // (n,k)
    const std::vector<int>& cols_bands = m_indices_conduction_bands;  // (n',k')

    if (populate_nk_npkp) {
        const std::size_t Nk      = m_list_vertices.size();
        const std::size_t Nt      = m_list_tetrahedra.size();
        const int         Nb_rows = static_cast<int>(rows_bands.size());
        const int         Nb_cols = static_cast<int>(cols_bands.size());

        const Eigen::Index nrows = static_cast<Eigen::Index>(static_cast<std::size_t>(Nb_rows) * Nk);
        const Eigen::Index ncols = static_cast<Eigen::Index>(static_cast<std::size_t>(Nb_cols) * Nt);
        std::cout << "Matrix size: " << nrows << " x " << ncols << " (" << (nrows * ncols) << " elements)\n";
        constexpr double percentage_reserve = 0.01;  // 1% of elements
        std::cout << "Reserving " << (nrows * ncols * percentage_reserve) << " elements per matrix.\n";

        m_rates_nk_npkp.clear();
        m_rates_nk_npkp.resize(8);  // indices 0..7 must equal rate_index(m,d,e)

        Eigen::VectorXi reserve_vec(nrows);
        reserve_vec.setConstant(std::max<Eigen::Index>(1, static_cast<Eigen::Index>(percentage_reserve * Nb_cols * Nt)));

        for (int M = 0; M < 2; ++M) {
            const PhononMode m = (M == 0) ? PhononMode::acoustic : PhononMode::optical;
            for (int D = 0; D < 2; ++D) {
                const PhononDirection d = (D == 0) ? PhononDirection::longitudinal : PhononDirection::transverse;
                for (int E = 0; E < 2; ++E) {
                    const PhononEvent e   = (E == 0) ? PhononEvent::absorption : PhononEvent::emission;  // matches your enum
                    const int         idx = rate_index(m, d, e);                                         // (M<<2)|(D<<1)|E  → [0..7]

                    Rates_nk_npkp_ctor R;
                    R.mode      = m;
                    R.direction = d;
                    R.event     = e;
                    R.matrix.resize(nrows, ncols);
                    R.matrix.reserve(reserve_vec);

                    m_rates_nk_npkp[idx] = std::move(R);
                }
            }
        }
    }  // if populate_nk_npkp

    std::cout << "Progress: 0%";
    std::atomic<std::size_t> counter{0};
    constexpr int            chunk_size = 32;

    m_phonon_rates_transport.clear();
    m_phonon_rates_transport.resize(static_cast<std::size_t>(m_indices_conduction_bands.size()));
    for (auto& vec : m_phonon_rates_transport) {
        vec.resize(m_list_vertices.size(), 0.0);
    }
    // Create a shuffled list of indices to balance load when using irreducible wedge only
    std::vector<std::size_t> random_indices(m_list_vertices.size());
    for (std::size_t i = 0; i < m_list_vertices.size(); ++i)
        random_indices[i] = i;
    if (irreducible_wedge_only) {
        constexpr int seed = 0;
        std::mt19937  g(seed);
        std::shuffle(random_indices.begin(), random_indices.end(), g);
    }

#pragma omp parallel for schedule(dynamic, chunk_size) num_threads(m_nb_threads)
    for (std::size_t idx = 0; idx < m_list_vertices.size(); ++idx) {
        // Use random index if irreducible wedge only
        const std::size_t idx_k1 = irreducible_wedge_only ? random_indices[idx] : idx;
        const bool        to_compute =
            (!irreducible_wedge_only) || (irreducible_wedge_only && is_irreducible_wedge(m_list_vertices[idx_k1].get_position()));

        const auto done = ++counter;
        if (omp_get_thread_num() == 0) {
            std::cout << "\rDone " << done << "/" << m_list_vertices.size() << " (" << std::fixed << std::setprecision(1)
                      << (100.0 * done / m_list_vertices.size()) << "%)" << std::flush;
        }

        // Valence bands (holes)
        for (std::size_t idx_n1 = 0; idx_n1 < static_cast<std::size_t>(min_idx_conduction_band); ++idx_n1) {
            if (!to_compute) continue;
            auto hole_rate = compute_hole_phonon_rate(static_cast<int>(idx_n1), idx_k1);
            (void)hole_rate;  // attach to vertices if/when needed
            // m_list_vertices[idx_k1].add_electron_phonon_rates(hole_rate.as_array());
        }

        // Conduction bands (electrons)
        for (std::size_t idx_n1 = static_cast<std::size_t>(min_idx_conduction_band);
             idx_n1 <= static_cast<std::size_t>(max_idx_conduction_band);
             ++idx_n1) {
            if (!to_compute) continue;

            if (m_list_vertices[idx_k1].get_energy_at_band(static_cast<int>(idx_n1)) > energy_max) {
                m_list_vertices[idx_k1].add_electron_phonon_rates(std::array<double, 8>{});
                continue;
            } else {
                auto rate = compute_electron_phonon_rate(static_cast<int>(idx_n1), idx_k1);
                m_list_vertices[idx_k1].add_electron_phonon_rates(rate.as_array());
            }
        }
    }

    std::cout << "\rComputed " << counter << " k-points out of " << m_list_vertices.size() << " (100%)\n";

    if (irreducible_wedge_only) {
        std::cout << "Set electron-phonon rates for all mesh vertices.\n";
#pragma omp parallel for schedule(dynamic) num_threads(m_nb_threads)
        for (std::size_t idx_k1 = 0; idx_k1 < m_list_vertices.size(); ++idx_k1) {
            if ((idx_k1 % 1000) == 0 && omp_get_thread_num() == 0) {
                std::cout << "\rSetting rates for all k-points: " << idx_k1 << "/" << m_list_vertices.size() << " (" << std::fixed
                          << std::setprecision(1) << (100.0 * idx_k1 / m_list_vertices.size()) << "%)" << std::flush;
            }
            if (!is_irreducible_wedge(m_list_vertices[idx_k1].get_position())) {
                std::size_t idx_k1_symm = get_index_irreducible_wedge(m_list_vertices[idx_k1].get_position());
                for (std::size_t idx_n1 = 0; idx_n1 <= static_cast<std::size_t>(max_idx_conduction_band); ++idx_n1) {
                    auto rates_symm = m_list_vertices[idx_k1_symm].get_electron_phonon_rates(idx_n1);
                    m_list_vertices[idx_k1].add_electron_phonon_rates(rates_symm);
                }
            }
        }
        std::cout << "\rSet rates for all k-points: " << m_list_vertices.size() << "/" << m_list_vertices.size() << " (100%)\n";
    }
}

void ElectronPhonon::compute_electron_phonon_rates_over_mesh_nk_npkp(bool irreducible_wedge_only) {
    auto indices_conduction_bands = m_indices_conduction_bands;
    auto min_idx_conduction_band  = *std::min_element(indices_conduction_bands.begin(), indices_conduction_bands.end());

    std::cout << "Min index conduction band: " << min_idx_conduction_band << "\n";
    std::cout << "Computing electron-phonon rates over mesh for " << m_list_vertices.size() << " k-points.\n";

    std::cout << "Progress: 0%";
    std::atomic<std::size_t> counter{0};

#pragma omp parallel for schedule(dynamic) num_threads(m_nb_threads)
    for (std::size_t idx_k1 = 0; idx_k1 < m_list_vertices.size(); ++idx_k1) {
        bool to_compute = is_irreducible_wedge(m_list_vertices[idx_k1].get_position()) && irreducible_wedge_only;

        auto done = ++counter;
        if ((done % 100) == 0 || (done == m_list_vertices.size() && omp_get_thread_num() == 0)) {
            std::cout << "\rDone " << done << "/" << m_list_vertices.size() << " (" << std::fixed << std::setprecision(1)
                      << (100.0 * done / m_list_vertices.size()) << "%)" << std::flush;
        }

        for (std::size_t idx_n1 = 0; idx_n1 < static_cast<std::size_t>(min_idx_conduction_band); ++idx_n1) {
            if (!to_compute) continue;
            (void)compute_hole_phonon_rate(static_cast<int>(idx_n1), idx_k1);
        }
    }
}

// -------------------- Sampling a final state --------------------

std::pair<int, std::size_t> ElectronPhonon::select_final_state(std::size_t     idx_band_initial,
                                                               std::size_t     idx_k_initial,
                                                               PhononMode      mode,
                                                               PhononDirection direction,
                                                               PhononEvent     event) const {
    using std::size_t;

    if (m_list_vertices.empty() || m_list_tetrahedra.empty()) throw std::runtime_error("select_final_state: empty mesh.");
    if (idx_k_initial >= m_list_vertices.size()) throw std::out_of_range("select_final_state: idx_k_initial OOB.");

    const int md = md_index(mode, direction);
    if (md < 0) throw std::runtime_error("select_final_state: invalid mode/direction.");
    const auto& disp = m_phonon_dispersion[md];  // ω(|q|) in s^-1

    // Initial state
    const double  Ei_eV = m_list_vertices[idx_k_initial].get_energy_at_band(static_cast<int>(idx_band_initial));
    const vector3 k1    = m_list_vertices[idx_k_initial].get_position();

    const double sign_ph = (event == PhononEvent::emission) ? -1.0 : +1.0;

    const size_t        nb_bands = m_list_vertices.front().get_number_bands();
    const size_t        nb_tetra = m_list_tetrahedra.size();
    std::vector<double> probs_flat(nb_bands * nb_tetra, 0.0);
    auto                P_ref = [&](int n2, size_t t) -> double& { return probs_flat[static_cast<size_t>(n2) * nb_tetra + t]; };

    const double pi      = EmpiricalPseudopotential::Constants::pi;
    const double qe      = EmpiricalPseudopotential::Constants::q_e;
    const double hbar_eV = EmpiricalPseudopotential::Constants::h_bar_eV;

    const double Eph_max_eV = get_max_phonon_energy();

    for (int n2 : m_indices_conduction_bands) {
        // Band window
        const double Ef_min = Ei_eV - Eph_max_eV;
        const double Ef_max = Ei_eV + Eph_max_eV;
        if (Ef_min > m_max_band[n2] || Ef_max < m_min_band[n2]) continue;

        for (size_t t = 0; t < nb_tetra; ++t) {
            const auto& tetra = m_list_tetrahedra[t];
            if (!tetra.does_intersect_band_energy_range(Ef_min, Ef_max, n2)) continue;

            const vector3 k2_bary = tetra.compute_barycenter();

            vector3 q = k2_bary - k1;
            if (!is_inside_mesh_geometry(q)) q = retrieve_k_inside_mesh_geometry(q);
            if (!is_inside_mesh_geometry(q)) continue;

            const double qn    = q.norm();
            const double omega = disp.omega_lookup(qn);
            if (!(omega > 0.0) || omega < 1e-12) continue;

            const double Eph_eV = hbar_eV * omega;
            const double N0     = bose_einstein_distribution(Eph_eV, m_temperature);
            const double bose   = (sign_ph < 0.0) ? (N0 + 1.0) : N0;

            const double Ef_eV  = Ei_eV + sign_ph * Eph_eV;
            const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(n2));
            if (dos_eV <= 0.0) continue;

            const double dos_per_J = dos_eV / qe;

            const double I  = electron_overlap_integral(k1, k2_bary);
            const double I2 = I * I;

            const DeformationPotential& defpot  = (mode == PhononMode::acoustic) ? m_ac_defpot_e : m_op_defpot_e;
            const double                Delta_J = defpot.get_fischetti_deformation_potential(q, static_cast<int>(idx_band_initial)) * qe;

            double P = (pi / (m_rho * omega)) * (Delta_J * Delta_J) * I2 * bose * dos_per_J;
            P /= m_reduce_bz_factor;
            P *= m_spin_degeneracy;

            if (P > 0.0 && std::isfinite(P)) P_ref(n2, t) = P;
        }
    }

    double total = 0.0;
    for (double p : probs_flat)
        total += p;
    if (!(total > 0.0) || !std::isfinite(total))
        throw std::runtime_error("select_final_state: no admissible final states (total probability = 0).");

    // Thread-local RNG
    thread_local std::mt19937_64           rng([] {
        std::random_device rd;
        auto               s1 = static_cast<uint64_t>(rd());
        auto               s2 = static_cast<uint64_t>(rd());
        return (s1 << 32) ^ s2;
    }());
    std::uniform_real_distribution<double> U(0.0, 1.0);
    const double                           threshold = U(rng) * total;

    double acc = 0.0;
    for (size_t flat = 0; flat < probs_flat.size(); ++flat) {
        acc += probs_flat[flat];
        if (acc >= threshold) {
            const int    n2 = static_cast<int>(flat / nb_tetra);
            const size_t t  = static_cast<size_t>(flat % nb_tetra);
            return {n2, t};  // band, tetra index (k' = barycenter(t))
        }
    }
    // Fallback: last positive
    for (size_t flat = probs_flat.size(); flat-- > 0;) {
        if (probs_flat[flat] > 0.0) {
            const int    n2 = static_cast<int>(flat / nb_tetra);
            const size_t t  = static_cast<size_t>(flat % nb_tetra);
            return {n2, t};
        }
    }
    throw std::runtime_error("select_final_state: internal sampling error.");
}

// -------------------- Energy sweep exporter --------------------

void ElectronPhonon::compute_plot_electron_phonon_rates_vs_energy_over_mesh(int                nb_bands,
                                                                            double             max_energy,
                                                                            double             energy_step,
                                                                            const std::string& filename,
                                                                            bool /*irreducible_wedge_only*/) {
    if (energy_step <= 0.0) throw std::invalid_argument("energy_step must be > 0");
    if (max_energy < 0.0) throw std::invalid_argument("max_energy must be >= 0");

    if (m_list_vertices.empty()) throw std::runtime_error("No vertices in mesh.");
    const int total_bands = static_cast<int>(m_list_vertices.front().get_number_bands());
    if (total_bands <= 0) throw std::runtime_error("Mesh reports zero bands.");

    nb_bands = std::clamp(nb_bands, 0, total_bands);
    if (nb_bands == 0) throw std::runtime_error("nb_bands clamped to 0; nothing to process.");

    std::ofstream out(filename);
    if (!out) throw std::runtime_error("Cannot open " + filename + " for writing.");

    static constexpr std::array<const char*, 8>
        kLabels{"ac_L_ab", "ac_T_ab", "op_L_ab", "op_T_ab", "ac_L_em", "ac_T_em", "op_L_em", "op_T_em"};

    out << "# E[eV],DOS(E)";
    for (auto* s : kLabels)
        out << ',' << s;
    out << '\n';

    const std::size_t n_steps = static_cast<std::size_t>(std::floor(max_energy / energy_step)) + 1;

    for (std::size_t istep = 0; istep < n_steps; ++istep) {
        const double E = std::min(max_energy, istep * energy_step);
        std::cout << "\rEnergy: " << E << " / " << max_energy << std::flush;

        double                dos_sum = 0.0;
        std::array<double, 8> num{};  // accumulators
        num.fill(0.0);

        for (const auto& tetra : m_list_tetrahedra) {
            for (int b = 0; b < nb_bands; ++b) {
                const double dos_t = tetra.compute_tetra_dos_energy_band(E, static_cast<std::size_t>(b));
                if (!std::isfinite(dos_t))
                    throw std::runtime_error("DOS is NaN/Inf at E=" + std::to_string(E) + " band=" + std::to_string(b));
                if (dos_t <= 0.0) continue;

                dos_sum += dos_t;

                const std::array<double, 8> rates = tetra.get_tetra_electron_phonon_rates(static_cast<std::size_t>(b));
                for (int i = 0; i < 8; ++i) {
                    num[i] += rates[i] * dos_t;
                }
            }
        }

        std::array<double, 8> mean{};
        if (dos_sum > 0.0) {
            const double inv_dos = 1.0 / dos_sum;
            for (int i = 0; i < 8; ++i)
                mean[i] = num[i] * inv_dos;
        } else {
            mean.fill(0.0);
        }

        out << std::scientific << std::setprecision(10) << E << ',' << dos_sum;
        for (double v : mean)
            out << ',' << v;
        out << '\n';
    }

    std::cout << std::endl;
    out.close();
}

/**
 * @brief Interpolate the phonon scattering rate at a given location for a given band.
 *
 * @param location
 * @param idx_band
 * @return Rate8
 */
Rate8 ElectronPhonon::interpolate_phonon_scattering_rate_at_location(const vector3& location, const std::size_t& idx_band) const {
    // Find the tetrahedron containing the location
    const Tetra* tetra = find_tetra_at_location(location);
    if (!tetra) {
        throw std::runtime_error("Location is not inside any tetrahedron");
    }

    // Get the vertex indices of the tetrahedron
    const auto& vertex_indices = tetra->get_index_vertices_with_sorted_energy_at_band(idx_band);

    // Interpolate the scattering rates at the vertices
    Rate8            rates;
    constexpr double inv_num_vertices = 1.0 / 4.0;
    for (std::size_t i = 0; i < vertex_indices.size(); ++i) {
        const auto& vertex = m_list_vertices[vertex_indices[i]];
        for (std::size_t idx_mode = 0; idx_mode < rates.size(); ++idx_mode) {
            rates[idx_mode] += m_list_phonon_scattering_rates[vertex.get_index()][idx_band][idx_mode];
        }
    }
    for (std::size_t idx_mode = 0; idx_mode < rates.size(); ++idx_mode) {
        rates[idx_mode] *= inv_num_vertices;
    }
    return rates;
}

// -------------------- Phonon dispersion dump --------------------

void ElectronPhonon::plot_phonon_dispersion(const std::string& filename) const {
    std::ofstream file(filename);
    for (auto&& vtx : m_list_vertices) {
        auto k = vtx.get_position();
        file << k.x() << " " << k.y() << " " << k.z() << " ";
        for (int md = 0; md < 4; ++md) {
            auto q = k;
            q /= m_material.get_fourier_factor();
            const auto&  disp = m_phonon_dispersion[md];
            const double e_ph = disp.omega_lookup(q.norm()) * EmpiricalPseudopotential::Constants::h_bar_eV;
            file << e_ph << " ";
        }
        file << '\n';
    }
}

// -------------------- Gmsh export --------------------

void ElectronPhonon::add_electron_phonon_rates_to_mesh(const std::string& initial_filename, const std::string& final_filename) {
    // If the file exists, remove it to avoid appending to an old file
    if (std::ifstream(final_filename)) {
        std::remove(final_filename.c_str());
    }

    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::model::add("bz_mesh");
    gmsh::open(initial_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);

    std::vector<std::size_t> node_tags;
    std::vector<double>      nodeCoords;
    std::vector<double>      nodeParams;
    gmsh::model::mesh::reclassifyNodes();
    gmsh::model::mesh::getNodes(node_tags, nodeCoords, nodeParams, -1, -1, false, false);

    auto indices_conduction_bands = m_indices_conduction_bands;
    auto max_idx_conduction_band  = *std::max_element(indices_conduction_bands.begin(), indices_conduction_bands.end());
    int  nb_bands                 = static_cast<int>(m_indices_conduction_bands.size() + m_indices_valence_bands.size());

    for (int idx_val_band = 0; idx_val_band < max_idx_conduction_band; ++idx_val_band) {
        std::vector<double> rates_ac_lo_em(m_list_vertices.size());
        std::vector<double> rates_ac_lo_ab(m_list_vertices.size());
        std::vector<double> rates_ac_tr_em(m_list_vertices.size());
        std::vector<double> rates_ac_tr_ab(m_list_vertices.size());
        std::vector<double> rates_opt_lo_em(m_list_vertices.size());
        std::vector<double> rates_opt_lo_ab(m_list_vertices.size());
        std::vector<double> rates_opt_tr_em(m_list_vertices.size());
        std::vector<double> rates_opt_tr_ab(m_list_vertices.size());

        for (std::size_t idx_k1 = 0; idx_k1 < m_list_vertices.size(); ++idx_k1) {
            auto rates              = m_list_vertices[idx_k1].get_electron_phonon_rates(static_cast<std::size_t>(idx_val_band));
            rates_ac_lo_em[idx_k1]  = rates[0];
            rates_ac_lo_ab[idx_k1]  = rates[1];
            rates_ac_tr_em[idx_k1]  = rates[2];
            rates_ac_tr_ab[idx_k1]  = rates[3];
            rates_opt_lo_em[idx_k1] = rates[4];
            rates_opt_lo_ab[idx_k1] = rates[5];
            rates_opt_tr_em[idx_k1] = rates[6];
            rates_opt_tr_ab[idx_k1] = rates[7];
        }

        std::string name_rate_ac_lo_em  = "ac_lo_em_" + std::to_string(idx_val_band);
        std::string name_rate_ac_lo_ab  = "ac_lo_ab_" + std::to_string(idx_val_band);
        std::string name_rate_ac_tr_em  = "ac_tr_em_" + std::to_string(idx_val_band);
        std::string name_rate_ac_tr_ab  = "ac_tr_ab_" + std::to_string(idx_val_band);
        std::string name_rate_opt_lo_em = "opt_lo_em_" + std::to_string(idx_val_band);
        std::string name_rate_opt_lo_ab = "opt_lo_ab_" + std::to_string(idx_val_band);
        std::string name_rate_opt_tr_em = "opt_tr_em_" + std::to_string(idx_val_band);
        std::string name_rate_opt_tr_ab = "opt_tr_ab_" + std::to_string(idx_val_band);

        int data_tag_ac_lo_em  = gmsh::view::add(name_rate_ac_lo_em);
        int data_tag_ac_lo_ab  = gmsh::view::add(name_rate_ac_lo_ab);
        int data_tag_ac_tr_em  = gmsh::view::add(name_rate_ac_tr_em);
        int data_tag_ac_tr_ab  = gmsh::view::add(name_rate_ac_tr_ab);
        int data_tag_opt_lo_em = gmsh::view::add(name_rate_opt_lo_em);
        int data_tag_opt_lo_ab = gmsh::view::add(name_rate_opt_lo_ab);
        int data_tag_opt_tr_em = gmsh::view::add(name_rate_opt_tr_em);
        int data_tag_opt_tr_ab = gmsh::view::add(name_rate_opt_tr_ab);

        gmsh::view::addHomogeneousModelData(data_tag_ac_lo_em, 0, model_file_name, "NodeData", node_tags, rates_ac_lo_em);
        gmsh::view::addHomogeneousModelData(data_tag_ac_lo_ab, 0, model_file_name, "NodeData", node_tags, rates_ac_lo_ab);
        gmsh::view::addHomogeneousModelData(data_tag_ac_tr_em, 0, model_file_name, "NodeData", node_tags, rates_ac_tr_em);
        gmsh::view::addHomogeneousModelData(data_tag_ac_tr_ab, 0, model_file_name, "NodeData", node_tags, rates_ac_tr_ab);
        gmsh::view::addHomogeneousModelData(data_tag_opt_lo_em, 0, model_file_name, "NodeData", node_tags, rates_opt_lo_em);
        gmsh::view::addHomogeneousModelData(data_tag_opt_lo_ab, 0, model_file_name, "NodeData", node_tags, rates_opt_lo_ab);
        gmsh::view::addHomogeneousModelData(data_tag_opt_tr_em, 0, model_file_name, "NodeData", node_tags, rates_opt_tr_em);
        gmsh::view::addHomogeneousModelData(data_tag_opt_tr_ab, 0, model_file_name, "NodeData", node_tags, rates_opt_tr_ab);

        gmsh::option::setNumber("PostProcessing.SaveMesh", 1);  // Save mesh only once
        gmsh::view::write(data_tag_ac_lo_em, final_filename, true);
        gmsh::option::setNumber("PostProcessing.SaveMesh", 0);
        gmsh::view::write(data_tag_ac_lo_ab, final_filename, true);
        gmsh::view::write(data_tag_ac_tr_em, final_filename, true);
        gmsh::view::write(data_tag_ac_tr_ab, final_filename, true);
        gmsh::view::write(data_tag_opt_lo_em, final_filename, true);
        gmsh::view::write(data_tag_opt_lo_ab, final_filename, true);
        gmsh::view::write(data_tag_opt_tr_em, final_filename, true);
        gmsh::view::write(data_tag_opt_tr_ab, final_filename, true);
    }
    gmsh::finalize();
}

// -------------------- Load parameters (YAML) --------------------

void ElectronPhonon::load_phonon_parameters(const std::string& filename) {
    YAML::Node config = YAML::LoadFile(filename);
    if (config.IsNull()) {
        throw std::runtime_error("File " + filename + " is empty");
    }

    // std::cout << "File " << filename << " contains:\n" << config << std::endl;

    auto               list_materials = config["materials"];
    const std::string& my_material    = m_material.get_name();

    auto same_material = [&](const YAML::Node& node) { return node["name"].as<std::string>() == my_material; };
    auto it_material   = std::find_if(list_materials.begin(), list_materials.end(), same_material);
    if (it_material == list_materials.end()) {
        throw std::runtime_error("Material " + my_material + " not found in file " + filename);
    }
    auto material = *it_material;

    double radiusWS      = material["Radius-WS"].as<double>();
    m_radii_wigner_seitz = radiusWS;

    // Dispersion → m_phonon_dispersion[md]
    auto dispersion = material["dispersion"];
    for (const auto& type : {"longitudinal", "transverse"}) {
        auto dispType = dispersion[type];
        for (const auto& wave : {"acoustic", "optic"}) {
            auto   waveType = dispType[wave];
            double w0       = waveType["w0"].as<double>();
            double vs       = waveType["vs"].as<double>();
            double c        = waveType["c"].as<double>();
            // std::cout << "w0: " << w0 << " vs: " << vs << " c: " << c << std::endl;

            PhononDirection direction = (std::string(type) == "longitudinal") ? PhononDirection::longitudinal : PhononDirection::transverse;
            PhononMode      mode      = (std::string(wave) == "acoustic") ? PhononMode::acoustic : PhononMode::optical;

            PhononDispersion phononDispersion(mode, direction, w0, vs, c);
            double           q_max_norm = 1.5 / m_si2red;
            std::size_t      points     = 200;
            // std::cout << "Max q norm in reduced units: " << q_max_norm << std::endl;
            phononDispersion.build_lookup(q_max_norm, points);

            const int md = md_index(mode, direction);
            if (md < 0) throw std::runtime_error("load_phonon_parameters: bad mode/direction index.");
            m_phonon_dispersion[md] = std::move(phononDispersion);
        }
    }

    // Deformation potentials
    auto node_deformationPotential = material["deformation-potential"];
    for (const auto& carrierType : {"electron", "hole"}) {
        auto   carrier          = node_deformationPotential[carrierType];
        double energy_threshold = carrier["energy-threshold"].as<double>();
        for (const auto& wave : {"acoustic", "optic"}) {
            auto   waveType = carrier[wave];
            double A        = waveType["A"].as<double>();
            double B        = waveType["B"].as<double>();

            PhononMode           mode = (std::string(wave) == "acoustic") ? PhononMode::acoustic : PhononMode::optical;
            DeformationPotential deformationPotential(mode, A, B, energy_threshold);
            if (std::string(carrierType) == "electron") {
                if (mode == PhononMode::acoustic)
                    m_ac_defpot_e = deformationPotential;
                else
                    m_op_defpot_e = deformationPotential;
            } else {
                if (mode == PhononMode::acoustic)
                    m_ac_defpot_h = deformationPotential;
                else
                    m_op_defpot_h = deformationPotential;
            }
        }
    }
}

// -------------------- CSV import/export of rates --------------------

void ElectronPhonon::export_rate_values(const std::string& filename) const {
    std::ofstream file(filename);
    for (auto&& vertex : m_list_vertices) {
        std::vector<std::array<double, 8>> all_rates = vertex.get_electron_phonon_rates_all_bands();
        for (std::size_t idx_band = 0; idx_band < all_rates.size(); ++idx_band) {
            double energy = vertex.get_energy_at_band(idx_band);
            file << idx_band << "," << energy << ",";
            for (std::size_t idx_rate = 0; idx_rate < all_rates[idx_band].size(); ++idx_rate) {
                double rate = all_rates[idx_band][idx_rate];
                file << rate << ((idx_rate + 1 < all_rates[idx_band].size()) ? "," : "");
            }
            file << '\n';
        }
    }
    file.close();
}

void ElectronPhonon::read_phonon_scattering_rates_from_file(const std::filesystem::path& path) {
    std::cout << "Reading phonon scattering rates (CSV) from file " << path.string() << " ...\n";

    std::ifstream in(path);
    if (!in.is_open()) throw std::runtime_error("Could not open file " + path.string());

    m_list_phonon_scattering_rates.clear();
    m_list_phonon_scattering_rates.resize(m_list_vertices.size());

    std::string line;
    std::size_t line_no = 0;

    for (std::size_t idx_vtx = 0; idx_vtx < m_list_vertices.size(); ++idx_vtx) {
        const auto&       vertex   = m_list_vertices[idx_vtx];
        const std::size_t nbands   = vertex.get_number_bands();
        auto&             per_band = m_list_phonon_scattering_rates[idx_vtx];
        per_band.resize(nbands);

        for (std::size_t idx_band = 0; idx_band < nbands; ++idx_band) {
            do {
                if (!std::getline(in, line)) {
                    std::cout << "Line no: " << line_no << " " << line << std::endl;
                    throw std::runtime_error("Unexpected EOF at vertex " + std::to_string(idx_vtx) + ", band " + std::to_string(idx_band));
                }
                ++line_no;
            } while (line.empty() || line[0] == '#' || line[0] == ';');

            for (char& c : line)
                if (c == ',') c = ' ';
            std::istringstream iss(line);

            std::size_t band_idx_file{};
            double      energy_file{};
            Rate8       rates{};

            // Keep your CSV layout if you still emit ALO..ETA in this order elsewhere
            if (!(iss >> band_idx_file >> energy_file >> rates[0] >> rates[1] >> rates[2] >> rates[3] >> rates[4] >> rates[5] >> rates[6] >>
                  rates[7])) {
                throw std::runtime_error("Malformed CSV line " + std::to_string(line_no));
            }
            if (band_idx_file == nbands) {
                // More bands in the file than in the mesh: ignore extra bands
                break;
            }
            per_band[idx_band] = rates;
        }
    }
    in.close();

    std::cout << "Finished reading phonon scattering rates for " << m_list_vertices.size() << " vertices.\n";
}

// -------------------- Simple reductions --------------------

inline double ElectronPhonon::sum_modes(const Rate8& r) const noexcept {
    double s = 0.0;
    for (int i = 0; i < 8; ++i)
        s += r[i];
    return s;
}

double ElectronPhonon::compute_P_Gamma() const {
    double pgamma_max = 0.0;
    for (const auto& perVertex : m_list_phonon_scattering_rates) {
        for (const auto& rate8 : perVertex) {
            const double tot = sum_modes(rate8);
            if (tot > pgamma_max) pgamma_max = tot;
        }
    }
    return pgamma_max;
}

}  // namespace bz_mesh
#include "BandStructure.h"

#include <omp.h>

#include <algorithm>
#include <cfloat>
#include <chrono>
#include <experimental/iterator>
#include <fstream>
#include <iostream>
#include <iterator>

#include "Hamiltonian.h"

namespace EmpiricalPseudopotential {

std::string BandStructure::get_path_as_string() const {
    std::string path = "";
    for (const auto& point : m_path) {
        path += point;
    }
    return path;
}

bool BandStructure::GenerateBasisVectors(unsigned int nearestNeighborsNumber) {
    static const std::vector<unsigned int> G2{
        0,   3,   4,   8,   11,  12,  16,  19,  20,  24,  27,  32,  35,  36,  40,  43,  44,  48,  51,  52,  56,  59,  67,  68,
        75,  76,  80,  83,  84,  88,  96,  99,  104, 107, 108, 115, 116, 120, 123, 128, 131, 132, 136, 139, 140, 144, 147, 152,
        155, 160, 163, 164, 168, 171, 172, 176, 179, 180, 184, 187, 192, 195, 196, 200, 203, 204, 208, 211, 212, 216, 219, 224,
        227, 228, 232, 236, 243, 244, 248, 251, 259, 260, 264, 267, 268, 272, 275, 276, 280, 283, 291, 296, 299, 300, 304, 307,
        308, 312, 315, 320, 323, 324, 331, 332, 339, 355, 356, 360, 363, 371, 376, 384, 387, 395, 420, 451};

    if (nearestNeighborsNumber < 2 || nearestNeighborsNumber > G2.size()) {
        std::cout << "Error: nearestNeighborsNumber must be between 2 and " << G2.size() << std::endl;
        return false;
    }
    const unsigned int nearestNeighbors = nearestNeighborsNumber - 1;
    basisVectors.clear();
    const int           size = static_cast<int>(ceil(sqrt(static_cast<double>(G2[nearestNeighbors]))));
    const Vector3D<int> b1(-1, 1, 1), b2(1, -1, 1), b3(1, 1, -1);

    for (int i = -size; i <= size; ++i)
        for (int j = -size; j <= size; ++j)
            for (int k = -size; k <= size; ++k) {
                const Vector3D<int> vect        = b1 * i + b2 * j + b3 * k;  // reciprocal lattice vector
                const double        vectSquared = vect * vect;

                if (vectSquared <= G2[nearestNeighbors])  // if it's under the cutoff length, add it
                    basisVectors.push_back(vect);
            }

    return true;
}

void BandStructure::Initialize(const Material&                 material,
                               std::size_t                     nb_bands,
                               const std::vector<std::string>& path,
                               unsigned int                    nbPoints,
                               unsigned int                    nearestNeighborsNumber,
                               bool                            enable_non_local_correction,
                               bool                            enable_soc) {
    m_material                    = material;
    m_nb_bands                    = nb_bands;
    m_path                        = path;
    m_nb_points                   = nbPoints;
    m_nearestNeighborsNumber      = nearestNeighborsNumber;
    m_enable_non_local_correction = enable_non_local_correction;
    m_enable_spin_orbit_coupling  = enable_soc;
    m_kpoints.clear();
    m_results.clear();
    m_kpoints.reserve(m_nb_points);
    m_results.reserve(m_nb_points);

    if (m_enable_spin_orbit_coupling) {
        m_nb_bands *= 2;
        std::cout << "Spin-orbit coupling enabled. Number of bands doubled to " << m_nb_bands << std::endl;
        m_material.get_spin_orbit_parameters().print_parameters();
    }

    if (!GenerateBasisVectors(nearestNeighborsNumber)) {
        throw std::runtime_error("BandStructure::Initialize: GenerateBasisVectors failed");
    }
    m_kpoints   = symmetryPoints.GeneratePoints(m_path, m_nb_points, symmetryPointsPositions);
    m_nb_points = m_kpoints.size();
    if (m_nb_points == 0) {
        throw std::runtime_error(
            "BandStructure::Initialize: GeneratePoints failed. No points generated.\
        \nPlease increase the number of points such as there is twice as many points as the number of symetry points.");
    }
}

void BandStructure::Initialize(const Material&               material,
                               std::size_t                   nb_bands,
                               std::vector<Vector3D<double>> list_k_points,
                               unsigned int                  nearestNeighborsNumber,
                               bool                          enable_non_local_correction,
                               bool                          enable_soc) {
    m_material                    = material;
    m_nb_bands                    = nb_bands;
    m_nb_points                   = list_k_points.size();
    m_nearestNeighborsNumber      = nearestNeighborsNumber;
    m_enable_non_local_correction = enable_non_local_correction;
    m_enable_spin_orbit_coupling  = enable_soc;

    if (m_enable_spin_orbit_coupling) {
        m_nb_bands *= 2;
        std::cout << "Spin-orbit coupling enabled. Number of bands doubled to " << m_nb_bands << std::endl;
        m_material.get_spin_orbit_parameters().print_parameters();

    }

    m_kpoints.clear();
    m_results.clear();
    m_kpoints = list_k_points;

    if (!GenerateBasisVectors(nearestNeighborsNumber)) {
        throw std::runtime_error("BandStructure::Initialize: GenerateBasisVectors failed");
    }
}

void BandStructure::Compute() {
    std::cout << "Computing band structure..." << std::endl;
    auto start = std::chrono::high_resolution_clock::now();

    m_results.clear();

    Hamiltonian hamiltonian(m_material, basisVectors);
    for (unsigned int i = 0; i < m_nb_points; ++i) {
        // std::cout << "\rComputing band structure at point " << i + 1 << "/" << m_nb_points << std::flush;
        // std::cout << "Computing band structure at point " << m_kpoints[i] << std::endl;

        hamiltonian.SetMatrix(m_kpoints[i], m_enable_non_local_correction, m_enable_spin_orbit_coupling);
        hamiltonian.Diagonalize();

        const Eigen::VectorXd& eigenvals = hamiltonian.eigenvalues();

        m_results.emplace_back();
        m_results.back().reserve(m_nb_bands);
        for (unsigned int level = 0; level < m_nb_bands && level < eigenvals.rows(); ++level) {
            m_results.back().push_back(eigenvals(level));
        }
    }
    auto end             = std::chrono::high_resolution_clock::now();
    m_computation_time_s = std::chrono::duration_cast<std::chrono::seconds>(end - start).count();
}

void BandStructure::Compute_parallel(int nb_threads) {
    auto start = std::chrono::high_resolution_clock::now();
    m_results.clear();
    m_results.resize(m_nb_points);
    for (auto& row : m_results) {
        row.resize(m_nb_bands);
    };

    std::vector<Hamiltonian> hamiltonian_per_thread;
    for (int i = 0; i < nb_threads; i++) {
        hamiltonian_per_thread.push_back(Hamiltonian(m_material, basisVectors));
    }

#pragma omp parallel for schedule(dynamic) num_threads(nb_threads)
    for (unsigned int index_k = 0; index_k < m_nb_points; ++index_k) {
        int tid = omp_get_thread_num();
        hamiltonian_per_thread[tid].SetMatrix(m_kpoints[index_k], m_enable_non_local_correction, m_enable_spin_orbit_coupling);
        hamiltonian_per_thread[tid].Diagonalize();

        const Eigen::VectorXd& eigenvals = hamiltonian_per_thread[tid].eigenvalues();
        for (unsigned int level = 0; level < m_nb_bands && level < eigenvals.rows(); ++level) {
            m_results[index_k][level] = eigenvals(level);
        }
    }
    auto end             = std::chrono::high_resolution_clock::now();
    m_computation_time_s = std::chrono::duration_cast<std::chrono::seconds>(end - start).count();
}

double BandStructure::AdjustValues(bool minConductionBandToZero) {
    double maxValValence;
    double minValConduction;

    double band_gap = 0;

    if (FindBandGap(m_results, maxValValence, minValConduction)) {
        band_gap = minValConduction - maxValValence;
    }

    for (std::size_t idx_k = 0; idx_k < m_results.size(); ++idx_k) {
        for (std::size_t idx_band = 0; idx_band < m_results[idx_k].size(); ++idx_band) {
            if (idx_band < 4) {
                m_results[idx_k][idx_band] -= maxValValence;
            } else if (minConductionBandToZero) {
                m_results[idx_k][idx_band] -= minValConduction;
            } else {
                m_results[idx_k][idx_band] -= maxValValence;
            }
        }
    }

    return band_gap;
}

bool BandStructure::FindBandGap(const std::vector<std::vector<double>>& results, double& maxValValence, double& minValConduction) {
    maxValValence = DBL_MIN;
    if (results.empty() || results.front().size() < 2) return false;

    const unsigned int nrLevels       = static_cast<unsigned int>(results.front().size());
    double             fallbackMaxVal = 0;

    for (unsigned int levelLow = 2; levelLow < nrLevels - 1; ++levelLow) {
        maxValValence    = DBL_MIN;
        minValConduction = DBL_MAX;

        for (auto& p : results) {
            const double valLow  = p[levelLow];
            const double valHigh = p[levelLow + 1ULL];

            maxValValence    = std::max(maxValValence, valLow);
            minValConduction = std::min(minValConduction, valHigh);
        }

        if (3 == levelLow) fallbackMaxVal = maxValValence;

        if (maxValValence + 0.35 < minValConduction) return true;
    }

    maxValValence = fallbackMaxVal;

    return false;
}

std::vector<double> BandStructure::get_band(unsigned int band_index) const {
    std::vector<double> res;
    res.reserve(m_results.size());
    for (auto& p : m_results) {
        res.push_back(p[band_index]);
    }
    return res;
}

void BandStructure::print_results() const {
    for (auto& p : m_results) {
        for (auto& v : p)
            std::cout << v << " ";
        std::cout << std::endl;
    }
}

void BandStructure::export_k_points_to_file(std::string filename) const {
    std::ofstream file(filename);
    for (auto& p : m_kpoints) {
        file << p.Y << " " << p.X << " " << p.Z << std::endl;
    }
    file.close();
}

void BandStructure::export_result_in_file(const std::string& filename) const {
    std::cout << "Exporting band structure to file:     " << filename << std::endl;
    std::ofstream file(filename);
    file << "# Path " << get_path_as_string() << std::endl;
    file << "# Material " << m_material.get_name() << std::endl;
    file << "# NBands " << m_nb_bands << std::endl;
    file << "# Nonlocal " << (m_enable_non_local_correction ? "Yes" : "No") << std::endl;

    for (unsigned int i = 0; i < m_results.front().size() - 1; ++i) {
        file << "band_" << i << ",";
    }
    file << "band_" << m_results.front().size() - 1 << std::endl;
    for (unsigned int index_k = 0; index_k < m_nb_points; ++index_k) {
        // file << m_kpoints[index_k].Y << "," << m_kpoints[index_k].X << "," << m_kpoints[index_k].Z << ",";
        std::vector<double> band_values = m_results[index_k];
        std::copy(std::begin(band_values), std::end(band_values), std::experimental::make_ostream_joiner(file, ","));
        file << std::endl;
    }
}

void BandStructure::export_result_in_file_with_kpoints(const std::string& filename) const {
    std::cout << "Exporting band structure to file:     " << filename << std::endl;
    std::ofstream file(filename);
    file << "kx,ky,kz,";

    for (unsigned int i = 0; i < m_results.front().size() - 1; ++i) {
        file << "band_" << i << ",";
    }
    file << "band_" << m_results.front().size() - 1 << std::endl;
    for (unsigned int index_k = 0; index_k < m_nb_points; ++index_k) {
        file << m_kpoints[index_k].Y << "," << m_kpoints[index_k].X << "," << m_kpoints[index_k].Z << ",";
        std::vector<double> band_values = m_results[index_k];
        std::copy(std::begin(band_values), std::end(band_values), std::experimental::make_ostream_joiner(file, ","));
        file << std::endl;
    }
}

std::string BandStructure::path_band_filename() const {
    std::string path_string;
    if (m_path.empty()) {
        path_string = "";
    } else {
        for (auto& point : m_path) {
            path_string += point;
        }
    }
    std::string filename = "EPM_" + m_material.get_name() + "_nb_bands_" + std::to_string(m_results.front().size()) + "_path_" +
                           path_string + "_size_basis_" + std::to_string(basisVectors.size());
    return filename;
}

void export_vector_bands_result_in_file(const std::string& filename, std::vector<std::vector<double>> results) {
    std::cout << "Exporting band structure to file:     " << filename << std::endl;
    std::ofstream file(filename);

    for (auto& p : results) {
        for (auto& v : p)
            file << v << ",";
        file << std::endl;
    }
}

}  // namespace EmpiricalPseudopotential/**
 * @file Constants.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-26
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <cmath>
#include <numbers>

namespace EmpiricalPseudopotential {

namespace Constants {

constexpr double h   = 6.62607015e-34;   // J·s (exact)
constexpr double k_B = 1.380649e-23;     // J/K (exact)
constexpr double q_e = 1.602176634e-19;  // C = J/eV (exact)
constexpr double N_A = 6.02214076e23;    // 1/mol (exact)
constexpr double c   = 299792458.0;      // m/s (exact)

// === Derived fundamentals ===
constexpr double pi       = std::numbers::pi_v<double>;
constexpr double h_bar    = h / (2.0 * pi);   // J·s
constexpr double eV_to_J  = q_e;              // J/eV
constexpr double h_bar_eV = h_bar / eV_to_J;  // eV·s
constexpr double k_b_eV   = k_B / eV_to_J;    // eV/K

constexpr double eps_0 = 8.8541878128e-12;  // F/m
constexpr double m_e   = 9.1093837015e-31;  // kg

constexpr double bohr_radius    = 5.29177210903e-11;    // m
constexpr double Hartree_to_J   = 4.3597447222071e-18;  // J
constexpr double Hartree_to_eV  = Hartree_to_J / eV_to_J;
constexpr double Ryd_to_eV      = Hartree_to_eV / 2.0;  // ~13.605693122994
constexpr double Ryd_to_Hartree = 0.5;

// conversions
constexpr double angstrom_to_m   = 1e-10;              // m/Å
constexpr double eV_to_cm_inv    = 8065.54429;         // cm^-1/eV
constexpr double eV_to_J_per_mol = eV_to_J * N_A;      // J/mol per eV
constexpr double eV_to_kg        = eV_to_J / (c * c);  // kg/eV (~1.78266192e-36)

// Back-conversions
constexpr double eV_to_Hartree = 1.0 / Hartree_to_eV;
constexpr double eV_to_Ryd     = 1.0 / Ryd_to_eV;

}  // namespace Constants
}  // namespace EmpiricalPseudopotential#include "Material.h"

#include <cmath>

#include "Constants.hpp"
#include "bessel_func.hpp"
#include "yaml-cpp/yaml.h"

namespace EmpiricalPseudopotential {

const double Bohr = 0.52917721092;  // in Angstroms

Material::Material(const std::string& Name,
                   double             a,
                   double             V3S,
                   double             V4S,
                   double             V8S,
                   double             V11S,
                   double             V3A,
                   double             V4A,
                   double             V8A,
                   double             V11A)
    : m_name(Name),
      m_lattice_constant(a),
      m_pseudopotential(V3S, V4S, V8S, V11S, V3A, V4A, V8A, V11A) {
}

/**
 * @brief Load material parameters from the passed filename.
 * The file is a YAML file containing the parameters for each material (lattice constant, pseudopotential parameters, etc.).
 *
 * @param filename
 */
void Materials::load_material_parameters(const std::string& filename) {
    YAML::Node config         = YAML::LoadFile(filename);
    auto       list_materials = config["materials"];
    for (const auto& material : list_materials) {
        std::string name                 = material["name"].as<std::string>();
        std::string symbol               = material["symbol"].as<std::string>();
        double      a                    = material["lattice-constant"].as<double>();
        auto        node_pseudopotential = material["pseudo-potential-parameters"];
        double      V3S                  = Constants::Ryd_to_eV * node_pseudopotential["V3S"].as<double>();
        double      V8S                  = Constants::Ryd_to_eV * node_pseudopotential["V8S"].as<double>();
        double      V11S                 = Constants::Ryd_to_eV * node_pseudopotential["V11S"].as<double>();
        double      V3A                  = Constants::Ryd_to_eV * node_pseudopotential["V3A"].as<double>();
        double      V4A                  = Constants::Ryd_to_eV * node_pseudopotential["V4A"].as<double>();
        double      V11A                 = Constants::Ryd_to_eV * node_pseudopotential["V11A"].as<double>();
        double      V4S                  = 0.0;
        double      V8A                  = 0.0;
        if (node_pseudopotential["V4S"]) {
            V4S = Constants::Ryd_to_eV * node_pseudopotential["V4S"].as<double>();
        }
        if (node_pseudopotential["V8A"]) {
            V8A = Constants::Ryd_to_eV * node_pseudopotential["V8A"].as<double>();
        }
        materials[symbol] = Material(symbol, a, V3S, V4S, V8S, V11S, V3A, V4A, V8A, V11A);

        auto node_non_local_parameters = material["non-local-parameters"];
        if (node_non_local_parameters) {
            materials[symbol].populate_non_local_parameters(node_non_local_parameters);
            materials[symbol].set_is_non_local_parameters_populated(true);
        }

        auto node_spin_orbit_parameters = material["spin-orbit-parameters"];
        if (node_spin_orbit_parameters) {
            materials[symbol].populate_spin_orbit_parameters(node_spin_orbit_parameters);
            materials[symbol].set_is_spin_orbit_parameters_populated(true);
            std::cout << "Spin-orbit parameters for " << symbol << " are set." << std::endl;
            // materials[symbol].get_spin_orbit_parameters().print_parameters();
            
        }
    }
}

/**
 * @brief Compute the so called F_l function, which is used in the non-local pseudopotential correction.
 * (See Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
 * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).)
 *
 * For the values of function, see: Bloomfield, J. K., Face, S. H. P. & Moss, Z. Indefinite Integrals of Spherical Bessel
 * Functions. Preprint at http://arxiv.org/abs/1703.06428 (2017). Equations 49 and 59.
 *
 * @param K1
 * @param K2
 * @param atomic_radii
 * @param l
 * @return double
 */
double F_l_function(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii, int l) {
    // This epsilon is used to avoid division by zero in the case of K1 == K2.
    // The value is quite big, but lower values lead to numerical instabilities (noisy bands).
    // Reason: K1 and K2 are of the order of  2PI / a_0 ~ 1e10 !
    constexpr double EPSILON = 1.0e-4;
    const double     norm_K1 = K1.Length();
    const double     norm_K2 = K2.Length();
    if (fabs(norm_K1 - norm_K2) > EPSILON) {
        const double pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
        const double F = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
                         norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
        return pre_factor * F;
    } else if (norm_K1 > EPSILON) {
        const double pre_factor = pow(atomic_radii, 3.0) / (2.0);
        const double F          = pow(generalized_bessel(l, norm_K1 * atomic_radii), 2.0) -
                         generalized_bessel(l - 1, norm_K1 * atomic_radii) * generalized_bessel(l + 1, norm_K1 * atomic_radii);
        return pre_factor * F;
    } else {
        return (l==0) ? pow(atomic_radii, 3.0) / (3.0) : 0.0;
    }
}

double F_2_function_gaussian(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii) {
    const double norm_K1    = K1.Length();
    const double norm_K2    = K2.Length();
    const double bessel_arg = 0.5 * (atomic_radii * atomic_radii) * norm_K1 * norm_K2;
    return bessel_2nd_order_first_kind(bessel_arg) * exp(-0.25 * (norm_K1 * norm_K1 + norm_K2 * norm_K2) * atomic_radii * atomic_radii);
}

/**
 * @brief Compute the non local correction to the EPM Hamiltonian.
 * It follows: Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
 * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).
 * See also: Pötz, W. & Vogl, P. Theory of optical-phonon deformation
 * potentials in tetrahedral semiconductors. Phys. Rev. B 24, 2025–2037 (1981)
 *
 * K1 = (k + G)
 * K2 = (k + G')
 * tau = 1/8 * a * (1, 1, 1)
 *
 * @warning This function aims to be as close as possible to the original implementation of the authors.
 * It might not be the most efficient way, even though the compiler may optimize it for us.
 *
 * @warning Only square well pseudopotential are supported for now on.
 *
 * @param K1
 * @param K2
 * @param tau
 * @return std::complex<double>
 */
std::complex<double> Material::compute_pseudopotential_non_local_correction(const Vector3D<double>& K1_normalized,
                                                                            const Vector3D<double>& K2_normalized,
                                                                            const Vector3D<double>& tau) const {
    const double           diag_factor       = pow(Constants::h_bar, 2) / (2.0 * Constants::m_e * Constants::q_e);
    const double           fourier_factor    = 2.0 * M_PI / get_lattice_constant_meter();
    const Vector3D<double> G_diff_normalized = (K1_normalized - K2_normalized);
    const Vector3D<double> K1                = K1_normalized * fourier_factor;
    const Vector3D<double> K2                = K2_normalized * fourier_factor;
    const double           norm_K1           = K1.Length();
    const double           norm_K2           = K2.Length();
    const double           cos_angle_K1_K2   = compute_cos_angle(K1, K2);
    const double           V_pre_factor      = 4.0 * M_PI / get_atomic_volume();
    const double           legendre_0        = 1.0;
    const double           legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);

    // First atomic species: anion
    double V_anion = 0;
    // l = 0
    const double A_0_anion = m_non_local_parameters.m_alpha_0_anion + diag_factor * m_non_local_parameters.m_beta_0_anion *
                                                                          (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
    const double F_0_anion = (m_non_local_parameters.m_R0_anion == 0.0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_anion, 0);
    V_anion += V_pre_factor * A_0_anion * (2 * 0 + 1) * 1.0 * F_0_anion;
    // l = 2
    double V_anion_2 = 0.0;
    if (m_non_local_parameters.m_A2_anion != 0) {
        const double A_2_anion = m_non_local_parameters.m_A2_anion;
        double       F_2_anion = 0.0;
        if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
            F_2_anion = F_l_function(K1, K2, m_non_local_parameters.m_R2_anion, 2);
            V_anion_2 = V_pre_factor * A_2_anion * (2 * 2 + 1) * legendre_2 * F_2_anion;
        } else {
            F_2_anion = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_anion);
            V_anion_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_anion, 3.0) / get_atomic_volume()) * A_2_anion *
                        legendre_2 * F_2_anion;
        }
        V_anion += V_anion_2;
    }

    // Second atomic species: cation
    double V_cation = 0;
    // l = 0
    const double F_0_cation = (m_non_local_parameters.m_R0_cation == 0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_cation, 0);
    const double A_0_cation = m_non_local_parameters.m_alpha_0_cation + m_non_local_parameters.m_beta_0_cation * diag_factor *
                                                                            (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
    V_cation += V_pre_factor * A_0_cation * (2 * 0 + 1) * legendre_0 * F_0_cation;
    // l = 2
    double V_cation_2 = 0.0;
    if (m_non_local_parameters.m_A2_cation != 0.0) {
        const double A_2_cation = m_non_local_parameters.m_A2_cation;
        double       F_2_cation = 0.0;
        if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
            F_2_cation = F_l_function(K1, K2, m_non_local_parameters.m_R2_cation, 2);
            V_cation_2 = V_pre_factor * A_2_cation * (2 * 2 + 1) * legendre_2 * F_2_cation;
        } else {
            F_2_cation = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_cation);
            V_cation_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_cation, 3.0) / get_atomic_volume()) * A_2_cation *
                         legendre_2 * F_2_cation;
        }
        V_cation += V_cation_2;
    }

    const double V_symmetric     = 1.0 * (V_anion + V_cation) / 2.0;
    const double V_antisymmetric = 1.0 * (V_anion - V_cation) / 2.0;

    constexpr double const_two        = 2.0;
    const double     lattice_constant = this->get_lattice_constant_meter();
    const double     Gtau             = (tau / lattice_constant) * (G_diff_normalized);

    return std::complex<double>(cos(const_two * M_PI * Gtau) * V_symmetric, sin(const_two * M_PI * Gtau) * V_antisymmetric);
}

void Materials::print_materials_list() const {
    for (const auto& material : materials) {
        std::cout << material.first << std::endl;
    }
}

void Materials::print_material_parameters(const std::string& name) const {
    if (materials.find(name) == materials.end()) {
        std::cout << "Material " << name << " not found" << std::endl;
        return;
    }
    const Material& material = materials.at(name);
    std::cout << "Material: " << name << std::endl;
    std::cout << "Lattice constant: " << material.get_lattice_constant_meter() << " Bohr" << std::endl;
    std::cout << "-------------------------------------" << std::endl;
}

void Materials::print_material_parameters() const {
    for (const auto& material : materials) {
        print_material_parameters(material.first);
    }
}

}  // namespace EmpiricalPseudopotential
/**
 * @file bz_mesh.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-07
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "bz_meshfile.hpp"

#include <filesystem>

#include "BandStructure.h"
#include "gmsh.h"
#include "rapidcsv.h"

void bz_mesh_points::add_k_point(Vector3D<double> kpoint) { m_kpoints.push_back(kpoint); }

void bz_mesh_points::add_k_point(double k_x, double k_y, double k_z) { m_kpoints.push_back(Vector3D<double>(k_x, k_y, k_z)); }

void bz_mesh_points::read_mesh_from_csv() {
    m_node_tags.clear();
    m_kpoints.clear();
    m_nb_points = 0;
    std::cout << "Opening file " << m_filename << std::endl;
    rapidcsv::Document  doc(m_filename, rapidcsv::LabelParams(-1, -1), rapidcsv::SeparatorParams(' '));
    std::vector<double> k_x = doc.GetColumn<double>(0);
    std::vector<double> k_y = doc.GetColumn<double>(1);
    std::vector<double> k_z = doc.GetColumn<double>(2);

    std::size_t size_k_x = k_x.size();
    std::size_t size_k_y = k_y.size();
    std::size_t size_k_z = k_z.size();

    if (size_k_x != size_k_y || size_k_x != size_k_z) {
        throw std::runtime_error("Number of k-points in x, y and z are not the same. Abort.");
    }

    for (std::size_t index_k = 0; index_k < size_k_x; ++index_k) {
        add_k_point(k_x[index_k], k_y[index_k], k_z[index_k]);
    }

    std::cout << "Number of k-points read from csv file: " << size_k_x << std::endl;
}

void bz_mesh_points::read_mesh() {
    std::cout << "Opening file " << m_filename << std::endl;
    if (m_filename.substr(m_filename.find_last_of(".") + 1) == "csv") {
        read_mesh_from_csv();
        return;
    }

    gmsh::initialize();
    // gmsh::option::setNumber("General.Verbosity", 1);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);
    // std::vector<std::size_t> nodeTags;
    std::vector<double> nodeCoords;
    std::vector<double> nodeParams;
    gmsh::model::mesh::reclassifyNodes();
    gmsh::model::mesh::getNodes(m_node_tags, nodeCoords, nodeParams, -1, -1, false, false);
    std::size_t size_nodes_tags        = m_node_tags.size();
    std::size_t size_nodes_coordinates = nodeCoords.size();
    if (size_nodes_coordinates != 3 * size_nodes_tags) {
        throw std::runtime_error("Number of coordinates is not 3 times the number of vertices. Abort.");
    }
    for (std::size_t index_vertex = 0; index_vertex < size_nodes_tags; ++index_vertex) {
        add_k_point(nodeCoords[3 * index_vertex], nodeCoords[3 * index_vertex + 1], nodeCoords[3 * index_vertex + 2]);
    }
    gmsh::finalize();
    std::cout << "Number of k-points: " << m_kpoints.size() << std::endl;
}

void bz_mesh_points::add_band_on_mesh(const std::string& band_name, const std::vector<double>& band_values) {
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 99999999);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);

    int data_tag = gmsh::view::add(band_name);
    if (m_node_tags.size() != band_values.size()) {
        std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
        std::cout << "number of values: " << band_values.size() << std::endl;
        throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
    }
    gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, band_values);
    const int   index_view             = gmsh::view::getIndex(data_tag);
    std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
    gmsh::option::setNumber(name_object_visibility, 1);
    gmsh::view::write(data_tag, "band_mesh.msh", true);
    gmsh::finalize();
}

void bz_mesh_points::add_all_bands_on_mesh(const std::string&                             out_filename,
                                           const EmpiricalPseudopotential::BandStructure& my_band,
                                           int                                            nb_valence_bands_to_export,
                                           int                                            nb_conduction_bands_to_export) {
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);
    bool first_view = true;

    // We want to inverse the order of the valence bands so that the highest valence band is band 0
    int nb_valence_bands = my_band.is_soc_enabled() ? 8 : 4;
    int nb_bands         = my_band.get_number_of_bands();

    // Sanity checks
    if (nb_valence_bands_to_export < 0 || nb_valence_bands_to_export > nb_valence_bands) {
        nb_valence_bands_to_export = nb_valence_bands;
        std::cout << "Warning: nb_valence_bands_to_export is not valid. Setting it to " << nb_valence_bands << std::endl;
    }
    if (nb_conduction_bands_to_export < 0 || nb_conduction_bands_to_export > (nb_bands - nb_valence_bands)) {
        nb_conduction_bands_to_export = nb_bands - nb_valence_bands;
        std::cout << "Warning: nb_conduction_bands_to_export is not valid. Setting it to " << (nb_bands - nb_valence_bands) << std::endl;
    }

    int count = 0;
    if (nb_valence_bands_to_export != 0) {
        for (int index_band = nb_valence_bands - 1; index_band >= nb_valence_bands - nb_valence_bands_to_export; --index_band) {
            std::string         band_name   = "band_" + std::to_string(count);
            count++;
            std::vector<double> band_values = my_band.get_band(index_band);
            int                 data_tag    = gmsh::view::add(band_name);
            if (m_node_tags.size() != band_values.size()) {
                std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
                std::cout << "number of values: " << band_values.size() << std::endl;
                throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
            }
            gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, band_values);
            const int   index_view             = gmsh::view::getIndex(data_tag);
            std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
            gmsh::option::setNumber(name_object_visibility, 0);
            gmsh::option::setNumber("PostProcessing.SaveMesh", (first_view) ? 1 : 0);  // Save mesh only once
            gmsh::view::write(data_tag, out_filename, true);
            first_view = false;
        }
    }

    if (nb_conduction_bands_to_export != 0) {
        for (int index_band = nb_valence_bands; index_band < nb_valence_bands + nb_conduction_bands_to_export; ++index_band) {
            std::string         band_name   = "band_" + std::to_string(count);
            count++;
            std::vector<double> band_values = my_band.get_band(index_band);
            int                 data_tag    = gmsh::view::add(band_name);
            if (m_node_tags.size() != band_values.size()) {
                std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
                std::cout << "number of values: " << band_values.size() << std::endl;
                throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
            }
            gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, band_values);
            const int   index_view             = gmsh::view::getIndex(data_tag);
            std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
            gmsh::option::setNumber(name_object_visibility, 0);
            gmsh::option::setNumber("PostProcessing.SaveMesh", (first_view) ? 1 : 0);  // Save mesh only once
            gmsh::view::write(data_tag, out_filename, true);
            first_view = false;
        }
    }
    gmsh::finalize();
}

void bz_mesh_points::add_all_bands_on_mesh_separate_files(const std::string&                             out_dir,
                                                          const EmpiricalPseudopotential::BandStructure& my_band) {
    gmsh::initialize();
    try {
        gmsh::option::setNumber("General.Verbosity", 0);
        // Choose a stable MSH version (2.2 or 4.1 both fine)
        gmsh::option::setNumber("Mesh.MshFileVersion", 4.1);

        const std::size_t nbands = my_band.get_number_of_bands();

        for (std::size_t index_band = 0; index_band < nbands; ++index_band) {
            // Fresh model each band to avoid accumulating views
            gmsh::clear();
            gmsh::open(m_filename);  // load the base mesh

            std::string model_name;
            gmsh::model::getCurrent(model_name);

            // Always get node tags from THIS session/model
            std::vector<std::size_t> nodeTags;
            std::vector<double>      nodeCoords, nodeParams;
            gmsh::model::mesh::reclassifyNodes();
            gmsh::model::mesh::getNodes(nodeTags, nodeCoords, nodeParams);

            const std::vector<double> band_values = my_band.get_band(index_band);
            if (band_values.size() != nodeTags.size()) {
                std::cout << "Band " << index_band << " — node/value size mismatch: " << nodeTags.size() << " vs " << band_values.size()
                          << std::endl;
                throw std::runtime_error("Node/value size mismatch.");
            }

            const std::string band_name = "band_" + std::to_string(index_band);
            const int         view_tag  = gmsh::view::add(band_name);
            gmsh::view::addHomogeneousModelData(view_tag, 0, model_name, "NodeData", nodeTags, band_values);

            // Optional: hide in GUI
            const int index_view = gmsh::view::getIndex(view_tag);
            gmsh::option::setNumber("View[" + std::to_string(index_view) + "].Visible", 0);

            // Write ONE file per band: mesh + this single view
            // out_dir can be a directory path; we build "out_dir/band_<i>.msh"

            std::filesystem::create_directories(out_dir);  // Ensure the directory exists
            const std::string out_file = out_dir + "/band_" + std::to_string(index_band) + ".msh";
            gmsh::view::write(view_tag, out_file, true);
        }
    } catch (...) {
        try {
            gmsh::finalize();
        } catch (...) {
        }
        throw;
    }
    gmsh::finalize();
}

// void bz_mesh_points::add_all_bands_on_mesh(const std::string& out_dir, const EmpiricalPseudopotential::BandStructure& my_band) {
//     gmsh::initialize();
//     try {
//         gmsh::option::setNumber("General.Verbosity", 0);
//         // Choose a stable MSH version (2.2 or 4.1 both fine)
//         gmsh::option::setNumber("Mesh.MshFileVersion", 4.1);

//         const std::size_t nbands = my_band.get_number_of_bands();

//         for (std::size_t index_band = 0; index_band < nbands; ++index_band) {
//             // Fresh model each band to avoid accumulating views
//             gmsh::clear();
//             gmsh::open(m_filename);  // load the base mesh

//             std::string model_name;
//             gmsh::model::getCurrent(model_name);

//             // Always get node tags from THIS session/model
//             std::vector<std::size_t> nodeTags;
//             std::vector<double>      nodeCoords, nodeParams;
//             gmsh::model::mesh::reclassifyNodes();
//             gmsh::model::mesh::getNodes(nodeTags, nodeCoords, nodeParams);

//             const std::vector<double> band_values = my_band.get_band(index_band);
//             if (band_values.size() != nodeTags.size()) {
//                 std::cout << "Band " << index_band << " — node/value size mismatch: " << nodeTags.size() << " vs " << band_values.size()
//                           << std::endl;
//                 throw std::runtime_error("Node/value size mismatch.");
//             }

//             const std::string band_name = "band_" + std::to_string(index_band);
//             const int         view_tag  = gmsh::view::add(band_name);
//             gmsh::view::addHomogeneousModelData(view_tag, 0, model_name, "NodeData", nodeTags, band_values);

//             // Optional: hide in GUI
//             const int index_view = gmsh::view::getIndex(view_tag);
//             gmsh::option::setNumber("View[" + std::to_string(index_view) + "].Visible", 0);

//             // Write ONE file per band: mesh + this single view
//             // out_dir can be a directory path; we build "out_dir/band_<i>.msh"

//             std::filesystem::create_directories(out_dir);  // Ensure the directory exists
//             const std::string out_file = out_dir + "/band_" + std::to_string(index_band) + ".msh";
//             gmsh::view::write(view_tag, out_file, true);
//         }
//     } catch (...) {
//         try {
//             gmsh::finalize();
//         } catch (...) {
//         }
//         throw;
//     }
//     gmsh::finalize();
// }

/**
 * @brief Add band structure energies to gmsh mesh as views.
 * One view per band.
 *
 * The band structure is assumed to be given in band_values vector under the following format:
 * band_values[index_k_point * number_of_bands + index_band] = energy of the band with index index_band at k-point with index index_k_point.
 *
 * @param out_filename
 * @param band_values
 */
void bz_mesh_points::add_all_bands_on_mesh(const std::string& out_filename, const std::vector<double>& band_values, int number_bands) {
    if (band_values.size() != number_bands * m_node_tags.size()) {
        std::cout << "band_values.size(): " << band_values.size() << std::endl;
        std::cout << "number_bands: " << number_bands << std::endl;
        std::cout << "m_node_tags.size(): " << m_node_tags.size() << std::endl;
        std::cout << "m_kpts.size(): " << m_kpoints.size() << std::endl;
        std::cout << "number_bands * m_node_tags.size(): " << number_bands * m_node_tags.size() << std::endl;
        throw std::runtime_error("band_values vector is not the same size as the number of bands times the number of nodes. Abort.");
    }
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::model::add("bz_mesh");
    gmsh::open(m_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);

    for (int index_band = 0; index_band < number_bands; ++index_band) {
        std::string         band_name = "band_" + std::to_string(index_band);
        std::vector<double> current_band_values(m_node_tags.size());
        for (std::size_t index_node = 0; index_node < m_node_tags.size(); ++index_node) {
            current_band_values[index_node] = band_values[index_node * number_bands + index_band];
        }
        int data_tag = gmsh::view::add(band_name);
        if (m_node_tags.size() != current_band_values.size()) {
            std::cout << "number of nodes: " << m_node_tags.size() << std::endl;
            std::cout << "number of values: " << current_band_values.size() << std::endl;
            throw std::runtime_error("Number of nodes and number of values are not the same. Abort.");
        }
        gmsh::view::addHomogeneousModelData(data_tag, 0, model_file_name, "NodeData", m_node_tags, current_band_values);
        const int   index_view             = gmsh::view::getIndex(data_tag);
        std::string name_object_visibility = "View[" + std::to_string(index_view) + "].Visible";
        gmsh::option::setNumber(name_object_visibility, 0);
        gmsh::view::write(data_tag, out_filename, true);
    }
}

/**
 * @brief Export band structure energies to csv files (one file per band).
 *
 * The band structure is assumed to be given in band_values vector under the following format:
 * band_values[index_k_point * number_of_bands + index_band] = energy of the band with index index_band at k-point with index index_k_point.
 *
 * @param out_filename
 * @param band_values
 */
void bz_mesh_points::export_bands_as_csv(const std::vector<double>& band_values, int number_bands) {
    // if (band_values.size() != number_bands * m_node_tags.size()) {
    //     throw std::runtime_error("band_values vector is not the same size as the number of bands times the number of nodes. Abort.");
    // }
    for (int index_band = 0; index_band < number_bands; ++index_band) {
        std::string         band_name = "band_" + std::to_string(index_band);
        std::vector<double> current_band_values(m_node_tags.size());
        for (std::size_t index_node = 0; index_node < m_node_tags.size(); ++index_node) {
            current_band_values[index_node] = band_values[index_node * number_bands + index_band];
        }
        std::ofstream band_file(band_name + ".csv");
        for (std::size_t index_node = 0; index_node < m_node_tags.size(); ++index_node) {
            band_file << current_band_values[index_node] << std::endl;
        }
        band_file.close();
    }
}
#include "SymmetryPoints.h"

namespace EmpiricalPseudopotential {

SymmetryPoints::SymmetryPoints() {
    symmetryPoints["L"] = SymmetryPoint("L", Vector3D<double>(0.5, 0.5, 0.5));
    symmetryPoints["G"] = SymmetryPoint("G", Vector3D<double>(0., 0., 0.));
    symmetryPoints["X"] = SymmetryPoint("X", Vector3D<double>(1., 0., 0.));
    symmetryPoints["W"] = SymmetryPoint("W", Vector3D<double>(1., 0.5, 0.));
    symmetryPoints["K"] = SymmetryPoint("K", Vector3D<double>(0.75, 0.75, 0.));
    symmetryPoints["U"] = SymmetryPoint("U", Vector3D<double>(1., 0.25, 0.25));
}

/**
 * @brief Generates the list of k points for the given path of "symetry points".
 *
 * The path will be for example {"G", "X", "W", "L", "G", "K", "X"}
 * The number of points will be the total of points in the output.
 * The symmetryPointsPositions will be the positions (indexes) of the symmetry points in the output.
 *
 * The points are spaced in such way that the number of points between two symmetry points is "proportional" to the distance between them.
 *
 * @param path
 * @param nrPoints
 * @param symmetryPointsPositions
 * @return std::vector<Vector3D<double>>
 */
std::vector<Vector3D<double>> SymmetryPoints::GeneratePoints(const std::vector<std::string>& path,
                                                             unsigned int                    nrPoints,
                                                             std::vector<unsigned int>&      symmetryPointsPositions) {
    std::vector<Vector3D<double>> result;

    symmetryPointsPositions.clear();
    symmetryPointsPositions.reserve(path.size());

    if (nrPoints <= path.size() * 2 + 1) {
        std::cout << "Error: nrPoints must be greater than twice the number of symmetry points in the path + 1" << std::endl;
        return result;
    };

    result.reserve(nrPoints);

    // Calculate the length of each path segment, and add it to the total length.
    double length = 0.0;
    for (std::size_t index_HS_point = 1; index_HS_point < path.size(); ++index_HS_point) {
        const Vector3D<double> dif = symmetryPoints[path[index_HS_point]].position - symmetryPoints[path[index_HS_point - 1]].position;
        length += dif.Length();
    }

    const double stepSize = length / (nrPoints - 1.);

    for (std::size_t indexHSpoint = 1; indexHSpoint < path.size(); ++indexHSpoint) {
        const Vector3D<double> startPos  = symmetryPoints[path[indexHSpoint - 1ULL]].position;
        const Vector3D<double> dif       = symmetryPoints[path[indexHSpoint]].position - startPos;
        const double           difLength = dif.Length();

        Vector3D<double> stepVec = dif / difLength * stepSize;

        if (indexHSpoint == 1)
            symmetryPointsPositions.push_back(0.0);
        else
            symmetryPointsPositions.push_back(static_cast<unsigned int>(result.size() + 1));

        // Fill the path segment with k points spaced by stepVec.
        for (Vector3D<double> pos = startPos; (pos - startPos).Length() < difLength; pos += stepVec)
            result.push_back(pos);
    }

    return result;
}

}  // namespace EmpiricalPseudopotential/**
 * @file SpinOrbitFunctions.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-30
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <complex>
#include <iostream>
#include <string>
#include <system_error>
#include <vector>

#include "Constants.hpp"
#include "Material.h"
#include "SpinOrbitParameters.hpp"
#include "Vector3D.h"

namespace EmpiricalPseudopotential {

/**
 * @brief Functor class to compute the spin-orbit Hamiltonian.
 * The name of the functions follow the notation of the paper:
 * Pötz, W. & Vogl, P. Theory of optical-phonon deformation
 * potentials in tetrahedral semiconductors. Phys. Rev. B 24, 2025–2037 (1981).
 *
 */
class SpinOrbitCorrection {
 protected:
    SpinOrbitParameters m_soc_parameters;
    Material            m_material;

 public:
    SpinOrbitCorrection() = delete;
    SpinOrbitCorrection(const Material& material, const SpinOrbitParameters& SpinParams) : m_material(material), m_soc_parameters(SpinParams){
    };

    double compute_B2_cation(const Vector3D<double>& K) const;
    double compute_B2_anion(const Vector3D<double>& K) const;
    double compute_B3_cation(const Vector3D<double>& K) const;
    double compute_B3_anion(const Vector3D<double>& K) const;
    double compute_B4_cation(const Vector3D<double>& K) const;
    double compute_B4_anion(const Vector3D<double>& K) const;

    double compute_lambda_1(const Vector3D<double>& K, const Vector3D<double>& Kp) const;
    double compute_lambda_2(const Vector3D<double>& K, const Vector3D<double>& Kp) const;

    double compute_lambda_sym(const Vector3D<double>& K, const Vector3D<double>& Kp) const;
    double compute_lambda_antisym(const Vector3D<double>& K, const Vector3D<double>& Kp) const;

    Eigen::Matrix<std::complex<double>, 2, 2> compute_soc_contribution(const Vector3D<double>& K,
                                                                       const Vector3D<double>& Kp,
                                                                       const Vector3D<double>& G,
                                                                       const Vector3D<double>& Gp,
                                                                       const Vector3D<double>& tau) const;

    static Eigen::Matrix<std::complex<double>, 2, 2> compute_pauli_state_dot_product(const Vector3D<double>& a);
};

}  // namespace EmpiricalPseudopotential
#include "Options.h"

#include <iostream>

Options::Options()
    : nrThreads(4),
      materialName("Si"),
      nrPoints(60),
      nearestNeighbors(12),
      nrLevels(30),
      pathNo(1),
      paths{{
          {"K", "W", "X", "G", "L", "W"},
          {"W", "G", "X", "W", "L", "G"},
          {"W", "L", "G", "X", "W", "K"},
          {"L", "G", "X", "K", "G"},
          {"L", "G", "X", "W", "K", "G"},
          {"L", "G", "X", "U", "K", "G"},
          {"L", "G", "X", "U", "G"},
          {"L", "K", "W", "G", "X", "W", "L", "G", "K"},
          {"G", "X", "K", "G", "L", "K", "W", "X"},
          {"G", "X", "W", "L", "G", "K", "W", "U"},
          {"G", "X", "W", "L", "G", "K"},
          {"G", "X", "W", "L", "G", "K", "X"},
          {"G", "X", "W", "L", "G", "X"},
          {"G", "X", "W", "G", "U", "X"},
          {"G", "X", "W", "K", "L", "G"},
          {"G", "X", "W", "K", "G", "L", "U", "W", "L", "K"},
          {"G", "X", "U", "K", "G", "L", "W", "X"},
      }},
      m_fileconfig(nullptr) {}

void Options::print_options() {
    std::cout << "Options:" << std::endl;
    std::cout << "nrThreads: " << nrThreads << std::endl;
    std::cout << "materialName: " << materialName << std::endl;
    std::cout << "nrPoints: " << nrPoints << std::endl;
    std::cout << "nearestNeighbors: " << nearestNeighbors << std::endl;
    std::cout << "nrLevels: " << nrLevels << std::endl;
    std::cout << "pathNo: " << pathNo << std::endl;
    // std::cout << "paths: " << std::endl;
    // for (auto& path : paths) {
    //     for (auto& point : path) {
    //         std::cout << point << " ";
    //     }
    //     std::cout << std::endl;
    // }
}


/**
 * @file DielectricFunction.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-11-24
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "DielectricFunction.hpp"

#include <fmt/core.h>
#include <fmt/format.h>
#include <fmt/ostream.h>

#include <algorithm>
#include <chrono>
#include <cmath>
#include <fstream>
#include <iostream>
#include <random>
#include <vector>

#include "Hamiltonian.h"
#include "Material.h"

namespace EmpiricalPseudopotential {

bool is_in_irreducible_wedge(const Vector3D<double>& k) {
    return (k.Z >= 0.0) && (k.Y >= k.Z) && (k.X >= k.Y) && (k.X <= 1.0) && (k.X + k.Y + k.Z <= 3.0 / 2.0);
}

bool is_in_first_BZ(const Vector3D<double>& k, bool one_eighth = false) {
    bool cond_1      = fabs(k.X) <= 1.0 && fabs(k.Y) <= 1.0 && fabs(k.Z) <= 1.0;
    bool cond_2      = fabs(k.X) + fabs(k.Y) + fabs(k.Z) <= 3.0 / 2.0;
    bool cond_eighth = (k.X >= 0.0 && k.Y >= 0.0 && k.Z >= 0.0);
    return cond_1 && cond_2 && (one_eighth ? cond_eighth : true);
}

DielectricFunction::DielectricFunction(const Material& material, const std::vector<Vector3D<int>>& basisVectors, const int nb_bands)
    : m_basisVectors(basisVectors),
      m_material(material),
      m_nb_bands(nb_bands) {}

void DielectricFunction::generate_k_points_random(std::size_t nb_points) {
    std::random_device               rd;
    std::mt19937                     gen(rd());
    std::uniform_real_distribution<> dis(-1, 1.0);
    while (m_kpoints.size() < nb_points) {
        Vector3D<double> k(dis(gen), dis(gen), dis(gen));
        if (is_in_first_BZ(k)) {
            m_kpoints.push_back(k);
        }
    }
}

void DielectricFunction::generate_k_points_grid(std::size_t Nx, std::size_t Ny, std::size_t Nz, double shift, bool irreducible_wedge) {
    m_kpoints.clear();
    double min = -1.0 - shift;
    double max = 1.0 + shift;
    for (std::size_t i = 0; i < Nx - 1; ++i) {
        for (std::size_t j = 0; j < Ny - 1; ++j) {
            for (std::size_t k = 0; k < Nz - 1; ++k) {
                Vector3D<double> k_vect(min + (max - min) * i / static_cast<double>(Nx - 1),
                                        min + (max - min) * j / static_cast<double>(Ny - 1),
                                        min + (max - min) * k / static_cast<double>(Nz - 1));
                if (is_in_first_BZ(k_vect) && (!irreducible_wedge || is_in_irreducible_wedge(k_vect))) {
                    m_kpoints.push_back(k_vect);
                }
            }
        }
    }
}

/**
 * @brief Compute the energy and wave vector dependent dielectric function.
 * The formula used is the one from the paper "
 *
 * @param eta_smearing
 */
void DielectricFunction::compute_dielectric_function(double eta_smearing, int mpi_rank) {
    const int           index_first_conduction_band = 4;
    std::vector<double> iter_dielectric_function(m_kpoints.size());
    const bool          keep_eigenvectors = true;

    std::size_t nb_kpoints = m_kpoints.size();
    m_eigenvalues_k.resize(nb_kpoints);
    m_eigenvectors_k.resize(nb_kpoints);
    auto        start = std::chrono::high_resolution_clock::now();
    Hamiltonian hamiltonian_k(m_material, m_basisVectors);
    Hamiltonian hamiltonian_k_plus_q(m_material, m_basisVectors);
    for (std::size_t index_q = 0; index_q < m_qpoints.size(); ++index_q) {
        Vector3D<double>              q_vect = m_qpoints[index_q];
        if (q_vect.Length() <= 1e-15) {
            q_vect = Vector3D<double>(1e-15, 1e-15, 1e-15);
        }
        std::vector<Vector3D<double>> k_plus_q_vects(m_kpoints.size());
        std::transform(m_kpoints.begin(), m_kpoints.end(), k_plus_q_vects.begin(), [&q_vect](const Vector3D<double>& k) {
            return k + q_vect;
        });
        std::vector<double> list_total_sum(m_energies.size());
        for (std::size_t index_k = m_offset_k_index; index_k < m_offset_k_index + m_nb_kpoints; ++index_k) {
            if (index_q == 0) {
                auto k_vect = m_kpoints[index_k];
                hamiltonian_k.SetMatrix(k_vect, m_nonlocal_epm);
                hamiltonian_k.Diagonalize(keep_eigenvectors);
                m_eigenvalues_k[index_k]  = hamiltonian_k.eigenvalues();
                m_eigenvectors_k[index_k] = hamiltonian_k.get_eigenvectors();
                // Keep only firsts columns
                auto nb_rows = m_eigenvectors_k[index_k].rows();
                m_eigenvectors_k[index_k].conservativeResize(nb_rows, m_nb_bands);
            }
            auto k_plus_q_vect = k_plus_q_vects[index_k];
            hamiltonian_k_plus_q.SetMatrix(k_plus_q_vect, m_nonlocal_epm);
            hamiltonian_k_plus_q.Diagonalize(keep_eigenvectors);
            const auto&         eigenvalues_k_plus_q  = hamiltonian_k_plus_q.eigenvalues();
            const auto&         eigenvectors_k_plus_q = hamiltonian_k_plus_q.get_eigenvectors();
            std::vector<double> list_k_sum(m_energies.size());
            for (int idx_conduction_band = index_first_conduction_band; idx_conduction_band < m_nb_bands; ++idx_conduction_band) {
                for (int idx_valence_band = 0; idx_valence_band < index_first_conduction_band; ++idx_valence_band) {
                    double overlap_integral = pow(
                        std::abs(
                            eigenvectors_k_plus_q.col(idx_conduction_band).adjoint().dot(m_eigenvectors_k[index_k].col(idx_valence_band))),
                        2);
                    double delta_energy = (eigenvalues_k_plus_q[idx_conduction_band]) - m_eigenvalues_k[index_k][idx_valence_band];
                    for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
                        double energy = m_energies[index_energy];
                        double factor_1 =
                            (delta_energy - energy) / ((delta_energy - energy) * (delta_energy - energy) + eta_smearing * eta_smearing);
                        double factor_2 =
                            (delta_energy + energy) / ((delta_energy + energy) * (delta_energy + energy) + eta_smearing * eta_smearing);
                        double total_factor = factor_1 + factor_2;
                        list_k_sum[index_energy] += overlap_integral * total_factor;
                    }
                }
            }
            if (m_qpoints.size() <= 1) {
                // if there is only one q point in the list, we don't keep the eigenvectors, to save memory.
                m_eigenvectors_k[index_k].resize(1, 1);
                m_eigenvalues_k[index_k].resize(1);
            }
            for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
                list_total_sum[index_energy] += list_k_sum[index_energy];
            }
        }
        std::vector<double> list_epsilon(m_energies.size());
        for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
            list_epsilon[index_energy] = list_total_sum[index_energy];
        }
        auto end     = std::chrono::high_resolution_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count() / 1000.0;
        if (mpi_rank == 0) {
            std::cout << "Computed dielectric function for q = " << m_qpoints[index_q] << " -> " << index_q + 1 << "/" << m_qpoints.size()
                      << " in " << elapsed << " s" << std::endl;
        }
        start = std::chrono::high_resolution_clock::now();
        m_dielectric_function_real.push_back(list_epsilon);
    }
}

DielectricFunction DielectricFunction::merge_results(DielectricFunction                                  RootDielectricFunction,
                                                     const std::vector<std::vector<std::vector<double>>>& dielectric_function_results,
                                                     std::vector<int>                                    nb_kpoints_per_instance) {
    std::vector<std::vector<double>> total_dielectric_function;
    if (dielectric_function_results.size() == 0) {
        throw std::runtime_error("No results to merge");
    }
    if (dielectric_function_results.size() != nb_kpoints_per_instance.size()) {
        throw std::runtime_error("Number of results and number of k-points per instance do not match");
    }
    std::size_t total_number_kpoints = 0;
    for (std::size_t index_instance = 0; index_instance < nb_kpoints_per_instance.size(); ++index_instance) {
        total_number_kpoints += nb_kpoints_per_instance[index_instance];
    }
    std::cout << "Number total kpoint to the merge : " << total_number_kpoints << std::endl;
    // Add-up the k-contributions.
    for (std::size_t index_instance = 0; index_instance < dielectric_function_results.size(); ++index_instance) {
        // Add the contributions to epsilon for each q-point and energy.
        for (std::size_t index_q = 0; index_q < dielectric_function_results[index_instance].size(); ++index_q) {
            if (index_instance == 0) {
                total_dielectric_function.push_back(dielectric_function_results[index_instance][index_q]);
            } else {
                for (std::size_t index_energy = 0; index_energy < dielectric_function_results[index_instance][index_q].size();
                     ++index_energy) {
                    total_dielectric_function[index_q][index_energy] += dielectric_function_results[index_instance][index_q][index_energy];
                }
            }
        }
    }
    // Renormalization
    double       renormalization = 1.0 / static_cast<double>(total_number_kpoints);
    std::cout << "Renormalization: " << renormalization << std::endl;
    for (std::size_t index_q = 0; index_q < total_dielectric_function.size(); ++index_q) {
        Vector3D<double> q_vect    = RootDielectricFunction.m_qpoints[index_q];
        double           q_squared = pow(q_vect.Length(), 2);
        // TO IMPROVE: This is a hack to avoid division by zero.
        if (q_squared == 0.0) {
            q_squared = 1e-14;
        }
        for (std::size_t index_energy = 0; index_energy < total_dielectric_function[index_q].size(); ++index_energy) {
            total_dielectric_function[index_q][index_energy] *= renormalization;
            total_dielectric_function[index_q][index_energy] =
                1.0 + (2.0 * M_PI / q_squared) * total_dielectric_function[index_q][index_energy];
        }
    }

    DielectricFunction dielectric_function         = RootDielectricFunction;
    dielectric_function.m_dielectric_function_real = total_dielectric_function;
    return dielectric_function;
}

Eigen::MatrixXd create_kramers_matrix(std::size_t N) {
    Eigen::MatrixXd kramers_matrix(N, N);
    for (std::size_t idx_line = 0; idx_line < N; ++idx_line) {
        for (std::size_t idx_col = 0; idx_col < N; ++idx_col) {
            if (idx_line == idx_col) {
                kramers_matrix(idx_line, idx_col) = 0.0;
            } else {
                double a = double(idx_line) / double(static_cast<long>(idx_col * idx_col) - static_cast<long>(idx_line * idx_line));
                kramers_matrix(idx_line, idx_col) = a;
            }
        }
    }
    kramers_matrix *= -2.0 / M_PI;
    return kramers_matrix;
}

void DielectricFunction::apply_kramers_kronig() {
    std::cout << "Applying Kramers-Kronig" << std::endl;
    std::fstream kramers_matrix_file;
    kramers_matrix_file.open("Bkramers_matrix.dat", std::ios::out);
    Eigen::MatrixXd kramers_matrix2 = create_kramers_matrix(6);
    kramers_matrix_file << kramers_matrix2 << std::endl;
    kramers_matrix_file.close();
    std::cout << "Kramers matrix created" << std::endl;
    m_dielectric_function_imag.clear();
    m_dielectric_function_imag.resize(m_dielectric_function_real.size());
    Eigen::MatrixXd kramers_matrix = create_kramers_matrix(m_energies.size());
    for (std::size_t idx_q = 0; idx_q < m_qpoints.size(); ++idx_q) {
        Eigen::VectorXd epsilon(m_energies.size());
        for (std::size_t idx_energy = 0; idx_energy < m_energies.size(); ++idx_energy) {
            epsilon(idx_energy) = m_dielectric_function_real[idx_q][idx_energy] - 1.0;
        }
        Eigen::VectorXd epsilon_imag = kramers_matrix * epsilon;
        m_dielectric_function_imag[idx_q].resize(m_energies.size());
        for (std::size_t idx_energy = 0; idx_energy < m_energies.size(); ++idx_energy) {
            m_dielectric_function_imag[idx_q][idx_energy] = epsilon_imag(idx_energy);
        }
    }
}

void DielectricFunction::export_dielectric_function_at_q(const std::string& filename, std::size_t idx_q, bool name_auto) const {
    std::string outname;
    if (name_auto) {
        // outname = m_export_prefix + '_' + std::to_string(idx_q) + '_' + std::to_string(m_qpoints[idx_q].X) + "_" +
        // std::to_string(m_qpoints[idx_q].Y) + "_" +
        //           std::to_string(m_qpoints[idx_q].Z) + ".csv";
        outname = fmt::format("{}_{:05}_{:.6f}_{:.6f}_{:.6f}.csv",
                              m_export_prefix,
                              idx_q,
                              m_qpoints[idx_q].X,
                              m_qpoints[idx_q].Y,
                              m_qpoints[idx_q].Z);
    } else {
        outname = filename;
    }
    std::ofstream outfile(outname);
    std::cout << m_energies[0] << " " << m_dielectric_function_real[idx_q][0] << std::endl;
    outfile << "Energy (eV),EpsilonReal,EpsilonImaginary" << std::endl;
    for (std::size_t index_energy = 0; index_energy < m_energies.size(); ++index_energy) {
        outfile << m_energies[index_energy] << "," << m_dielectric_function_real[idx_q][index_energy] << ","
                << m_dielectric_function_imag[idx_q][index_energy] << std::endl;
    }
    outfile.close();
}

void DielectricFunction::export_dielectric_function(const std::string& filename, bool name_auto) const {
    for (std::size_t index_q = 0; index_q < m_qpoints.size(); ++index_q) {
        export_dielectric_function_at_q(filename, index_q, name_auto);
    }
}

void DielectricFunction::export_kpoints(const std::string& filename) const {
    std::ofstream file(filename);
    file << "X,Y,Z" << std::endl;
    for (const auto& k : m_kpoints) {
        file << k.X << "," << k.Y << "," << k.Z << std::endl;
    }
}

}  // namespace EmpiricalPseudopotential/**
 * @file NonLocalParameters.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-26
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <iostream>
#include <string>
#include <system_error>

#include "Constants.hpp"
#include "yaml-cpp/yaml.h"

namespace EmpiricalPseudopotential {

enum class non_local_well_type { square, gaussian, unknown };

/**
 * @brief Struct to store the non-local parameters.
 *
 * The formalism is taken from: 1. Pötz, W. & Vogl, P. Theory of optical-phonon deformation potentials in tetrahedral semiconductors.
 *  Phys. Rev. B 24, 2025–2037 (1981).
 *
 */
struct NonLocalParameters {
    double              m_alpha_0_cation;
    double              m_beta_0_cation;
    double              m_A2_cation;
    double              m_alpha_0_anion;
    double              m_beta_0_anion;
    double              m_A2_anion;
    double              m_R0_cation;
    double              m_R2_cation;
    double              m_R0_anion;
    double              m_R2_anion;
    non_local_well_type m_well_type;

    NonLocalParameters()
        : m_alpha_0_cation(0.0),
          m_beta_0_cation(0.0),
          m_A2_cation(0.0),
          m_alpha_0_anion(0.0),
          m_beta_0_anion(0.0),
          m_A2_anion(0.0),
          m_R0_cation(0.0),
          m_R2_cation(0.0),
          m_R0_anion(0.0),
          m_R2_anion(0.0),
          m_well_type(non_local_well_type::unknown) {}

    NonLocalParameters(double              alpha_0_cation,
                       double              beta_0_cation,
                       double              A2_cation,
                       double              alpha_0_anion,
                       double              beta_0_anion,
                       double              A2_anion,
                       double              R0_cation,
                       double              R2_cation,
                       double              R0_anion,
                       double              R2_anion,
                       non_local_well_type well_type)
        : m_alpha_0_cation(alpha_0_cation),
          m_beta_0_cation(beta_0_cation),
          m_A2_cation(A2_cation),
          m_alpha_0_anion(alpha_0_anion),
          m_beta_0_anion(beta_0_anion),
          m_A2_anion(A2_anion),
          m_R0_cation(R0_cation),
          m_R2_cation(R2_cation),
          m_R0_anion(R0_anion),
          m_R2_anion(R2_anion),
          m_well_type(well_type) {
        m_alpha_0_cation *= Constants::Ryd_to_eV;
        m_alpha_0_anion *= Constants::Ryd_to_eV;
        m_A2_cation *= Constants::Ryd_to_eV;
        m_A2_anion *= Constants::Ryd_to_eV;

        m_R0_anion *= Constants::angstrom_to_m;
        m_R2_anion *= Constants::angstrom_to_m;
        m_R0_cation *= Constants::angstrom_to_m;
        m_R2_cation *= Constants::angstrom_to_m;
    }

    void populate_non_local_parameters(const YAML::Node& node) {
        m_alpha_0_cation                        = Constants::Ryd_to_eV * node["alpha_0_cation"].as<double>();
        m_beta_0_cation                         = node["beta_0_cation"].as<double>();
        m_A2_cation                             = Constants::Ryd_to_eV * node["A2_cation"].as<double>();
        m_alpha_0_anion                         = Constants::Ryd_to_eV * node["alpha_0_anion"].as<double>();
        m_beta_0_anion                          = node["beta_0_anion"].as<double>();
        m_A2_anion                              = Constants::Ryd_to_eV * node["A2_anion"].as<double>();
        m_R0_cation                             = node["R0_cation"].as<double>();
        m_R2_cation                             = node["R2_cation"].as<double>();
        m_R0_anion                              = node["R0_anion"].as<double>();
        m_R2_anion                              = node["R2_anion"].as<double>();
        const std::string   well_type           = node["well_type"].as<std::string>();
        non_local_well_type non_local_well_type = non_local_well_type::unknown;
        if (well_type == "square") {
            non_local_well_type = non_local_well_type::square;
        } else if (well_type == "gaussian") {
            non_local_well_type = non_local_well_type::gaussian;
        } else {
            throw std::runtime_error("Unknown non-local well type");
        }
        m_well_type = non_local_well_type;
        m_R0_anion *= Constants::angstrom_to_m;
        m_R2_anion *= Constants::angstrom_to_m;
        m_R0_cation *= Constants::angstrom_to_m;
        m_R2_cation *= Constants::angstrom_to_m;
    }

    void print_non_local_parameters() const {
        std::cout << "alpha_0_cation: " << m_alpha_0_cation << std::endl;
        std::cout << "beta_0_cation: " << m_beta_0_cation << std::endl;
        std::cout << "A2_cation: " << m_A2_cation << std::endl;
        std::cout << "alpha_0_anion: " << m_alpha_0_anion << std::endl;
        std::cout << "beta_0_anion: " << m_beta_0_anion << std::endl;
        std::cout << "A2_anion: " << m_A2_anion << std::endl;
        std::cout << "R0_cation: " << m_R0_cation << std::endl;
        std::cout << "R2_cation: " << m_R2_cation << std::endl;
        std::cout << "R0_anion: " << m_R0_anion << std::endl;
        std::cout << "R2_anion: " << m_R2_anion << std::endl;
        std::cout << "well_type: " << static_cast<int>(m_well_type) << std::endl;
    }
};
}  // namespace EmpiricalPseudopotential/**
 * @file bessel_func.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-10
 *
 * @copyright Copyright (c) 2022
 *
 */

#include <cmath>
#include <iostream>

constexpr double pi = M_PI;

inline double J_neg_v(double v, double x) {
    return std::cos(-v * pi) * std::cyl_bessel_j(-v, x) - std::sin(-v * pi) * std::cyl_neumann(-v, x);
}

inline double generalized_bessel_cylindrical(double nu, double x) {
    if (nu >= 0) {
        return std::cyl_bessel_j(nu, x);
    } else {
        return J_neg_v(nu, x);
    }
}

inline double generalized_bessel(double nu, double x) {
    constexpr double epsilon = 1e-14;
    if (x < 0) {
        throw std::invalid_argument("Bessel function x argument must be positive. (x = " + std::to_string(x) + ")");
    }
    if (x < epsilon && nu == 0) {
        return 1.0;
    }
    if (x < epsilon && nu == 1) {
        return 0.0;
    }
    if (x < epsilon && nu >= 2) {
        return 0.0;
    }

    return sqrt(M_PI / (2.0 * x)) * generalized_bessel_cylindrical(nu + 0.5, x);
}

inline double bessel_2nd_order_first_kind(double x) {
    if (x == 0.0) {
        return 0.0;
    }
    return ((x * x + 3) * sinh(x) - 3 * x * cosh(x)) / (x * x * x);
}#include "Hamiltonian.h"

#define _USE_MATH_DEFINES 1
#include <math.h>

#include <complex>
#include <iostream>
#include <vector>

#include "Constants.hpp"
#include "NonLocalFunctional.hpp"
#include "SpinOrbitFunctional.hpp"
#include "Vector3D.h"

namespace EmpiricalPseudopotential {

Hamiltonian::Hamiltonian(const Material& material, const std::vector<Vector3D<int>>& basisVectors)
    : m_material(material),
      m_basisVectors(basisVectors) {
    const unsigned int basisSize   = static_cast<unsigned int>(basisVectors.size());
    m_constant_non_diagonal_matrix = Eigen::MatrixXcd::Zero(basisSize, basisSize);
    SetConstantNonDiagonalMatrix();
    matrix.resize(basisSize, basisSize);
}

/**
 * @brief Set the constant part of the Hamiltonian matrix.
 * The non-diagonal part of the matrix does not depend on the k-point, except for the non-local correction.
 *
 */
void Hamiltonian::SetConstantNonDiagonalMatrix() {
    const std::size_t     basisSize       = static_cast<unsigned int>(m_basisVectors.size());
    const double          latticeConstant = m_material.get_lattice_constant_meter();
    const Pseudopotential pseudopotential = m_material.get_pseudopotential();

    constexpr double one_eight = 1.0 / 8.0;
    Vector3D<double> tau{one_eight * latticeConstant, one_eight * latticeConstant, one_eight * latticeConstant};
    for (unsigned int i = 0; i < basisSize; ++i) {
        for (unsigned int j = 0; j < basisSize; ++j) {
            m_constant_non_diagonal_matrix(i, j) = pseudopotential.GetValue(m_basisVectors[i] - m_basisVectors[j], tau, latticeConstant);
        }
    }
}

void Hamiltonian::SetMatrix(const Vector3D<double>& k, bool add_non_local_correction, bool enable_soc) {
    const unsigned int basisSize       = static_cast<unsigned int>(m_basisVectors.size());
    const double       latticeConstant = m_material.get_lattice_constant_meter();
    constexpr double   one_eight       = 1.0 / 8.0;
    Vector3D<double>   tau{one_eight * latticeConstant, one_eight * latticeConstant, one_eight * latticeConstant};
    const double       fourier_factor = 2.0 * M_PI / latticeConstant;
    matrix                            = m_constant_non_diagonal_matrix;
    // diagonal elements
    const double diag_factor = pow(Constants::h_bar, 2) / (2.0 * Constants::m_e * Constants::q_e);
    for (unsigned int i = 0; i < basisSize; ++i) {
        Vector3D<double> real_k_vector = (k + m_basisVectors[i]);
        const double     KG2           = fourier_factor * fourier_factor * diag_factor * (real_k_vector * real_k_vector);
        matrix(i, i)                   = std::complex<double>(KG2, 0);
        // Non local correction
        if (add_non_local_correction) {
            std::complex<double> nl_correction = m_material.compute_pseudopotential_non_local_correction(real_k_vector, real_k_vector, tau);
            matrix(i, i) += nl_correction;
        }
    }

    // const Pseudopotential pseudopotential = m_material.get_pseudopotential();
    if (add_non_local_correction) {
        for (unsigned int i = 0; i < basisSize; ++i) {
            for (unsigned int j = 0; j < basisSize; ++j) {
                Vector3D<double> k_vector_i = (k + m_basisVectors[i]);
                Vector3D<double> k_vector_j = (k + m_basisVectors[j]);
                matrix(i, j) += m_material.compute_pseudopotential_non_local_correction(k_vector_i, k_vector_j, tau);
            }
        }
    }

    if (enable_soc) {
        // std::cout << "Spin-orbit correction enabled" << std::endl;
        SpinOrbitParameters SpinParams = m_material.get_spin_orbit_parameters();
        SpinOrbitCorrection soc_correction(m_material, SpinParams);
        std::size_t         matrix_size    = matrix.rows();
        Eigen::MatrixXcd    UpDownMatrix   = Eigen::MatrixXcd::Zero(matrix_size, matrix_size);
        Eigen::MatrixXcd    DownUpMatrix   = Eigen::MatrixXcd::Zero(matrix_size, matrix_size);
        Eigen::MatrixXcd    UpUpMatrix     = matrix;
        Eigen::MatrixXcd    DownDownMatrix = matrix;
        for (unsigned int i = 0; i < matrix_size; ++i) {
            for (unsigned int j = 0; j < matrix_size; ++j) {
                Vector3D<double>                          k_vector_i = (k + m_basisVectors[i]);
                Vector3D<double>                          k_vector_j = (k + m_basisVectors[j]);
                Eigen::Matrix<std::complex<double>, 2, 2> soc_contribution =
                    soc_correction.compute_soc_contribution(k_vector_i, k_vector_j, m_basisVectors[i], m_basisVectors[j], tau);
                // std::cout << soc_contribution << std::endl;
                UpUpMatrix(i, j) += soc_contribution(0, 0);
                UpDownMatrix(i, j) += soc_contribution(1, 0);
                DownUpMatrix(i, j) += soc_contribution(0, 1);
                DownDownMatrix(i, j) += soc_contribution(1, 1);
            }
        }
        matrix.resize(2 * matrix_size, 2 * matrix_size);
        matrix << UpUpMatrix, UpDownMatrix, DownUpMatrix, DownDownMatrix;
    }
}

void Hamiltonian::Diagonalize(bool keep_eigenvectors) {
    // Check matrix is Hermitian
    if (!matrix.isApprox(matrix.adjoint())) {
        std::cout << "Matrix is not Hermitian!" << std::endl;
        throw std::runtime_error("Matrix is not Hermitian");
    }
    solver.compute(matrix, keep_eigenvectors ? Eigen::ComputeEigenvectors : Eigen::EigenvaluesOnly);
    if (solver.info() != Eigen::Success) {
        std::cout << matrix << std::endl;
        throw std::runtime_error("Eigenvalue decomposition failed");
    }
}

}  // namespace EmpiricalPseudopotential/**
 * @file SpinOrbitParameters.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-30
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <iostream>
#include <string>
#include <system_error>

#include "Constants.hpp"
#include "yaml-cpp/yaml.h"

namespace EmpiricalPseudopotential {

/**
 * @brief Struct to store the Spin-Orbit Coupling (SOC) parameters.
 *
 */
struct SpinOrbitParameters {
    /**
     * @brief Period of the anion (line number in the periodic table).
     *
     */
    unsigned int m_period_anion = 0;

    /**
     * @brief Period of the cation (line number in the periodic table).
     *
     */
    unsigned int m_period_cation = 0;

    /**
     * @brief Length scale of the radial wave function for the cation.
     *
     */
    double m_radial_extent_cation = 0;

    /**
     * @brief Length scale of the radial wave function for the anion.
     *
     */
    double m_radial_extent_anion = 0;

    /**
     * @brief Fitting parameter alpha.
     *
     */
    double m_alpha = 0;

    /**
     * @brief Fitting parameter beta.
     *
     */
    double m_mu = 0;

    /**
     * @brief Default constructor.
     *
     */
    SpinOrbitParameters() = default;

    // Copy constructor
    SpinOrbitParameters(const SpinOrbitParameters& other) = default;
    SpinOrbitParameters& operator=(const SpinOrbitParameters& other) = default;
    SpinOrbitParameters(SpinOrbitParameters&& other)                 = default;

    /**
     * @brief Populate the spin-orbit parameters from a YAML node.
     *
     * @param node
     */
    void populate_from_yaml(const YAML::Node& node) {
        m_period_anion         = node["period_anion"].as<unsigned int>();
        m_period_cation        = node["period_cation"].as<unsigned int>();
        m_radial_extent_anion  = node["radial_extent_anion"].as<double>();
        m_radial_extent_cation = node["radial_extent_cation"].as<double>();
        m_alpha                = node["alpha_soc"].as<double>();
        m_mu                   = 1.0 * Constants::Ryd_to_eV * node["mu_soc"].as<double>();
        // print_parameters();
    }

    /**
     * @brief Display the spin-orbit parameters.
     *
     */
    void print_parameters() const {
        std::cout << "Spin-Orbit Coupling parameters:" << std::endl;
        std::cout << "Period anion: " << m_period_anion << std::endl;
        std::cout << "Period cation: " << m_period_cation << std::endl;
        std::cout << "Radial extent anion: " << m_radial_extent_anion << std::endl;
        std::cout << "Radial extent cation: " << m_radial_extent_cation << std::endl;
        std::cout << "Alpha: " << m_alpha << std::endl;
        std::cout << "Mu: " << m_mu << std::endl;
    }
};

}  // namespace EmpiricalPseudopotential// /**
//  * @file NonLocalFunctional.cpp
//  * @author remzerrr (remi.helleboid@gmail.com)
//  * @brief
//  * @version 0.1
//  * @date 2022-10-01
//  *
//  * @copyright Copyright (c) 2022
//  *
//  */

// #include "NonLocalFunctional.hpp"

// #include "Vector3D.h"
// #include "bessel_func.hpp"

// namespace EmpiricalPseudopotential {

// /**
//  * @brief Constructor of the NonLocalFunctional functor.
//  *
//  * @param non_local_parameters
//  * @param material
//  * @param tau
//  */
// NonLocalFunctor::NonLocalFunctor(const NonLocalParameters& non_local_parameters, const Material& material, const Vector3D<double>& tau)
//     : m_non_local_parameters(non_local_parameters),
//       m_material(material),
//       m_tau(tau),
//       m_cinetic_factor{(Constants::h_bar * Constants::h_bar) / (2.0 * Constants::m_e * Constants::q_e)},
//       m_fourrier_factor{2.0 * M_PI / m_material.get_lattice_constant_meter()},
//       m_V0_pref_factor(2.0 * M_PI / m_material.get_lattice_constant_meter()),
//       m_V2_square_well_pref_factor{m_V0_pref_factor},
//       m_V2_gaussian_well_pref_factor{pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_anion, 3.0) / m_material.get_atomic_volume())} {}


// /**
//  * @brief Compute the so called F_l function, which is used in the non-local pseudopotential correction.
//  * (See Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
//  * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).)
//  *
//  * For the values of function, see: Bloomfield, J. K., Face, S. H. P. & Moss, Z. Indefinite Integrals of Spherical Bessel
//  * Functions. Preprint at http://arxiv.org/abs/1703.06428 (2017). Equations 49 and 59.
//  *
//  * @param K1
//  * @param K2
//  * @param atomic_radii
//  * @param l
//  * @return double
//  */
// double NonLocalFunctorF_l_function(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii, int l) {
//     // This epsilon is used to avoid division by zero in the case of K1 == K2.
//     // The value is quite big, but lower values lead to numerical instabilities (noisy bands).
//     // Reason: K1 and K2 are of the order of  2PI / a_0 ~ 1e10 !
//     constexpr double EPSILON = 1.0e-4;
//     const double     norm_K1 = K1.Length();
//     const double     norm_K2 = K2.Length();
//     if (fabs(norm_K1 - norm_K2) > EPSILON) {
//         const double pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
//         const double F = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
//                          norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
//         return pre_factor * F;
//     } else if (norm_K1 > EPSILON) {
//         const double pre_factor = pow(atomic_radii, 3.0) / (2.0);
//         const double F          = pow(generalized_bessel(l, norm_K1 * atomic_radii), 2.0) -
//                          generalized_bessel(l - 1, norm_K1 * atomic_radii) * generalized_bessel(l + 1, norm_K1 * atomic_radii);
//         return pre_factor * F;
//     } else {
//         return (l==0) ? pow(atomic_radii, 3.0) / (3.0) : 0.0;
//     }
// }

// double F_2_function_gaussian(const Vector3D<double>& K1, const Vector3D<double>& K2, double atomic_radii) {
//     const double norm_K1    = K1.Length();
//     const double norm_K2    = K2.Length();
//     const double bessel_arg = 0.5 * (atomic_radii * atomic_radii) * norm_K1 * norm_K2;
//     return bessel_2nd_order_first_kind(bessel_arg) * exp(-0.25 * (norm_K1 * norm_K1 + norm_K2 * norm_K2) * atomic_radii * atomic_radii);
// }

// /**
//  * @brief Compute the non local correction to the EPM Hamiltonian.
//  * It follows: Chelikowsky, J. R. & Cohen, M. L. Nonlocal pseudopotential calculations for the electronic structure of eleven diamond
//  * and zinc-blende semiconductors. Phys. Rev. B 14, 556–582 (1976).
//  * See also: Pötz, W. & Vogl, P. Theory of optical-phonon deformation
//  * potentials in tetrahedral semiconductors. Phys. Rev. B 24, 2025–2037 (1981)
//  *
//  * K1 = (k + G)
//  * K2 = (k + G')
//  * tau = 1/8 * a * (1, 1, 1)
//  *
//  * @warning This function aims to be as close as possible to the original implementation of the authors.
//  * It might not be the most efficient way, even though the compiler may optimize it for us.
//  *
//  * @warning Only square well pseudopotential are supported for now on.
//  *
//  * @param K1
//  * @param K2
//  * @param tau
//  * @return std::complex<double>
//  */
// std::complex<double> Material::compute_pseudopotential_non_local_correction(const Vector3D<double>& K1_normalized,
//                                                                             const Vector3D<double>& K2_normalized,
//                                                                             const Vector3D<double>& tau) const {
//     const double           diag_factor       = pow(Constants::h_bar, 2) / (2.0 * Constants::m_e * Constants::q_e);
//     const double           fourier_factor    = 2.0 * M_PI / get_lattice_constant_meter();
//     const Vector3D<double> G_diff_normalized = (K1_normalized - K2_normalized);
//     const Vector3D<double> K1                = K1_normalized * fourier_factor;
//     const Vector3D<double> K2                = K2_normalized * fourier_factor;
//     const double           norm_K1           = K1.Length();
//     const double           norm_K2           = K2.Length();
//     const double           cos_angle_K1_K2   = compute_cos_angle(K1, K2);
//     const double           V_pre_factor      = 4.0 * M_PI / get_atomic_volume();
//     const double           legendre_0        = 1.0;
//     const double           legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);

//     // First atomic species: anion
//     double V_anion = 0;
//     // l = 0
//     const double A_0_anion = m_non_local_parameters.m_alpha_0_anion + diag_factor * m_non_local_parameters.m_beta_0_anion *
//                                                                           (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
//     const double F_0_anion = (m_non_local_parameters.m_R0_anion == 0.0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_anion, 0);
//     V_anion += V_pre_factor * A_0_anion * (2 * 0 + 1) * 1.0 * F_0_anion;
//     // l = 2
//     double V_anion_2 = 0.0;
//     if (m_non_local_parameters.m_A2_anion != 0) {
//         const double A_2_anion = m_non_local_parameters.m_A2_anion;
//         double       F_2_anion = 0.0;
//         if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
//             F_2_anion = F_l_function(K1, K2, m_non_local_parameters.m_R2_anion, 2);
//             V_anion_2 = V_pre_factor * A_2_anion * (2 * 2 + 1) * legendre_2 * F_2_anion;
//         } else {
//             F_2_anion = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_anion);
//             V_anion_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_anion, 3.0) / get_atomic_volume()) * A_2_anion *
//                         legendre_2 * F_2_anion;
//         }
//         V_anion += V_anion_2;
//     }

//     // Second atomic species: cation
//     double V_cation = 0;
//     // l = 0
//     const double F_0_cation = (m_non_local_parameters.m_R0_cation == 0) ? 0.0 : F_l_function(K1, K2, m_non_local_parameters.m_R0_cation, 0);
//     const double A_0_cation = m_non_local_parameters.m_alpha_0_cation + m_non_local_parameters.m_beta_0_cation * diag_factor *
//                                                                             (norm_K1 * norm_K2 - pow(this->get_fermi_momentum(), 2.0));
//     V_cation += V_pre_factor * A_0_cation * (2 * 0 + 1) * legendre_0 * F_0_cation;
//     // l = 2
//     double V_cation_2 = 0.0;
//     if (m_non_local_parameters.m_A2_cation != 0.0) {
//         const double A_2_cation = m_non_local_parameters.m_A2_cation;
//         double       F_2_cation = 0.0;
//         if (m_non_local_parameters.m_well_type == non_local_well_type::square) {
//             F_2_cation = F_l_function(K1, K2, m_non_local_parameters.m_R2_cation, 2);
//             V_cation_2 = V_pre_factor * A_2_cation * (2 * 2 + 1) * legendre_2 * F_2_cation;
//         } else {
//             F_2_cation = F_2_function_gaussian(K1, K2, m_non_local_parameters.m_R2_cation);
//             V_cation_2 = 5.0 * pow(M_PI, 1.5) * (pow(m_non_local_parameters.m_R2_cation, 3.0) / get_atomic_volume()) * A_2_cation *
//                          legendre_2 * F_2_cation;
//         }
//         V_cation += V_cation_2;
//     }

//     const double V_symmetric     = 1.0 * (V_anion + V_cation) / 2.0;
//     const double V_antisymmetric = 1.0 * (V_anion - V_cation) / 2.0;

//     constexpr double const_two        = 2.0;
//     const double     lattice_constant = this->get_lattice_constant_meter();
//     const double     Gtau             = (tau / lattice_constant) * (G_diff_normalized);

//     return std::complex<double>(cos(const_two * M_PI * Gtau) * V_symmetric, sin(const_two * M_PI * Gtau) * V_antisymmetric);
// }

// // /**
// //  * @brief Return the value of the F_l function for l = 0, at K1 == K2 == 0.
// //  *
// //  * @param norm_K
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_0_Gamma(double atomic_radii) const { return pow(atomic_radii, 3.0) / 3.0; }

// // /**
// //  * @brief Return the value of the F_l function for l = 0, at K1 == K2 (diagonal term).
// //  *
// //  * @param norm_K1
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_0_diag(double norm_K1, double atomic_radii) const {
// //     constexpr int l          = 0;
// //     const double  pre_factor = pow(atomic_radii, 3.0) / 2.0;
// //     const double  F          = pow(generalized_bessel(l, norm_K1 * atomic_radii), 2.0) -
// //                      generalized_bessel(l - 1, norm_K1 * atomic_radii) * generalized_bessel(l + 1, norm_K1 * atomic_radii);
// //     return m_V0_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 0, at K1 != K2 (coupling term).
// //  *
// //  * @param norm_K1
// //  * @param norm_K2
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_0_coupling(double norm_K1, double norm_K2, double atomic_radii) const {
// //     constexpr int l          = 0;
// //     const double  pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
// //     const double  F          = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
// //                      norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
// //     return m_V0_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 2, at K1 == K2 == 0 for a square potential.
// //  *
// //  * @param norm_K
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_2_diag_square_potential(double norm_K, double atomic_radii) const {
// //     constexpr int l          = 2;
// //     const double  pre_factor = pow(atomic_radii, 3.0) / 2.0;
// //     const double  F          = pow(generalized_bessel(l, norm_K * atomic_radii), 2.0) -
// //                      generalized_bessel(l - 1, norm_K * atomic_radii) * generalized_bessel(l + 1, norm_K * atomic_radii);
// //     return m_V2_square_well_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 2, at K1 =! K2 for a square potential.
// //  *
// //  * @param norm_K1
// //  * @param norm_K2
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_2_coupling_square_potential(double norm_K1, double norm_K2, double atomic_radii) const {
// //     constexpr int l          = 2;
// //     const double  pre_factor = pow(atomic_radii, 2.0) / (norm_K1 * norm_K1 - norm_K2 * norm_K2);
// //     const double  F          = norm_K1 * generalized_bessel(l + 1, norm_K1 * atomic_radii) * generalized_bessel(l, norm_K2 * atomic_radii) -
// //                      norm_K2 * generalized_bessel(l + 1, norm_K2 * atomic_radii) * generalized_bessel(l, norm_K1 * atomic_radii);
// //     return m_V2_square_well_pref_factor * pre_factor * F;
// // }

// // /**
// //  * @brief Return the value of the F_l function for l = 2, at any K1, K2 for a gaussian potential.
// //  *
// //  * @param norm_K
// //  * @param atomic_radii
// //  * @return double
// //  */
// // double NonLocalFunctor::F_2_gaussian(double norm_K1, double norm_K2, double atomic_radii) const {
// //     const double bessel_arg = 0.5 * (atomic_radii * atomic_radii) * norm_K1 * norm_K2;
// //     return m_V2_gaussian_well_pref_factor * bessel_2nd_order_first_kind(bessel_arg) *
// //            exp(-0.25 * (norm_K1 * norm_K1 + norm_K2 * norm_K2) * atomic_radii * atomic_radii);
// // }

// // double NonLocalFunctor::compute_anion_non_local_correction(const Vector3D<double>& K1_normalized,
// //                                                            const Vector3D<double>& K2_normalized) const {
// //     if (m_non_local_parameters.m_R0_anion == 0.0) {
// //         return 0.0;
// //     }
// //     const double cos_angle_K1_K2   = compute_cos_angle(K1_normalized, K2_normalized);
// //     const double legendre_0        = 1.0;
// //     const double legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);
// //     const double norm_K1_normlized = K1_normalized.Length();
// //     const double norm_K2_normlized = K2_normalized.Length();
// //     const double norm_K1           = norm_K1_normlized * m_fourrier_factor;
// //     const double norm_K2           = norm_K2_normlized * m_fourrier_factor;
// //     const double A_0_anion         = m_non_local_parameters.m_alpha_0_anion + m_cinetic_factor * m_non_local_parameters.m_beta_0_anion *
// //                                                                           (norm_K1 * norm_K2 - pow(m_material.get_fermi_momentum(), 2.0));
// //     double F_0 = 0.0;
// //     double F_2 = 0.0;
// //     if (fabs(norm_K1_normlized - norm_K2_normlized) > m_epsilon) {
// //         F_0 = F_0_coupling(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_coupling_square_potential(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //     } else if (norm_K1_normlized > m_epsilon) {
// //         F_0 = F_0_diag(norm_K1, m_non_local_parameters.m_R0_anion);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_diag_square_potential(norm_K1, m_non_local_parameters.m_R0_anion)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //     } else if (norm_K1 < m_epsilon) {
// //         F_0 = F_0_Gamma(m_non_local_parameters.m_R0_anion);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_Gamma_square_potential()
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_anion);
// //     }
// //     return A_0_anion * legendre_0 * F_0 + m_non_local_parameters.m_A2_anion * legendre_2 * F_2;
// // }

// // double NonLocalFunctor::compute_cation_non_local_correction(const Vector3D<double>& K1_normalized,
// //                                                             const Vector3D<double>& K2_normalized) const {
// //     if (m_non_local_parameters.m_R0_cation == 0.0) {
// //         return 0.0;
// //     }
// //     const double cos_angle_K1_K2   = compute_cos_angle(K1_normalized, K2_normalized);
// //     const double legendre_0        = 1.0;
// //     const double legendre_2        = 0.5 * (3 * cos_angle_K1_K2 * cos_angle_K1_K2 - 1);
// //     const double norm_K1_normlized = K1_normalized.Length();
// //     const double norm_K2_normlized = K2_normalized.Length();
// //     const double norm_K1           = norm_K1_normlized * m_fourrier_factor;
// //     const double norm_K2           = norm_K2_normlized * m_fourrier_factor;
// //     const double A_0_cation        = m_non_local_parameters.m_alpha_0_cation + m_cinetic_factor * m_non_local_parameters.m_beta_0_cation *
// //                                                                             (norm_K1 * norm_K2 - pow(m_material.get_fermi_momentum(), 2.0));
// //     double F_0 = 0.0;
// //     double F_2 = 0.0;
// //     if (fabs(norm_K1_normlized - norm_K2_normlized) > m_epsilon) {
// //         F_0 = F_0_coupling(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_coupling_square_potential(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //     } else if (norm_K1_normlized > m_epsilon) {
// //         F_0 = F_0_diag(norm_K1, m_non_local_parameters.m_R0_cation);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_diag_square_potential(norm_K1, m_non_local_parameters.m_R0_cation)
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //     } else if (norm_K1 < m_epsilon) {
// //         F_0 = F_0_Gamma(m_non_local_parameters.m_R0_cation);
// //         F_2 = (m_non_local_parameters.m_well_type == non_local_well_type::square)
// //                   ? F_2_Gamma_square_potential()
// //                   : F_2_gaussian(norm_K1, norm_K2, m_non_local_parameters.m_R0_cation);
// //     }
// //     return A_0_cation * legendre_0 * F_0 + m_non_local_parameters.m_A2_cation * legendre_2 * F_2;
// // }

// // std::complex<double> NonLocalFunctor::operator()(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized) const {
// //     const Vector3D<double> G_diff_normalized           = K1_normalized - K2_normalized;
// //     const double           anion_non_local_correction  = compute_anion_non_local_correction(K1_normalized, K2_normalized);
// //     const double           cation_non_local_correction = compute_cation_non_local_correction(K1_normalized, K2_normalized);
// //     const double           V_symmetric                 = anion_non_local_correction + cation_non_local_correction;
// //     const double           V_antisymmetric             = anion_non_local_correction - cation_non_local_correction;
// //     constexpr double       const_two                   = 2.0;
// //     const double           lattice_constant            = m_material.get_lattice_constant_meter();
// //     const double           Gtau                        = (m_tau / lattice_constant) * (G_diff_normalized);

// //     return std::complex<double>(cos(const_two * M_PI * Gtau) * V_symmetric, sin(const_two * M_PI * Gtau) * V_antisymmetric);
// // }

// }  // namespace EmpiricalPseudopotential/**
 * @file bz_mesh.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-07-07
 *
 * @copyright Copyright (c) 2022
 *
 */

#include <iostream>
#include <string>

#include "BandStructure.h"
#include "Vector3D.h"
#include "gmsh.h"

class bz_mesh_points {
 private:
    std::string                   m_filename;
    std::size_t                   m_nb_points = 0;
    std::vector<std::size_t>      m_node_tags;
    std::vector<Vector3D<double>> m_kpoints;

 public:
    explicit bz_mesh_points(const std::string& filename) : m_filename(filename), m_nb_points(0) {};
    ~bz_mesh_points() = default;

    void add_k_point(Vector3D<double> kpoint);
    void add_k_point(double k_x, double k_y, double k_z);

    void                           read_mesh();
    void                           read_mesh_from_csv();
    std::vector<Vector3D<double>>& get_kpoints() { return m_kpoints; };

    void add_band_on_mesh(const std::string& band_name, const std::vector<double>& band_values);
    void add_all_bands_on_mesh_separate_files(const std::string& out_dir, const EmpiricalPseudopotential::BandStructure& my_band);
    void add_all_bands_on_mesh(const std::string&                             out_filename,
                               const EmpiricalPseudopotential::BandStructure& my_band,
                               int                                            nb_valence_bands_to_export,
                               int                                            nb_conduction_bands_to_export);
    void add_all_bands_on_mesh(const std::string& out_filename, const std::vector<double>& band_values, int number_bands);
    void export_bands_as_csv(const std::vector<double>& band_values, int number_bands);
};/**
 * @file DielectricFunction.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-11-24
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <atomic>
#include <vector>

#include "Material.h"
#include "SymmetryPoints.h"
#include "Vector3D.h"

namespace EmpiricalPseudopotential {

class DielectricFunction {
 protected:
    std::vector<Vector3D<int>>    m_basisVectors;
    std::vector<Vector3D<double>> m_kpoints;
    const Material&               m_material;
    const int                     m_nb_bands;
    bool                          m_nonlocal_epm = false;

    std::vector<Vector3D<double>> m_qpoints;
    std::vector<double>           m_energies;

    std::vector<Eigen::VectorXd>  m_eigenvalues_k;
    std::vector<Eigen::MatrixXcd> m_eigenvectors_k;

    std::string m_export_prefix = "dielectric_function";

    /**
     * @brief The index of the first k-point this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the k-points.
     *
     * For a calculation on a single CPU the offset is 0.
     *
     */
    std::size_t m_offset_k_index = 0;

    /**
     * @brief Number of k-points this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the k-points.
     *
     * For a calculation on a single CPU this parameter is equal to the size of the m_list_k_points.
     *
     */
    std::size_t m_nb_kpoints = 0;

    /**
     * @brief m_dielectric_function[idx_q][idx_energy] is the dielectric function
     * q = m_qpoints[idx_q]
     * energy = m_energies[idx_energy]
     *
     */
    std::vector<std::vector<double>> m_dielectric_function_real;

    /**
     * @brief m_dielectric_function_imag[idx_q][idx_energy] is the dielectric function
     * q = m_qpoints[idx_q]
     * energy = m_energies[idx_energy]
     *
     */
    std::vector<std::vector<double>> m_dielectric_function_imag;

 public:
    DielectricFunction(const Material& material, const std::vector<Vector3D<int>>& basisVectors, const int nb_bands);

    DielectricFunction & operator=(const DielectricFunction &) = default;
    DielectricFunction(const DielectricFunction &) = default;


    void set_non_local_epm(const bool new_value) {m_nonlocal_epm = new_value;}

    /**
     * @brief Randomly generate a list of k-points in the irreducible wedge of the first Brillouin zone.
     *
     * @param nb_points
     */
    void generate_k_points_random(std::size_t nb_points);

    /**
     * @brief Generate a list of k-points in the irreducible wedge of the first Brillouin zone, using the
     * Monkhorst-Pack algorithm.
     *
     * @param nb_points
     */
    void generate_k_points_grid(std::size_t Nx, std::size_t Ny, std::size_t Nz, double shift, bool irreducible_wedge);

    /** Get the list of k-points.
     * @return const std::vector<Vector3D<double>>&
     */
    const std::vector<Vector3D<double>>& get_kpoints() const { return m_kpoints; }

    /**
     * @brief Get the offset of the first k-point this class is responsible for.
     *
     * @param offset_k_index
     */
    std::size_t get_offset_k_index() const { return m_offset_k_index; }

    /**
     * @brief Get the nb kpoints the instance of this class is responsible for.
     *
     * @return std::size_t
     */
    std::size_t get_nb_kpoints() const { return m_nb_kpoints; }

    /**
     * @brief Set the offset k index.
     *
     * @param offset_k_index
     */
    void set_offset_k_index(std::size_t offset_k_index) { m_offset_k_index = offset_k_index; }

    /**
     * @brief Set the number of k-points this class is responsible for.
     *
     * @param nb_kpoints
     */
    void set_nb_kpoints(std::size_t nb_kpoints) { m_nb_kpoints = nb_kpoints; }

    /**
     * @brief Set the list of q-points for which the dielectric function will be computed.
     *
     * @param kpoints
     */
    void set_qpoints(const std::vector<Vector3D<double>>& qpoints) { m_qpoints = qpoints; }

    /**
     * @brief Set the list of energies for which the dielectric function will be computed.
     *
     * @param energies
     */
    void set_energies(const std::vector<double>& energies) { m_energies = energies; }

    void set_export_prefix(const std::string& prefix) { m_export_prefix = prefix; }

    /**
     * @brief Compute the dielectric function.
     *
     */
    void compute_dielectric_function(double eta_smearing = 1e-2, int mpi_rank = 0);

    void clear_eigen_states() {
        m_eigenvalues_k.clear();
        m_eigenvectors_k.clear();
    }

    /**
     * @brief Get the dielectric function result.
     *
     * @return const std::vector<std::vector<double>>&
     */
    const std::vector<std::vector<double>>& get_dielectric_function() const { return m_dielectric_function_real; }

    const std::vector<double> get_flat_dielectric_function() const {
        std::vector<double> result;
        for (const auto& q : m_dielectric_function_real) {
            result.insert(result.end(), q.begin(), q.end());
        }
        return result;
    }

    /**
     * @brief Merge the results of multiple instances of this class.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the k-points.
     *
     * @param dielectric_function_results
     * @param nb_kpoints_per_instance
     * @return std::vector<std::vector<double>>
     */
    static DielectricFunction merge_results(DielectricFunction                                  RootDielectricFunction,
                                            const std::vector<std::vector<std::vector<double>>>& dielectric_function_results,
                                            std::vector<int>                                    nb_kpoints_per_instance);

    /**
     * @brief Apply Kramer's Kronig relations to the dielectric function to obtain the real part.
     *
     */
    void apply_kramers_kronig();

    /**
     * @brief Export the grid of k-points to a file.
     *
     * @param filename
     */
    void export_kpoints(const std::string& filename) const;

    /**
     * @brief Export the results of the computation of the dielectric function to a file.
     *
     * @param filename
     */
    void export_dielectric_function_at_q(const std::string& filename, std::size_t idx_q, bool name_auto) const;

    void export_dielectric_function(const std::string& filename, bool name_auto) const;
};

}  // namespace EmpiricalPseudopotential/**
 * @file SpinOrbitDunctional.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-30
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "SpinOrbitFunctional.hpp"

#include <cmath>
#include <iostream>
#include <vector>

namespace EmpiricalPseudopotential {

double SpinOrbitCorrection::compute_B2_cation(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_cation);
    double B2    = 1.0 / std::pow((1.0 + kappa * kappa), 3.0);
    return B2;
}

double SpinOrbitCorrection::compute_B2_anion(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_anion);
    double B2    = 1.0 / std::pow((1.0 + kappa * kappa), 3.0);
    return B2;
}

double SpinOrbitCorrection::compute_B3_cation(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_cation);
    double B3    = (5 - kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 4.0));
    return B3;
}

double SpinOrbitCorrection::compute_B3_anion(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_anion);
    double B3    = (5 - kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 4.0));
    return B3;
}

double SpinOrbitCorrection::compute_B4_cation(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_cation);
    double B4    = (5.0 - 3.0 * kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 5.0));
    return B4;
}

double SpinOrbitCorrection::compute_B4_anion(const Vector3D<double>& K) const {
    double kappa = K.Length() * (Constants::bohr_radius / m_soc_parameters.m_radial_extent_anion);
    double B4    = (5.0 - 3.0 * kappa * kappa) / (5.0 * pow((1.0 + kappa * kappa), 5.0));
    return B4;
}

double SpinOrbitCorrection::compute_lambda_1(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_1 = m_soc_parameters.m_mu * compute_B3_cation(K) * compute_B3_cation(Kp);
    return lambda_1;
}

double SpinOrbitCorrection::compute_lambda_2(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_2 = m_soc_parameters.m_alpha * m_soc_parameters.m_mu * compute_B3_anion(K) * compute_B3_anion(Kp);
    return lambda_2;
}

double SpinOrbitCorrection::compute_lambda_sym(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_1   = compute_lambda_1(K, Kp);
    double lambda_2   = compute_lambda_2(K, Kp);
    double lambda_sym = (lambda_1 + lambda_2) / 2.0;
    return lambda_sym;
}

double SpinOrbitCorrection::compute_lambda_antisym(const Vector3D<double>& K, const Vector3D<double>& Kp) const {
    double lambda_1       = compute_lambda_1(K, Kp);
    double lambda_2       = compute_lambda_2(K, Kp);
    double lambda_antisym = (lambda_1 - lambda_2) / 2.0;
    return lambda_antisym;
}

Eigen::Matrix<std::complex<double>, 2, 2> SpinOrbitCorrection::compute_pauli_state_dot_product(const Vector3D<double>& myVect) {
    using namespace std::complex_literals;
    std::complex<double>                      a00 = myVect.Z;
    std::complex<double>                      a01 = myVect.X - myVect.Y * 1i;
    std::complex<double>                      a10 = myVect.X + myVect.Y * 1i;
    std::complex<double>                      a11 = -myVect.Z;
    Eigen::Matrix<std::complex<double>, 2, 2> res_matrix;
    res_matrix << a00, a10, a01, a11;
    return res_matrix;
}

Eigen::Matrix<std::complex<double>, 2, 2> SpinOrbitCorrection::compute_soc_contribution(const Vector3D<double>& K,
                                                                                        const Vector3D<double>& Kp,
                                                                                        const Vector3D<double>& G,
                                                                                        const Vector3D<double>& Gp,
                                                                                        const Vector3D<double>& tau) const {
    using namespace std::complex_literals;
    Vector3D<double> Kn = (m_material.get_lattice_constant_meter() / (2.0 * M_PI)) * K;
    Vector3D<double> Knp = (m_material.get_lattice_constant_meter() / (2.0 * M_PI)) * Kp;
    double lambda_sym     = compute_lambda_sym(Kn, Knp);
    double lambda_antisym = compute_lambda_antisym(Kn, Knp);
    Vector3D<double>                          cross_K_Kp       = cross_product(Kn, Knp);
    Eigen::Matrix<std::complex<double>, 2, 2> res_matrix       = compute_pauli_state_dot_product(cross_K_Kp);
    Vector3D<double>                          diff_G           = G - Gp;
    const double                              lattice_constant = m_material.get_lattice_constant_meter();
    const double                              Gtau             = (2 * M_PI / lattice_constant) * tau * diff_G;
    std::complex<double>                      sym_factor       = -1i * lambda_sym * std::cos(Gtau);
    std::complex<double>                      antisym_factor   = lambda_antisym * std::sin(Gtau);
    res_matrix *= (2.0 * M_PI / lattice_constant) * (2.0 * M_PI / lattice_constant) * (sym_factor + antisym_factor);
    return res_matrix;
}

}  // namespace EmpiricalPseudopotential// /**
//  * @file NonLocalFunctional.hpp
//  * @author remzerrr (remi.helleboid@gmail.com)
//  * @brief
//  * @version 0.1
//  * @date 2022-10-01
//  *
//  * @copyright Copyright (c) 2022
//  *
//  */

// #pragma once

// #include <algorithm>
// #include <cmath>
// #include <complex>
// #include <iostream>
// #include <string>
// #include <system_error>
// #include <vector>

// #include "Constants.hpp"
// #include "Material.h"
// #include "NonLocalParameters.hpp"
// #include "Vector3D.h"

// namespace EmpiricalPseudopotential {

// /**
//  * @brief Functor class to compute the non-local correction to the Hamiltonian.
//  * The notation of the functions follow the paper:
//  * Pötz, W. & Vogl, P. Theory of optical-phonon deformation potentials in tetrahedral semiconductors.
//  * Phys. Rev. B 24, 2025–2037 (1981).
//  *
//  */
// class NonLocalFunctor {
//  private:
//     NonLocalParameters      m_non_local_parameters;
//     Material                m_material;
//     Vector3D<double>        m_tau;
//     const double            m_cinetic_factor;
//     const double            m_fourrier_factor;
//     const double            m_V0_pref_factor;
//     const double            m_V2_square_well_pref_factor;
//     const double            m_V2_gaussian_well_pref_factor;
//     static constexpr double m_epsilon = 1e-10;

//  public:
//     NonLocalFunctor() = delete;
//     NonLocalFunctor(const NonLocalParameters& non_local_parameters, const Material& material, const Vector3D<double>& tau);

//     double F_0_Gamma(double atomic_radii) const;
//     double F_0_diag(double norm_K, double atomic_radii) const;
//     double F_0_coupling(double norm_K1, double norm_K2, double atomic_radii) const;

//     double F_2_Gamma_square_potential() const { return 0.0; }
//     double F_2_diag_square_potential(double norm_K, double atomic_radii) const;
//     double F_2_coupling_square_potential(double norm_K1, double norm_K2, double atomic_radii) const;
//     double F_2_gaussian(double norm_K1, double norm_K2, double atomic_radii) const;

//     double compute_anion_non_local_correction(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized2) const;
//     double compute_cation_non_local_correction(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized) const;

//     std::complex<double> operator()(const Vector3D<double>& K1_normalized, const Vector3D<double>& K2_normalized) const;
// };

// }  // namespace EmpiricalPseudopotential#include "Pseudopotential.h"

#define _USE_MATH_DEFINES 1
#include <array>
#include <cmath>
#include <complex>
#include <numbers>

#include "Constants.hpp"

namespace EmpiricalPseudopotential {

Pseudopotential::Pseudopotential(double V3S, double V4S, double V8S, double V11S, double V3A, double V4A, double V8A, double V11A)
    : m_V3S(V3S),
      m_V4S(V4S),
      m_V8S(V8S),
      m_V11S(V11S),
      m_V3A(V3A),
      m_V4A(V4A),
      m_V8A(V8A),
      m_V11A(V11A) {}

#include <array>
#include <cmath>
#include <complex>
#include <numbers>

std::complex<double> Pseudopotential::GetValue(const Vector3D<int>& G, const Vector3D<double>& tau, double lattice_constant) const {
    // Optional: enforce fcc selection rule (all-even or all-odd Miller indices)
    const bool same_parity = ((G.X & 1) == (G.Y & 1)) && ((G.Y & 1) == (G.Z & 1));
    if (!same_parity) return {0.0, 0.0};

    const int    G2   = G * G;  // integer dot product h^2 + k^2 + l^2
    const double kfac = 2.0 * std::numbers::pi_v<double> / lattice_constant;
    const double Gtau = kfac * (tau * G);  // dimensionless phase

    double VS = 0.0, VA = 0.0;
    switch (G2) {
        case 3:
            VS = m_V3S;
            VA = m_V3A;
            break;
        case 4:
            VS = m_V4S;
            VA = m_V4A;
            break;
        case 8:
            VS = m_V8S;
            VA = m_V8A;
            break;
        case 11:
            VS = m_V11S;
            VA = m_V11A;
            break;
        default: 
            break;
    }

    // V(G) = VS cos(G·τ) + i VA sin(G·τ)
    const double c = std::cos(Gtau);
    const double s = std::sin(Gtau);
    return {VS * c, VA * s};
}

void Pseudopotential::print_parameters() const {
    std::cout << "V3S = " << m_V3S << std::endl;
    std::cout << "V4S = " << m_V4S << std::endl;
    std::cout << "V8S = " << m_V8S << std::endl;
    std::cout << "V11S = " << m_V11S << std::endl;
    std::cout << "V3A = " << m_V3A << std::endl;
    std::cout << "V4A = " << m_V4A << std::endl;
    std::cout << "V8A = " << m_V8A << std::endl;
    std::cout << "V11A = " << m_V11A << std::endl;
}

}  // namespace EmpiricalPseudopotential/**
 * @file single_part_fbmc.cpp
 * @author your name (you@domain.com)
 * @brief 
 * @version 0.1
 * @date 2025-09-19
 * 
 * @copyright Copyright (c) 2025
 * 
 */


#include <algorithm>
#include <array>
#include <cmath>
#include <fstream>
#include <iostream>
#include <map>
#include <numeric>
#include <random>
#include <vector>

#include "Constants.hpp"
#include "single_part_fbmc.hpp"
namespace fbmc {

Single_particle_simulation::Single_particle_simulation(bz_mesh::ElectronPhonon*     ptr_mesh_bz,
                                                       const Bulk_environment&      bulk_env,
                                                       const Simulation_parameters& sim_params)
    : m_ptr_mesh_bz(ptr_mesh_bz),
      m_bulk_env(bulk_env),
      m_sim_params(sim_params) {
    double m_time = 0.0;
    // Initialize the particle
    const std::size_t index = 0;
    m_particle              = particle(index, particle_type::electron, m_ptr_mesh_bz);
    m_particle.set_position({0.0, 0.0, 0.0});
    const double thermal_energy = bulk_env.m_temperature * EmpiricalPseudopotential::Constants::k_b_eV;
    m_particle.set_energy(thermal_energy);
    m_particle.set_velocity({0.0, 0.0, 0.0});
    std::cout << "Thermal energy at " << bulk_env.m_temperature << " K: " << thermal_energy << " eV" << std::endl;
    vector3 initial_k = m_ptr_mesh_bz->draw_random_k_point_at_energy(thermal_energy, 0, m_particle.get_random_generator());
    m_particle.set_k_vector(initial_k);
    std::cout << "Initial k-vector (drawn at thermal energy): " << initial_k << std::endl;
    bz_mesh::Tetra* containing_tetra = m_ptr_mesh_bz->find_tetra_at_location(m_particle.get_k_vector());
    if (containing_tetra == nullptr) {
        throw std::runtime_error("Initial k-point is out of the Brillouin zone mesh.");
    }
    m_particle.set_containing_bz_mesh_tetra(containing_tetra);
    m_particle.update_group_velocity();
    m_particle.update_energy();

    double init_energy_true = containing_tetra->interpolate_energy_at_band(m_particle.get_k_vector(), 0);

    std::cout << "Initial k-vector: " << m_particle.get_k_vector().x() << " " << m_particle.get_k_vector().y() << " "
              << m_particle.get_k_vector().z() << std::endl;
    std::cout << "Initial energy (set): " << m_particle.get_energy() << " eV" << std::endl;
    std::cout << "Initial energy (true): " << init_energy_true << " eV" << std::endl;
}

void Single_particle_simulation::run_simulation() {
    // Freefligts time in a file
    std::ofstream free_flight_time_file("free_flight_times.txt");
    if (!free_flight_time_file.is_open()) {
        std::cerr << "Could not open free flight time file for writing." << std::endl;
        return;
    }

    // Compute total scattering rate
    const double p_gamma = m_ptr_mesh_bz->compute_P_Gamma();
    std::cout << "Total scattering rate: " << p_gamma << " 1/s" << std::endl;
    if (p_gamma <= 0.0) {
        std::cerr << "Total scattering rate is zero or negative." << std::endl;
        return;
    }

    int nb_foldings = 0;

    while (m_time < m_sim_params.m_simulation_time) {
        // std::cout << "Time: " << m_time << " s" << std::endl;
        m_particle.update_history();

        // Draw free flight time
        m_particle.draw_free_flight_time(p_gamma);
        free_flight_time_file << m_particle.get_current_free_flight_time() << std::endl;

        // Update time
        m_time += m_particle.get_current_free_flight_time();

        // Update k-vector
        m_particle.update_k_vector(m_bulk_env.m_electric_field);
        // std::cout << "New k-vector: " << m_particle.get_k_vector().x() << " " << m_particle.get_k_vector().y() << " "
        //           << m_particle.get_k_vector().z() << std::endl;

        // Find containing tetrahedron
        bz_mesh::Tetra* containing_tetra = m_ptr_mesh_bz->find_tetra_at_location(m_particle.get_k_vector());
        if (containing_tetra == nullptr) {
            // TEST
            bool is_inside_bz = m_ptr_mesh_bz->inside_ws_bcc(m_particle.get_k_vector());
            if (is_inside_bz) {
                std::cout << "ERROR : Particle is inside the Wigner-Seitz cell but outside the mesh." << std::endl;
            } else {
                std::cout << "GOOD : Particle is outside the Wigner-Seitz cell and the mesh." << std::endl;
            }

            std::cerr << "Particle exited the Brillouin zone mesh ("
                      << "k = " << m_particle.get_k_vector().x() << " " << m_particle.get_k_vector().y() << " "
                      << m_particle.get_k_vector().z() << "). Folding back..." << std::endl;
            // Fold back into the first Brillouin zone
            vector3 folded_k = m_ptr_mesh_bz->fold_ws_bcc(m_particle.get_k_vector());
            m_particle.set_k_vector(folded_k);
            containing_tetra = m_ptr_mesh_bz->find_tetra_at_location(m_particle.get_k_vector());
            if (containing_tetra == nullptr) {
                std::cerr << "Particle still outside the Brillouin zone mesh after folding back." << std::endl;
                break;
            } else {
                std::cout << "Particle folded back into the Brillouin zone mesh at k = " << folded_k.x() << " " << folded_k.y() << " "
                          << folded_k.z() << std::endl;
                nb_foldings++;
            }
        }
        m_particle.set_containing_bz_mesh_tetra(containing_tetra);

        m_particle.update_energy();

        // Update group velocity
        m_particle.update_group_velocity();

        // Update position
        vector3 new_position = m_particle.get_position() + m_particle.get_velocity() * m_particle.get_current_free_flight_time();
        m_particle.set_position(new_position);

        // Scatter the particle
        std::array<double, 8> scattering_rates      = m_particle.interpolate_phonon_scattering_rate_at_location(m_particle.get_k_vector());
        double                total_scattering_rate = std::accumulate(scattering_rates.begin(), scattering_rates.end(), 0.0);
        if (total_scattering_rate <= 0.0) {
            std::cerr << "Total scattering rate is zero or negative during scattering." << std::endl;
            break;
        }
        std::uniform_real_distribution<double> distribution(0.0, total_scattering_rate);
        double                                 random_value     = distribution(m_particle.get_random_generator());
        double                                 cumulative_rate  = 0.0;
        std::size_t                            scattering_event = 0;
        bool                                   event_found      = false;
        for (std::size_t idx_mode = 0; idx_mode < scattering_rates.size(); ++idx_mode) {
            cumulative_rate += scattering_rates[idx_mode];
            if (random_value <= cumulative_rate) {
                scattering_event = idx_mode;
                event_found      = true;
                break;
            }
        }
        // std::cout << "Scattering event: " << scattering_event << " at energy " << m_particle.get_energy() << " eV" << std::endl;
        if (!event_found) {
            std::cout << "Self-scattering event." << std::endl;
            continue;
        }
    }
    std::cout << "Simulation finished at time " << m_time << " s" << std::endl;
    std::cout << "Number of foldings: " << nb_foldings << std::endl;
    free_flight_time_file.close();
}

void Single_particle_simulation::export_history(const std::string& filename) {
    std::ofstream history_file(filename);
    if (!history_file.is_open()) {
        std::cerr << "Could not open history file for writing." << std::endl;
        return;
    }
    constexpr double lattice_constant     = 5.43e-10;  // in meters (for silicon)
    constexpr double normalization_factor = 2.0 * M_PI / lattice_constant;

    // Write particle history to file
    auto history = m_particle.get_history();
    history_file << "time,x,y,z,kx,ky,kz,vx,vy,vz,energy\n";
    for (std::size_t step = 0; step < history.get_number_of_steps(); ++step) {
        history_file << history.m_time_history[step] << "," << history.m_positions[step].x() << "," << history.m_positions[step].y() << ","
                     << history.m_positions[step].z() << "," << history.m_k_vectors[step].x() / normalization_factor << ","
                     << history.m_k_vectors[step].y() / normalization_factor << "," << history.m_k_vectors[step].z() / normalization_factor
                     << "," << history.m_velocities[step].x() << "," << history.m_velocities[step].y() << ","
                     << history.m_velocities[step].z() << "," << history.m_energies[step] << "\n";
    }
    history_file.close();
    std::cout << "Particle history exported to " << filename << std::endl;
}

}  // namespace fbmc/**
 * @file single_part_fbmc.hpp
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2025-09-17
 *
 * @copyright Copyright (c) 2025
 *
 */

#pragma once

#include <array>
#include <cmath>
#include <cstddef>

#include "bz_mesh.hpp"
#include "bz_states.hpp"
#include "electron_phonon.hpp"
#include "particle.hpp"
#include "vector.hpp"

namespace fbmc {

struct Bulk_environment {
    double  m_temperature;
    vector3 m_electric_field;
    double  m_doping_concentration;
};

struct Simulation_parameters {
    double      m_simulation_time;
    std::size_t m_export_frequency;
};

class Single_particle_simulation {
 private:
    bz_mesh::ElectronPhonon* m_ptr_mesh_bz;
    Bulk_environment         m_bulk_env;
    Simulation_parameters    m_sim_params;
    particle                 m_particle;

    double m_time = 0.0;

 public:
    double a = 0;
    Single_particle_simulation(bz_mesh::ElectronPhonon*     ptr_mesh_bz,
                               const Bulk_environment&      bulk_env,
                               const Simulation_parameters& sim_params);

    void run_simulation();

    void export_history(const std::string& filename);
};
}  // namespace fbmc/**
 * @file particle.hpp
 * @author your name (you@domain.com)
 * @brief Particle simulation class for the FBMC (Full Band Monte Carlo) method.
 * @version 0.1
 * @date 2025-09-19
 *
 * @copyright Copyright (c) 2025
 *
 */

#pragma once

#include <array>
#include <iostream>
#include <memory>
#include <random>
#include <vector>

#include "bz_mesh.hpp"
#include "vector.hpp"
// #include "particle_history_mc.hpp"
#include "electron_phonon.hpp"
#include "mesh_tetra.hpp"
#include "vector.hpp"

namespace fbmc {

enum class particle_type { electron = -1, hole = 1 };

using vector3 = bz_mesh::vector3;

struct scattering_rate {
    std::array<double, 8> m_phonon_rate;
    double                m_phonon_rate_total      = 0.0;
    double                m_impurity_rate          = 0.0;
    double                m_impact_ionization_rate = 0.0;
};

struct particle_history {
    std::size_t          m_index;
    std::vector<double>  m_time_history;
    std::vector<vector3> m_positions;
    std::vector<vector3> m_k_vectors;
    std::vector<vector3> m_velocities;
    std::vector<double>  m_energies;

    particle_history() : m_index(0), m_positions(), m_k_vectors(), m_velocities(), m_energies() {}
    particle_history(std::size_t index) : m_index(index), m_positions(), m_k_vectors(), m_velocities(), m_energies() {}

    void add_time(double time) { m_time_history.push_back(time); }
    void add_position(const vector3& position) { m_positions.push_back(position); }
    void add_k_vector(const vector3& k_vector) { m_k_vectors.push_back(k_vector); }
    void add_velocity(const vector3& velocity) { m_velocities.push_back(velocity); }
    void add_energy(double energy) { m_energies.push_back(energy); }

    void add_particle_state(const double&  my_time,
                            const vector3& my_position,
                            const vector3& my_k_vector,
                            const vector3& my_velocity,
                            double         my_energy) {
        add_time(my_time);
        add_position(my_position);
        add_k_vector(my_k_vector);
        add_velocity(my_velocity);
        add_energy(my_energy);
    }
    std::size_t get_number_of_steps() const { return m_positions.size(); }
};

class particle {
 protected:
    /**
     * @brief Pointer to the Brillouin Zone Mesh.
     *
     */
    bz_mesh::ElectronPhonon* m_mesh_bz = nullptr;

    /**
     * @brief Index of the particle in the simulation.
     *
     */
    std::size_t m_index = 0;

    /**
     * @brief Type of the particle (electron or hole).
     *
     */
    particle_type m_type = particle_type::electron;

    /**
     * @brief Time of the particle in the simulation.
     *
     */
    double m_time = 0.0;

    /**
     * @brief Position of the particle in the real space.
     *
     */
    vector3 m_position = {0.0, 0.0, 0.0};

    /**
     * @brief Wave vector of the particle.
     *
     */
    vector3 m_k_vector = {0.0, 0.0, 0.0};

    /**
     * @brief Band index of the particle.
     *
     */
    int m_band_index = 0;

    /**
     * @brief Velocity of the particle.
     *
     */
    vector3 m_velocity = {0.0, 0.0, 0.0};

    /**
     * @brief Energy of the particle.
     *
     */
    double m_energy = 0.0;

    /**
     * @brief Free flight time of the particle.
     *
     */
    double m_current_free_flight_time = 0.0;

    /**
     * @brief Pointer to the tetrahedron in which the particle lies.
     *
     */
    bz_mesh::Tetra* m_containing_bz_mesh_tetra = nullptr;

    /**
     * @brief Random number generator.
     *
     */
    std::mt19937 m_random_generator = std::mt19937(std::random_device{}());

    /**
     * @brief Random number distribution.
     *
     */
    std::uniform_real_distribution<double> m_random_distribution = std::uniform_real_distribution<double>(0.0, 1.0);

    /**
     * @brief History of the particle during the simulation.
     *
     */
    particle_history m_history;

 public:
    particle() = default;
    particle(std::size_t index, particle_type type, bz_mesh::ElectronPhonon* mesh);
    particle(const particle& other)            = default;
    particle& operator=(const particle& other) = default;
    ~particle()                                = default;

    std::size_t     get_index() const { return m_index; }
    void            set_index(std::size_t index) { m_index = index; }
    particle_type   get_type() const { return m_type; }
    double          get_charge_sign() const { return static_cast<double>(m_type); }
    double          get_time() const { return m_time; }
    void            set_time(double time) { m_time = time; }
    const vector3&  get_position() const { return m_position; }
    void            set_position(const vector3& position) { m_position = position; }
    const vector3&  get_k_vector() const { return m_k_vector; }
    void            set_k_vector(const vector3& k_vector) { m_k_vector = k_vector; }
    const vector3&  get_velocity() const { return m_velocity; }
    void            set_velocity(const vector3& velocity) { m_velocity = velocity; }
    double          get_energy() const { return m_energy; }
    void            set_energy(double energy) { m_energy = energy; }
    double          get_current_free_flight_time() const { return m_current_free_flight_time; }
    bz_mesh::Tetra* get_containing_bz_mesh_tetra() const { return m_containing_bz_mesh_tetra; }
    void set_containing_bz_mesh_tetra(bz_mesh::Tetra* containing_bz_mesh_tetra) { m_containing_bz_mesh_tetra = containing_bz_mesh_tetra; }
    void set_random_generator(std::mt19937 random_generator) { m_random_generator = random_generator; }

    std::array<double, 8> interpolate_phonon_scattering_rate_at_location(const vector3& location);
    void                  compute_post_phonon_scattering_state();

    void draw_free_flight_time(double p_gamma);
    void update_k_vector(const vector3& v_electric_field);
    void update_energy();
    void update_group_velocity();

    std::mt19937& get_random_generator() { return m_random_generator; }
    void          draw_random_k_point_at_energy(double energy, std::size_t idx_band) {
        m_mesh_bz->draw_random_k_point_at_energy(energy, idx_band, get_random_generator());
    }
    void                    update_history() { m_history.add_particle_state(m_time, m_position, m_k_vector, m_velocity, m_energy); }
    const particle_history& get_history() const { return m_history; }
    void                    reset_history() { m_history = particle_history(m_index); }
};

}  // namespace fbmc/**
 * @file particle.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-09-10
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "particle.hpp"

#include <random>

#include "Constants.hpp"
namespace fbmc {

particle::particle(std::size_t index, particle_type arg_particle_type, bz_mesh::ElectronPhonon* ptr_mesh_bz)
    : m_index(index),
      m_type(arg_particle_type),
      m_mesh_bz(ptr_mesh_bz) {}

/**
 * @brief Draw a new free flight time for the particle.
 *
 * @param p_gamma
 */
void particle::draw_free_flight_time(double p_gamma) {
    m_current_free_flight_time = -(1.0 / p_gamma) * std::log(m_random_distribution(m_random_generator));
    m_time += m_current_free_flight_time;
}

/**
 * @brief Update the k-vector of the particle based on the electric field.
 *
 * @param v_electric_field The electric field vector.
 */
void particle::update_k_vector(const vector3& v_electric_field) {
    m_k_vector += (get_charge_sign() * EmpiricalPseudopotential::Constants::q_e / EmpiricalPseudopotential::Constants::h_bar) *
                  v_electric_field * m_current_free_flight_time;
}

void particle::update_group_velocity() {
    m_velocity = m_containing_bz_mesh_tetra->get_gradient_energy_at_band(m_band_index);
    m_velocity *= (1.0 / EmpiricalPseudopotential::Constants::h_bar_eV);
}

std::array<double, 8> particle::interpolate_phonon_scattering_rate_at_location(const vector3& location) {
    return m_mesh_bz->interpolate_phonon_scattering_rate_at_location(location, m_band_index);
}

void particle::update_energy() { m_energy = m_containing_bz_mesh_tetra->interpolate_energy_at_band(m_k_vector, m_band_index); }

void compute_post_phonon_scattering_state() {}

}  // namespace fbmc/**
 * @file dielectric_mesh.hpp
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2024-05-17
 *
 * @copyright Copyright (c) 2024
 *
 */

#pragma once

#include <Eigen/Dense>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <sstream>
#include <string>
#include <vector>

#include "Material.h"
#include "bz_mesh.hpp"

namespace bz_mesh {

typedef std::complex<double> complex_d;

class DielectricMesh : public MeshBZ {
 protected:
    /**
     * @brief Store the energies of the dielectric function.
     *
     */
    std::vector<double> m_energies;

    /**
     * @brief Store the dielectric function for each k-point of the mesh.
     * m_dielectric_function[idx_node][idx_energy]  is the dielectric function at the k-point idx_node and energy idx_energy (from
     * m_energies).
     *
     */
    std::vector<std::vector<complex_d>> m_dielectric_function;

 public:
    DielectricMesh() = default;
    DielectricMesh(const EmpiricalPseudopotential::Material& material) : MeshBZ(material) {}

    /**
     * @brief Read the dielectric function from a .msf file (created by epsilon.epm).
     *
     * @param filename Path to the file containing the dielectric function.
     */
    void read_dielectric_file(const std::string& filename);

    /**
     * @brief Find the closest energy in the list of energies.
     * Return the index (idx) of the stored energy directly below the given energy and the fraction (t) of the distance between the two
     * closest energies. The dielectric function at the given energy can be interpolated as: m_dielectric_function[idx_node][idx] * (1 - t)
     * + m_dielectric_function[idx_node][idx + 1] * t
     *
     *
     * @param energy
     * @return std::pair<std::size_t, double>
     */
    std::pair<std::size_t, double> find_closest_energy(double energy) const;

    /**
     * @brief Interpolate the dielectric function at a given k-point and energy.
     *
     * @param k
     * @param energy
     * @return complex_d
     */
    complex_d interpolate_dielectric_function(const vector3& k, double energy) const;
};

}  // namespace bz_mesh/**
 * @file bz_dielectric.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <array>
#include <memory>

#include "Material.h"
#include "bz_mesh.hpp"
#include "bz_states.hpp"
#include "dielectric_mesh.hpp"

namespace bz_mesh {

typedef std::complex<double>       complex_d;
typedef std::unique_ptr<BZ_States> uptr_BZstates;

class ImpactIonization {
 private:
    /**
     * @brief List of Brillouin Zone with their precomputed electronic states.
     * Each of them correspond to a 1BZ shifted by a vector G of the reciprocal lattice.
     *
     */
    std::vector<uptr_BZstates> m_list_BZ_states;

    /**
     * @brief Path to the initial mesh file (centered at 0,0,0)
     *
     */
    std::string m_initial_mesh_path;

    /**
     * @brief Maximum radius of the Brillouin Zone in the reciprocal space.
     *
     */
    double m_max_radius_G0_BZ = 0.0;

    /**
     * @brief Material of the system.
     *
     */
    EmpiricalPseudopotential::Material m_material;

    /**
     * @brief Mesh of the dielectric function.
     *
     */
    DielectricMesh m_dielectric_mesh;

    /**
     * @brief List of the results of the impact ionization rate.
     *
     */
    std::vector<double> m_impact_ionization_results;

 public:
    ImpactIonization(const EmpiricalPseudopotential::Material& material, const std::string& initial_mesh_path);
    void read_dielectric_file(const std::string& filename);
    void interp_test_dielectric_function(std::string filename);

    double get_max_radius_G0_BZ() const { return m_max_radius_G0_BZ; }
    void   set_max_radius_G0_BZ(double max_radius_G0_BZ) { m_max_radius_G0_BZ = max_radius_G0_BZ; }
    void   compute_eigenstates(int nb_threads = 1);

    std::array<complex_d, 2> compute_direct_indirect_impact_ionization_matrix_element(int idx_n1,
                                                                                      int idx_n1_prime,
                                                                                      int idx_n2,
                                                                                      int idx_n2_prime,
                                                                                      int idx_k1,
                                                                                      int idx_k1_prime,
                                                                                      int idx_k2,
                                                                                      int idx_k2_prime) const;

    double compute_impact_ionization_rate(int idx_n1, std::size_t idx_k1);
};

}  // namespace bz_mesh/**
 * @file electron_phonon.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2025-10-04
 *
 *
 */

#pragma once

#include <Eigen/Sparse>  // needed for member type in class; keep here
#include <algorithm>     // max_element
#include <array>
#include <cmath>
#include <cstdint>
#include <stdexcept>
#include <vector>

#include "bz_states.hpp"  // for vector3, BZ_States, material

namespace bz_mesh {

// ---------- Discrete axes ----------
enum class PhononMode : uint8_t { acoustic = 0, optical = 1, none = 2 };
enum class PhononDirection : uint8_t { longitudinal = 0, transverse = 1, none = 2 };
enum class PhononEvent : uint8_t { absorption = 0, emission = 1, none = 2 };

// Compact index:  m∈{ac,op}, d∈{L,T}, e∈{ab,em}  → [0..7] = (m<<2)|(d<<1)|e
constexpr int rate_index(PhononMode m, PhononDirection d, PhononEvent e) noexcept {
    const int M = (m == PhononMode::acoustic) ? 0 : (m == PhononMode::optical) ? 1 : -1;
    const int D = (d == PhononDirection::longitudinal) ? 0 : (d == PhononDirection::transverse) ? 1 : -1;
    const int E = (e == PhononEvent::absorption) ? 0 : (e == PhononEvent::emission) ? 1 : -1;
    return (M | D | E) < 0 ? -1 : ((M << 2) | (D << 1) | E);
}

constexpr int IDX_AC_L_AB = 0;
constexpr int IDX_AC_T_AB = 1;
constexpr int IDX_OP_L_AB = 2;
constexpr int IDX_OP_T_AB = 3;
constexpr int IDX_AC_L_EM = 4;
constexpr int IDX_AC_T_EM = 5;
constexpr int IDX_OP_L_EM = 6;
constexpr int IDX_OP_T_EM = 7;

// ---------- Compact rate containers ----------
using Rate8           = std::array<double, 8>;
using BandRates       = std::vector<Rate8>;      // per band
using VertexBandRates = std::vector<BandRates>;  // per vertex

struct RateValues {
    Rate8 v{};
    void  add(PhononMode m, PhononDirection d, PhononEvent e, double x) noexcept {
        const int idx = rate_index(m, d, e);
        if (idx >= 0) v[static_cast<size_t>(idx)] += x;
    }
    double&            at(PhononMode m, PhononDirection d, PhononEvent e) { return v[rate_index(m, d, e)]; }
    const double&      at(PhononMode m, PhononDirection d, PhononEvent e) const { return v[rate_index(m, d, e)]; }
    const Rate8&       as_array() const noexcept { return v; }
    static const char* label(int i) {
        static const char* L[8] = {"ac_L_ab", "ac_T_ab", "op_L_ab", "op_T_ab", "ac_L_em", "ac_T_em", "op_L_em", "op_T_em"};
        return (i >= 0 && i < 8) ? L[i] : "invalid";
    }
};

// ---------- Phonon dispersion (uniform lookup + analytic fallback) ----------
struct PhononDispersion {
    PhononMode      mode      = PhononMode::none;
    PhononDirection direction = PhononDirection::none;

    // Analytic ω(q) = w0 + vs*q + c*q^2 (optional fast path)
    double w0 = 0.0, vs = 0.0, c = 0.0;

    // Uniform lookup on q∈[0,qmax]: store only ω; derive indices arithmetically
    double              q0     = 0.0;  // usually 0
    double              inv_dq = 0.0;  // 1/Δq
    double              qmax   = 0.0;
    uint32_t            N      = 0;     // number of samples
    std::vector<double> omega_samples;  // size N

    PhononDispersion() = default;
    PhononDispersion(PhononMode m, PhononDirection d, double w0_, double vs_, double c_) : mode(m), direction(d), w0(w0_), vs(vs_), c(c_) {}

    inline double omega_analytic(double q) const noexcept { return std::fma(c, q * q, std::fma(vs, q, w0)); }

    void build_lookup(double q_max, std::size_t n_points) {
        if (q_max <= 0.0 || n_points < 2) throw std::invalid_argument("bad lookup grid");
        q0              = 0.0;
        qmax            = q_max;
        N               = static_cast<uint32_t>(n_points);
        const double dq = (qmax - q0) / (N - 1);
        inv_dq          = 1.0 / dq;
        omega_samples.resize(N);
        for (uint32_t i = 0; i < N; ++i) {
            const double q   = q0 + i * dq;
            omega_samples[i] = omega_analytic(q);
        }
    }

    inline double omega_lookup(double q) const {
        if (omega_samples.empty()) throw std::runtime_error("phonon lookup empty");
        if (q <= q0) return omega_samples.front();
        if (q >= qmax) return omega_samples.back();
        const double t = (q - q0) * inv_dq;
        uint32_t     i = static_cast<uint32_t>(t);
        if (i >= N - 1) i = N - 2;
        const double frac = t - static_cast<double>(i);
        const double a = omega_samples[i], b = omega_samples[i + 1];
        return std::fma(frac, (b - a), a);
    }

    inline double max_omega() const {
        if (omega_samples.empty()) throw std::runtime_error("phonon lookup empty");
        return *std::max_element(omega_samples.begin(), omega_samples.end());
    }
};

// ---------- Deformation potentials (no i/o in header) ----------
struct DeformationPotential {
    PhononMode mode             = PhononMode::none;
    double     A                = 0.0;
    double     B                = 0.0;
    double     energy_threshold = 1e6;  // eV

    DeformationPotential() = default;
    DeformationPotential(PhononMode m, double A_, double B_, double thr) : mode(m), A(A_), B(B_), energy_threshold(thr) {}

    double get_deformation_potential(const vector3& q, double energy) const {
        const double Ee = (energy < energy_threshold ? energy : energy_threshold);
        return (mode == PhononMode::acoustic) ? std::sqrt(A + Ee * B) * q.norm() : std::sqrt(A + Ee * B);
    }

    double get_fischetti_deformation_potential(const vector3& q, int idx_band) const {
        constexpr double cm_to_m = 1e2;
        const double     boost   = 1.5;
        if (mode == PhononMode::acoustic) {
            return (idx_band == 0 ? boost * 1.2 : 1.0 * 1.7) * q.norm();
        } else {
            return (idx_band == 0 ? boost * 1.75e8 : boost * 2.10e8) * cm_to_m;
        }
    }
};

// ---------- Hole overlap params (fixed arrays instead of linear search) ----------
struct HoleOverlapIntParams {
    // Indices 1..3 used in your logic; we store 0..2 and subtract 1 on access
    std::array<std::array<double, 3>, 3> A{{{{1.0, 3.0, 3.0 / 8.0}}, {{3.0, 1.0, 3.0 / 8.0}}, {{3.0 / 8.0, 3.0 / 8.0, 5.0 / 8.0}}}};
    std::array<std::array<double, 3>, 3> B{{{{3.0, -3.0, 0.0}}, {{-3.0, 3.0, 0.0}}, {{0.0, 0.0, 0.0}}}};

    // returns {A,B} for pair (n1,n2) where n∈{1,2,3}; outside → {0,0}
    std::array<double, 2> get_params(int n1, int n2) const noexcept {
        if (n1 >= 1 && n1 <= 3 && n2 >= 1 && n2 <= 3) {
            return {A[n1 - 1][n2 - 1], B[n1 - 1][n2 - 1]};
        }
        return {0.0, 0.0};
    }
};

// Helper: compact container for 4 (mode×direction) dispersions
inline constexpr int md_index(PhononMode m, PhononDirection d) noexcept {
    const int M = (m == PhononMode::acoustic) ? 0 : (m == PhononMode::optical) ? 1 : -1;
    const int D = (d == PhononDirection::longitudinal) ? 0 : (d == PhononDirection::transverse) ? 1 : -1;
    return (M | D) < 0 ? -1 : ((M << 1) | D);  // 0..3
}

// ---------- Eigen aliases ----------
using EigenSparseMatrix = Eigen::SparseMatrix<double>;
using EigenTriplet      = Eigen::Triplet<double>;

struct Rates_nk_npkp_ctor {
    PhononMode      mode      = PhononMode::none;
    PhononDirection direction = PhononDirection::none;
    PhononEvent     event     = PhononEvent::none;
    /**
     * @brief Preliminary constructor for the rate matrix (n,k) → (n',k') for a given (m,d,e) triplet.
    // (n,k) → (n',k') transition rate matrix. /!\ k' are the barycenters of final tetrahedra, not the mesh vertices!
    // So the size is (nk, n'k') where n'k' are the number of final tetrahedra × number of bands.
     *
     */
    EigenSparseMatrix matrix;  // (nk, n'k')
};

class ElectronPhonon : public BZ_States {
 private:
    double m_temperature        = 300.0;
    double m_rho                = 2.329e3;
    double m_radii_wigner_seitz = 0.0;

    int  m_nb_threads         = 1;
    bool m_parallelize_over_k = true;

    HoleOverlapIntParams m_hole_overlap_int_params;
    DeformationPotential m_ac_defpot_e, m_op_defpot_e;
    DeformationPotential m_ac_defpot_h, m_op_defpot_h;

    // 4 dispersions: (ac/op) × (L/T); index via md_index()
    std::array<PhononDispersion, 4> m_phonon_dispersion;

    // Transport rates. m_phonon_rates_transport[band][k1]
    std::vector<std::vector<double>> m_phonon_rates_transport;  // precomputed 1/τ_tr(E) on uniform grid

    // Precomputed rates on mesh: [vertex][band][8]
    std::vector<std::vector<Rate8>> m_list_phonon_scattering_rates;
    std::vector<double>             m_count_weight_tetra_per_vertex;

    // (n,k) → (n',k') transition rate matrices. /!\ k' are the barycenters of final tetrahedra, not the mesh vertices!
    // So the size is (nk, n'k') where n'k' are the number of final tetrahedra × number of bands.
    // One matrix per (m,d,e) triplet.
    std::vector<Rates_nk_npkp_ctor> m_rates_nk_npkp;

 public:
    explicit ElectronPhonon(const EmpiricalPseudopotential::Material& material) : BZ_States(material) {}

    // .cpp implements these (keep header slim—no YAML/iostream here)
    void   load_phonon_parameters(const std::string& filename);
    void   plot_phonon_dispersion(const std::string& filename) const;
    double get_max_phonon_energy() const;

    inline double bose_einstein_distribution(double energy_eV, double temperature_K) const;  // inline in .cpp
    inline double electron_overlap_integral(const vector3& k1, const vector3& k2) const;
    inline double hole_overlap_integral(int n1, const vector3& k1, int n2, const vector3& k2) const;
    inline double transport_weight_RTA(const vector3& v0, const vector3& v1);  // inline in .cpp

    Rate8      compute_transition_rates_pair(int idx_n1, std::size_t idx_k1, int idx_n2, std::size_t idx_tetra_final, bool push_nk_npkp);
    RateValues compute_electron_phonon_rate(int idx_n1, std::size_t idx_k1, bool populate_nk_npkp = false);
    RateValues compute_hole_phonon_rate(int idx_n1, std::size_t idx_k1);

    void set_nb_threads(int nb_threads) {
        if (nb_threads < 1) throw std::invalid_argument("nb_threads must be >= 1");
        m_nb_threads = nb_threads;
    }
    void set_parallelize_over_k(bool b) noexcept { m_parallelize_over_k = b; }

    void set_temperature(double T) noexcept { m_temperature = T; }
    void set_density(double rho) noexcept { m_rho = rho; }

    void compute_electron_phonon_rates_over_mesh(double energy_max             = 100.0,
                                                 bool   irreducible_wedge_only = false,
                                                 bool   populate_nk_npkp       = false);
    void add_electron_phonon_rates_to_mesh(const std::string& initial_filename, const std::string& final_filename);
    void compute_electron_phonon_rates_over_mesh_nk_npkp(bool irreducible_wedge_only = false);

    std::pair<int, std::size_t> select_final_state(std::size_t     idx_band_initial,
                                                   std::size_t     idx_k_initial,
                                                   PhononMode      mode,
                                                   PhononDirection direction,
                                                   PhononEvent     event) const;

    void export_rate_values(const std::string& filename) const;

    void compute_plot_electron_phonon_rates_vs_energy_over_mesh(int                nb_bands,
                                                                double             max_energy,
                                                                double             energy_step,
                                                                const std::string& filename,
                                                                bool               irreducible_wedge_only = false);

    void          read_phonon_scattering_rates_from_file(const std::filesystem::path& path);
    Rate8         interpolate_phonon_scattering_rate_at_location(const vector3& location, const std::size_t& idx_band) const;
    inline double sum_modes(const Rate8& r) const noexcept;
    double        compute_P_Gamma() const;

    void compute_RTA_mobility();
};

}  // namespace bz_mesh
/**
 * @file box_bz.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-25
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <memory>
#include <random>
#include <vector>

#include "vector.hpp"

namespace bz_mesh {

/**
 * @brief Class representing a box in 3D space.
 * The box is of the form AABB (Axis-Aligned Bounding Box)
 *
 *
 */
class bbox_mesh {
 private:
    double m_x_min{0.0};
    double m_x_max{0.0};
    double m_y_min{0.0};
    double m_y_max{0.0};
    double m_z_min{0.0};
    double m_z_max{0.0};

 public:
    bbox_mesh(){};
    bbox_mesh(double x_min, double x_max, double y_min, double y_max, double z_min, double z_max)
        : m_x_min(x_min),
          m_x_max(x_max),
          m_y_min(y_min),
          m_y_max(y_max),
          m_z_min(z_min),
          m_z_max(z_max) {
        if (!check_order()) {
            throw std::invalid_argument("Order of bbox_mesh corner is bad.");
        }
    }

    bbox_mesh(const vector3 &bottom_left_front_corner, const vector3 &up_right_back_corner)
        : m_x_min(bottom_left_front_corner.x()),
          m_x_max(up_right_back_corner.x()),
          m_y_min(bottom_left_front_corner.y()),
          m_y_max(up_right_back_corner.y()),
          m_z_min(bottom_left_front_corner.z()),
          m_z_max(up_right_back_corner.z()) {
        if (!check_order()) {
            throw std::invalid_argument("Order of bbox_mesh corner is bad.");
        }
    }

    bool check_order() const { return (m_x_min <= m_x_max) && (m_y_min <= m_y_max) && (m_z_min <= m_z_max); }

    double get_x_min() const { return m_x_min; }
    double get_x_max() const { return m_x_max; }
    double get_y_min() const { return m_y_min; }
    double get_y_max() const { return m_y_max; }
    double get_z_min() const { return m_z_min; }
    double get_z_max() const { return m_z_max; }

    double get_x_size() const { return m_x_max - m_x_min; }
    double get_y_size() const { return m_y_max - m_y_min; }
    double get_z_size() const { return m_z_max - m_z_min; }

    double get_diagonal_size() const {
        return sqrt(get_x_size() * get_x_size() + get_y_size() * get_y_size() + get_z_size() * get_z_size());
    }

    double get_volume() const {
        const double surface = fabs(m_x_max - m_x_min) * fabs(m_y_max - m_y_min) * fabs(m_z_max - m_z_min);
        return surface;
    }

    vector3 get_center() const {
        constexpr double one_half = 1.0 / 2.0;
        return {one_half * (m_x_min + m_x_max), one_half * (m_y_min + m_y_max), one_half * (m_z_min + m_z_max)};
    }

    bool is_inside(const vector3 &location) const {
        return (location.x() > m_x_min) && (location.x() < m_x_max) && (location.y() > m_y_min) && (location.y() < m_y_max) &&
               (location.z() > m_z_min) && (location.z() < m_z_max);
    }

    /**
     * @brief Split the box into 8 equal sub-boxes.
     *
     * @return std::array<bbox_mesh, 8>
     */
    std::array<bbox_mesh, 8> split_3d_box_in_octants() const {
        std::array<bbox_mesh, 8> octants;
        const vector3         box_center = get_center();

        octants[0] = bbox_mesh(m_x_min, box_center.x(), m_y_min, box_center.y(), m_z_min, box_center.z());
        octants[1] = bbox_mesh(box_center.x(), m_x_max, m_y_min, box_center.y(), m_z_min, box_center.z());
        octants[2] = bbox_mesh(box_center.x(), m_x_max, box_center.y(), m_y_max, m_z_min, box_center.z());
        octants[3] = bbox_mesh(m_x_min, box_center.x(), box_center.y(), m_y_max, m_z_min, box_center.z());
        octants[4] = bbox_mesh(m_x_min, box_center.x(), m_y_min, box_center.y(), box_center.z(), m_z_max);
        octants[5] = bbox_mesh(box_center.x(), m_x_max, m_y_min, box_center.y(), box_center.z(), m_z_max);
        octants[6] = bbox_mesh(box_center.x(), m_x_max, box_center.y(), m_y_max, box_center.z(), m_z_max);
        octants[7] = bbox_mesh(m_x_min, box_center.x(), box_center.y(), m_y_max, box_center.z(), m_z_max);
        return octants;
    }

    void dilate(double factor) {
        m_x_min *= factor;
        m_x_max *= factor;
        m_y_min *= factor;
        m_y_max *= factor;
        m_z_min *= factor;
        m_z_max *= factor;
    }

    void translate(const vector3 &translation) {
        m_x_min += translation.x();
        m_x_max += translation.x();
        m_y_min += translation.y();
        m_y_max += translation.y();
        m_z_min += translation.z();
        m_z_max += translation.z();
    }

    bool is_overlapping(const bbox_mesh &second_box) const {
        const bool noOverlap = this->m_x_min > second_box.m_x_max || second_box.m_x_min > this->m_x_max ||
                               this->m_y_min > second_box.m_y_max || second_box.m_y_min > this->m_y_max ||
                               this->m_z_min > second_box.m_z_max || second_box.m_z_min > this->m_z_max;
        return !noOverlap;
    }

    friend std::ostream &operator<<(std::ostream &os, const bbox_mesh &my_box) {
        os << "bbox_mesh: x_min = " << my_box.m_x_min << " x_max = " << my_box.m_x_max << " y_min = " << my_box.m_y_min
           << " y_max = " << my_box.m_y_max << " z_min = " << my_box.m_z_min << " z_max = " << my_box.m_z_max;
        return os;
    }
};

}  // namespace bz_mesh/**
 * @file Octree_mesh.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-25
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "octree_bz.hpp"


#include <algorithm>
#include <array>
#include <memory>
#include <vector>

namespace bz_mesh {

Octree_mesh::Octree_mesh(const std::vector<Tetra *> &list_tetras, const bbox_mesh &bounding_box) {
    if (list_tetras.size() <= max_number_of_elements_per_node || bounding_box.get_diagonal_size() < min_size_of_a_node) {
        m_is_leaf     = true;
        m_list_tetras = list_tetras;
        m_node_box    = bounding_box;
        return;
    }

    m_is_leaf                        = false;
    m_node_box                       = bounding_box;
    std::array<bbox_mesh, 8> sub_boxes = m_node_box.split_3d_box_in_octants();

    for (int i = 0; i < 8; i++) {
        m_list_sub_nodes.push_back(
            std::make_unique<Octree_mesh>(Octree_mesh::find_overlapping_tetras(list_tetras, sub_boxes[i]), sub_boxes[i]));
    }
}

/**
 * @brief Find the tetra from the list of tetras that are overlapping with the bounding box.
 *
 * @note The list of pointers to tetras is passed by copy because it is modified during the search.
 * Perf should be compared with a list of pointers to tetras that is passed by reference and copied within the function.
 *
 * @param list_p_tetras
 * @param bounding_box
 * @return std::vector<Tetra *>
 */
std::vector<Tetra *> Octree_mesh::find_overlapping_tetras(const std::vector<Tetra *> &list_p_tetras, const bbox_mesh &bounding_box) {
    std::vector<Tetra *> list_overlapping_tetras;
    for (auto &p_tetra : list_p_tetras) {
        if (bounding_box.is_overlapping(p_tetra->get_bounding_box())) {
            list_overlapping_tetras.push_back(p_tetra);
        }
    }
    return list_overlapping_tetras;
}

/**
 * @brief Find the tetra that contains the location.
 * If none is found, return nullptr, else return a pointer to the tetra.
 *
 * @param location
 * @return Tetra*
 */
Tetra *Octree_mesh::find_tetra_at_location(const vector3 &location) const {
    if (!m_is_leaf) {
        for (auto &&p_sub_node : m_list_sub_nodes) {
            if (p_sub_node->is_inside(location)) {
                return p_sub_node->find_tetra_at_location(location);
            }
        }
    }
    const auto it_tetra =
        std::find_if(m_list_tetras.begin(), m_list_tetras.end(), [&](const Tetra *p_tetra) { return p_tetra->is_location_inside(location); });
    return it_tetra != m_list_tetras.end() ? *it_tetra : nullptr;
}

}  // namespace bz_mesh
/**
 * @file bz_mesh.cpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "bz_mesh.hpp"

#include <algorithm>
#include <chrono>
#include <filesystem>
#include <vector>

#include "gmsh.h"
#include "omp.h"
#include "rapidcsv.h"

#pragma omp declare reduction(merge : std::vector<double> : omp_out.insert(omp_out.end(), omp_in.begin(), omp_in.end()))

namespace bz_mesh {

void MeshBZ::shift_bz_center(const vector3& center) {
    m_center = center;
    for (auto&& vtx : m_list_vertices) {
        vtx.shift_position(center);
    }
}

inline double MeshBZ::si_to_reduced_scale() const {
    // reduced k = (a / (2π)) * k_SI
    return m_material.get_lattice_constant_meter() / (2.0 * M_PI);
}

/**
 * @brief Read the geometry of the mesh from the .msh file: the vertices and the elements are added to
 * the m_list_vertices and m_list_elements lists.
 * All the points coordinates are re-normalized by the lattice constant passed as argument.
 *
 * @param filename
 * @param lattice_constant
 */
void MeshBZ::read_mesh_geometry_from_msh_file(const std::string& filename, bool normalize_by_fourier_factor) {
    std::cout << "Opening file " << filename << std::endl;
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 1000);
    gmsh::open(filename);
    std::vector<std::size_t> nodeTags;
    std::vector<double>      nodeCoords;
    std::vector<double>      nodeParams;
    std::cout << "Reading vertices ..." << std::endl;
    gmsh::model::mesh::reclassifyNodes();
    gmsh::model::mesh::getNodes(nodeTags, nodeCoords, nodeParams, -1, -1, false, false);
    std::size_t size_nodes_tags        = nodeTags.size();
    std::size_t size_nodes_coordinates = nodeCoords.size();
    m_node_tags                        = nodeTags;
    std::cout << "Number of nodes: " << size_nodes_tags << std::endl;

    if (size_nodes_coordinates != 3 * size_nodes_tags) {
        throw std::runtime_error("Number of coordinates is not 3 times the number of vertices. Abort.");
    }

    m_list_vertices.reserve(size_nodes_tags);
    double lattice_constant = m_material.get_lattice_constant_meter();
    std::cout << "Lattice const: " << lattice_constant << std::endl;
    std::cout << "V: " << std::pow(2.0 * M_PI, 3) / std::pow(lattice_constant, 3.0) << std::endl;
    const double fourier_factor = 2.0 * M_PI / lattice_constant;
    // const double fourier_factor       = 1;
    double normalization_factor = normalize_by_fourier_factor ? fourier_factor : 1.0;
    for (std::size_t index_vertex = 0; index_vertex < size_nodes_tags; ++index_vertex) {
        m_list_vertices.push_back(Vertex(index_vertex,
                                         normalization_factor * nodeCoords[3 * index_vertex],
                                         normalization_factor * nodeCoords[3 * index_vertex + 1],
                                         normalization_factor * nodeCoords[3 * index_vertex + 2]));
    }
    std::cout << "Number of k-points vertices: " << m_list_vertices.size() << std::endl;

    // Get the mesh elements for the entity (dim, tag):
    const int                             dim = 3;
    const int                             tag = -1;
    std::vector<int>                      elemTypes;
    std::vector<std::vector<std::size_t>> elemTags, elemNodeTags;
    gmsh::model::mesh::getElements(elemTypes, elemTags, elemNodeTags, dim, tag);
    if (elemTags.empty()) {
        std::cout << "ElementTags is zero when the mesh was imported... Abort.\n";
        throw std::runtime_error("ElementTags is zero when the mesh was imported... Abort.");
    }
    std::size_t number_elements = elemTags[0].size();

    if (elemNodeTags[0].size() != 4 * number_elements) {
        throw std::runtime_error("Number of elements vertices index is not 4 x NumberOfElements. Abort.");
    }

    m_list_tetrahedra.reserve(number_elements);
    m_vertex_to_tetrahedra.resize(m_list_vertices.size());
    for (std::size_t index_element = 0; index_element < number_elements; ++index_element) {
        const std::array<Vertex*, 4> array_element_vertices = {&m_list_vertices[elemNodeTags[0][4 * index_element] - 1],
                                                               &m_list_vertices[elemNodeTags[0][4 * index_element + 1] - 1],
                                                               &m_list_vertices[elemNodeTags[0][4 * index_element + 2] - 1],
                                                               &m_list_vertices[elemNodeTags[0][4 * index_element + 3] - 1]};
        Tetra                        new_tetra(index_element, array_element_vertices);
        m_list_tetrahedra.push_back(new_tetra);
        for (std::size_t i = 0; i < 4; ++i) {
            m_vertex_to_tetrahedra[elemNodeTags[0][4 * index_element + i] - 1].push_back(index_element);
        }
    }
    gmsh::finalize();
    m_total_volume = compute_mesh_volume();
    std::cout << "Total mesh volume: " << m_total_volume << std::endl;
    // Compute the reduced BZ volume
    double       Vcell      = std::pow(m_material.get_lattice_constant_meter(), 3) / 4.0;
    const double VBZ_theory = std::pow(2.0 * M_PI, 3) / Vcell;  // m^-3

    m_reduce_bz_factor = m_total_volume / VBZ_theory;
    std::cout << "Reduce BZ factor: " << m_reduce_bz_factor << std::endl;

    precompute_G_shifts();
    Eigen::Vector3d  b1_SI                = {-1.0, 1.0, 1.0};
    Eigen::Vector3d  b2_SI                = {1.0, -1.0, 1.0};
    Eigen::Vector3d  b3_SI                = {1.0, 1.0, -1.0};
    constexpr double halfwidth_reduced    = 1.0;
    const double     ssi_to_reduced_scale = si_to_reduced_scale();
    init_reciprocal_basis(b1_SI, b2_SI, b3_SI, halfwidth_reduced, ssi_to_reduced_scale);

    // build_search_tree();
}

bbox_mesh MeshBZ::compute_bounding_box() const {
    double x_min = std::numeric_limits<double>::max();
    double y_min = std::numeric_limits<double>::max();
    double z_min = std::numeric_limits<double>::max();
    double x_max = std::numeric_limits<double>::min();
    double y_max = std::numeric_limits<double>::min();
    double z_max = std::numeric_limits<double>::min();
    for (auto&& vtx : m_list_vertices) {
        const vector3& position = vtx.get_position();
        x_min                   = std::min(x_min, position.x());
        y_min                   = std::min(y_min, position.y());
        z_min                   = std::min(z_min, position.z());
        x_max                   = std::max(x_max, position.x());
        y_max                   = std::max(y_max, position.y());
        z_max                   = std::max(z_max, position.z());
    }
    vector3 min_corner(x_min, y_min, z_min);
    vector3 max_corner(x_max, y_max, z_max);
    return bbox_mesh(min_corner, max_corner);
}

void MeshBZ::build_search_tree() {
    bbox_mesh mesh_bbox = compute_bounding_box();
    std::cout << "Mesh bounding box: " << mesh_bbox << std::endl;
    mesh_bbox.dilate(1.05);
    // bbox_mesh.translate({0.0, 0.0, 0.0});
    auto start    = std::chrono::high_resolution_clock::now();
    m_search_tree = std::make_unique<Octree_mesh>(get_list_p_tetra(), mesh_bbox);
    auto end      = std::chrono::high_resolution_clock::now();
    auto total    = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "Octree built in " << total / 1000.0 << "s" << std::endl;
}

Tetra* MeshBZ::find_tetra_at_location(const vector3& location) const { return m_search_tree->find_tetra_at_location(location); }

std::size_t MeshBZ::get_nearest_k_index(const vector3& k) const {
    std::size_t index_nearest_k = 0;
    double      min_distance    = std::numeric_limits<double>::max();
    for (std::size_t index_k = 0; index_k < m_list_vertices.size(); ++index_k) {
        double distance = (k - m_list_vertices[index_k].get_position()).norm();
        if (distance < min_distance) {
            min_distance    = distance;
            index_nearest_k = index_k;
        }
    }
    return index_nearest_k;
}

/**
 * @brief Read the energy values for each band at every k-points (vertices) of the mesh.
 *
 * @param filename
 */
void MeshBZ::read_mesh_bands_from_msh_file(const std::string& filename, int nb_bands_to_load) {
    std::cout << "Opening file " << filename << std::endl;
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::open(filename);
    // std::cout << "Read gmsh views (band energy values) ..." << std::endl;
    std::vector<int> viewTags;
    gmsh::view::getTags(viewTags);
    // std::cout << "Number of view (bands) found: " << viewTags.size() << std::endl;
    int count_band = 0;

    for (auto&& tag : viewTags) {
        if (nb_bands_to_load != -1 && count_band >= nb_bands_to_load) break;

        const int   index_view  = gmsh::view::getIndex(tag);
        std::string name_object = "View[" + std::to_string(index_view) + "].Name";
        std::string name_view;
        try {
            gmsh::option::getString(name_object, name_view);
        } catch (const std::exception& e) {
            std::cerr << e.what() << '\n';
        }

        std::string              type;
        std::vector<std::size_t> tags;
        double                   time;
        int                      numComp;
        std::vector<double>      data_view;
        gmsh::view::getHomogeneousModelData(tag, 0, type, tags, data_view, time, numComp);
        bool is_valence = data_view[0] <= 0.1;
        if (is_valence) {
            m_indices_valence_bands.push_back(count_band);
        } else {
            m_indices_conduction_bands.push_back(count_band);
        }
        count_band++;
        auto minmax_band = std::minmax_element(data_view.begin(), data_view.end());
        m_min_band.push_back(*(minmax_band.first));
        m_max_band.push_back(*(minmax_band.second));
        add_new_band_energies_to_vertices(data_view);
    }
    gmsh::finalize();
    // PRINT INDICES
    std::cout << "Number of bands loaded: " << m_min_band.size() << std::endl;
    std::cout << "Number of valence bands: " << m_indices_valence_bands.size() << std::endl;
    std::cout << "Number of conduction bands: " << m_indices_conduction_bands.size() << std::endl;
    for (auto&& idx : m_indices_valence_bands) {
        std::cout << "Valence band index: " << idx << std::endl;
    }
    for (auto&& idx : m_indices_conduction_bands) {
        std::cout << "Conduction band index: " << idx << std::endl;
    }

    auto_shift_conduction_band_energies();
    auto_set_positive_valence_band_energies();
    compute_min_max_energies_at_tetras();
    compute_energy_gradient_at_tetras();
    set_energy_gradient_at_vertices_by_averaging_tetras();
    for (auto&& tetra : m_list_tetrahedra) {
        tetra.pre_compute_sorted_slots_per_band();
    }

    // Print band info
    std::cout << "Number of bands loaded: " << m_min_band.size() << std::endl;
    std::cout << "Number of valence bands: " << m_indices_valence_bands.size() << std::endl;
    std::cout << "Number of conduction bands: " << m_indices_conduction_bands.size() << std::endl;
    for (std::size_t i = 0; i < m_min_band.size(); ++i) {
        std::cout << "Band " << i << ": min = " << m_min_band[i] << " eV, max = " << m_max_band[i] << " eV";
        if (std::find(m_indices_valence_bands.begin(), m_indices_valence_bands.end(), i) != m_indices_valence_bands.end()) {
            std::cout << " (valence band)";
        } else if (std::find(m_indices_conduction_bands.begin(), m_indices_conduction_bands.end(), i) != m_indices_conduction_bands.end()) {
            std::cout << " (conduction band)";
        }
        std::cout << std::endl;
    }

    export_energies_and_gradients_to_vtk("mesh_energies_gradients.vtk");
}

void MeshBZ::precompute_dos_tetra(double energy_step, double energy_threshold) {
    std::cout << "Precomputing DOS per tetrahedra with energy step = " << energy_step << " eV ..." << std::endl;
    auto start = std::chrono::high_resolution_clock::now();
#pragma omp parallel for schedule(dynamic)
    for (std::size_t i = 0; i < m_list_tetrahedra.size(); ++i) {
        m_list_tetrahedra[i].precompute_dos_on_energy_grid_per_band(energy_step, energy_threshold);
    }
}

void MeshBZ::set_energy_gradient_at_vertices_by_averaging_tetras() {
    std::cout << "Setting energy gradient at vertices by averaging tetrahedra gradients ..." << std::endl;
    for (std::size_t i = 0; i < m_list_vertices.size(); ++i) {
        for (std::size_t b = 0; b < m_list_vertices[i].get_number_bands(); ++b) {
            vector3 gradient_sum(0.0, 0.0, 0.0);
            int     count = 0;
            for (auto&& tetra_idx : m_vertex_to_tetrahedra[i]) {
                gradient_sum += m_list_tetrahedra[tetra_idx].get_gradient_energy_at_band(b);
                count++;
            }
            if (count > 0) {
                gradient_sum /= static_cast<double>(count);
                m_list_vertices[i].push_back_energy_gradient_at_band(gradient_sum);
            } else {
                m_list_vertices[i].push_back_energy_gradient_at_band(vector3(0.0, 0.0, 0.0));
            }
        }
    }
    std::cout << "Done." << std::endl;
}

void MeshBZ::recompute_min_max_energies() {
    m_min_band.clear();
    m_max_band.clear();
    int nb_bands = m_list_vertices[0].get_number_bands();
    m_min_band.resize(nb_bands, std::numeric_limits<double>::max());
    m_max_band.resize(nb_bands, std::numeric_limits<double>::lowest());
    for (auto&& vtx : m_list_vertices) {
        const auto& energies = vtx.get_band_energies();
        for (int i = 0; i < nb_bands; ++i) {
            if (energies[i] < m_min_band[i]) m_min_band[i] = energies[i];
            if (energies[i] > m_max_band[i]) m_max_band[i] = energies[i];
        }
    }
    // Print band info
    std::cout << "Number of bands: " << m_min_band.size() << std::endl;
    for (std::size_t i = 0; i < m_min_band.size(); ++i) {
        std::cout << "Band " << i << ": min = " << m_min_band[i] << " eV, max = " << m_max_band[i] << " eV";
        if (std::find(m_indices_valence_bands.begin(), m_indices_valence_bands.end(), i) != m_indices_valence_bands.end()) {
            std::cout << " (valence band)";
        } else if (std::find(m_indices_conduction_bands.begin(), m_indices_conduction_bands.end(), i) != m_indices_conduction_bands.end()) {
            std::cout << " (conduction band)";
        }
        std::cout << std::endl;
    }
    std::cout << std::endl;
}

/**
 * @brief Keep only a subset of bands (valence and conduction) in the mesh. Remove higher (relative) bands.
 * @param nb_valence_bands Number of valence bands to keep
 * @param nb_conduction_bands Number of conduction bands to keep
 */
void MeshBZ::keep_only_bands(const int nb_valence_bands, const int nb_conduction_bands) {
    int nb_valence_to_remove    = static_cast<int>(m_indices_valence_bands.size()) - nb_valence_bands;
    int nb_conduction_to_remove = static_cast<int>(m_indices_conduction_bands.size()) - nb_conduction_bands;
    if (nb_valence_to_remove < 0 || nb_conduction_to_remove < 0) {
        throw std::runtime_error("Cannot keep more bands than available.");
    }
    std::cout << "Removing " << nb_valence_to_remove << " valence bands and " << nb_conduction_to_remove << " conduction bands."
              << std::endl;
    // Remove higher valence bands
    for (int i = 0; i < nb_valence_to_remove; ++i) {
        int band_to_remove = m_indices_valence_bands.back();
        m_indices_valence_bands.pop_back();
        for (auto&& vtx : m_list_vertices) {
            vtx.remove_band_energy(band_to_remove);
        }
    }
    // Remove higher conduction bands
    for (int i = 0; i < nb_conduction_to_remove; ++i) {
        int band_to_remove = m_indices_conduction_bands.back();
        m_indices_conduction_bands.pop_back();
        for (auto&& vtx : m_list_vertices) {
            vtx.remove_band_energy(band_to_remove);
        }
    }
    // Recompute min/max band energies
    recompute_min_max_energies();
    std::cout << "After removing bands:" << std::endl;
    std::cout << "Number of valence bands: " << m_indices_valence_bands.size() << std::endl;
    std::cout << "Number of conduction bands: " << m_indices_conduction_bands.size() << std::endl;
}

void MeshBZ::add_new_band_energies_to_vertices(const std::vector<double>& energies_at_vertices) {
    if (energies_at_vertices.size() != m_list_vertices.size()) {
        throw std::invalid_argument("The number of energy values does not match the number of vertices. Abort.");
    }
    for (std::size_t index_vtx = 0; index_vtx < m_list_vertices.size(); ++index_vtx) {
        m_list_vertices[index_vtx].add_band_energy_value(energies_at_vertices[index_vtx]);
    }
}

void MeshBZ::compute_min_max_energies_at_tetras() {
    for (auto&& tetra : m_list_tetrahedra) {
        tetra.compute_min_max_energies_at_bands();
    }
}

void MeshBZ::auto_set_positive_valence_band_energies() {
    for (int vband : m_indices_valence_bands) {
        for (auto&& vtx : m_list_vertices) {
            double energy = vtx.get_energy_at_band(vband);
            vtx.set_band_energy(vband, std::fabs(energy));
        }
    }
}

void MeshBZ::auto_shift_conduction_band_energies() {
    if (m_indices_conduction_bands.empty()) return;

    // Find the highest valence band maximum
    double max_valence = std::numeric_limits<double>::lowest();
    for (int vband : m_indices_valence_bands) {
        max_valence = std::max(max_valence, m_max_band[vband]);
    }
    if (m_indices_valence_bands.empty()) {
        max_valence = 0.0;
    }
    std::cout << "Max valence band energy: " << max_valence << " eV\n";

    // Find the lowest conduction band minimum
    double min_conduction = std::numeric_limits<double>::max();
    for (int cband : m_indices_conduction_bands) {
        min_conduction = std::min(min_conduction, m_min_band[cband]);
    }
    std::cout << "Min conduction band energy: " << min_conduction << " eV\n";

    double band_gap = min_conduction - max_valence;
    std::cout << "Computed band gap: " << band_gap << " eV\n";

    if (band_gap < 0.1) {
        std::cout << "Warning: computed band gap is very small or negative (" << band_gap << " eV). No shift applied.\n";
        return;
    }

    // Shift all conduction bands so that the conduction band minimum aligns with the valence band maximum
    double shift_amount = -min_conduction + max_valence;
    std::cout << "Shifting conduction bands by " << shift_amount << " eV to align CBM with VBM.\n";

    // void set_band_energy(std::size_t index_band, double new_energy) {

    for (auto&& vtx : m_list_vertices) {
        for (int cband : m_indices_conduction_bands) {
            double old_energy = vtx.get_energy_at_band(cband);
            double new_energy = old_energy + shift_amount;
            vtx.set_band_energy(cband, new_energy);
        }
    }

    // Recompute per-band min/max
    m_min_band.clear();
    m_max_band.clear();
    for (std::size_t b = 0; b < m_list_vertices[0].get_number_bands(); ++b) {
        double bmin = std::numeric_limits<double>::max();
        double bmax = std::numeric_limits<double>::lowest();
        for (auto&& vtx : m_list_vertices) {
            double e = vtx.get_energy_at_band(b);
            bmin     = std::min(bmin, e);
            bmax     = std::max(bmax, e);
        }
        m_min_band.push_back(bmin);
        m_max_band.push_back(bmax);
    }

    std::cout << "Post-shift band extrema:\n";
    for (std::size_t b = 0; b < m_min_band.size(); ++b) {
        std::cout << " Band " << b << ": min = " << m_min_band[b] << " eV, max = " << m_max_band[b] << " eV\n";
    }
    std::cout << std::endl;
}

void MeshBZ::set_bands_in_right_order() {
    if (m_indices_valence_bands.empty() || m_indices_conduction_bands.empty()) {
        std::cout << "Warning: valence or conduction band indices are empty. Cannot reorder bands.\n";
        return;
    }

    // DEBUG PROVISOIRE
    for (auto&& vtx : m_list_vertices) {
        vtx.swap_bands(m_indices_valence_bands[0], m_indices_valence_bands.back());
        vtx.swap_bands(m_indices_valence_bands[1], m_indices_valence_bands[m_indices_valence_bands.size() - 2]);
        std::cout << "Swapped bands for vertex " << vtx.get_index() << ": band " << m_indices_valence_bands[0] << " with band "
                  << m_indices_valence_bands.back() << ", band " << m_indices_valence_bands[1] << " with band "
                  << m_indices_valence_bands[m_indices_valence_bands.size() - 2] << std::endl;
    }
    recompute_min_max_energies();
}

void MeshBZ::compute_energy_gradient_at_tetras() {
    for (auto&& tetra : m_list_tetrahedra) {
        tetra.compute_gradient_energy_at_bands();
    }
}

vector3 MeshBZ::interpolate_energy_gradient_at_location(const vector3& location, const std::size_t& idx_band) const {
    Tetra* tetra = find_tetra_at_location(location);
    if (tetra == nullptr) {
        throw std::runtime_error("Location is outside the mesh. Cannot interpolate energy gradient.");
    }
    return tetra->get_gradient_energy_at_band(idx_band);
}

double MeshBZ::compute_mesh_volume() const {
    double total_volume = 0.0;
    for (auto&& tetra : m_list_tetrahedra) {
        total_volume += std::fabs(tetra.get_signed_volume());
        // std::cout << "Tetra " << tetra.get_index() << " volume: " << tetra.get_signed_volume() << std::endl;
    }
    // total_volume *= (1.0 / pow(2.0 * M_PI, 3.0));
    return total_volume;
}

double MeshBZ::compute_iso_surface(double iso_energy, int band_index) const {
    double total_dos = 0.0;
    for (auto&& tetra : m_list_tetrahedra) {
        total_dos += tetra.compute_tetra_iso_surface_energy_band(iso_energy, band_index);
    }

    return total_dos;
}

double MeshBZ::compute_dos_at_energy_and_band(double iso_energy, int band_index, bool use_interp) const {
    double total_dos = 0.0;
    for (auto&& tetra : m_list_tetrahedra) {
        if (use_interp) {
            total_dos += tetra.interpolate_dos_at_energy_per_band(iso_energy, band_index);
        } else {
            total_dos += tetra.compute_tetra_dos_energy_band(iso_energy, band_index);
        }
    }
    total_dos *= get_reduce_bz_factor();
    total_dos *= m_spin_degeneracy;
    return total_dos;
}

std::vector<std::vector<double>> MeshBZ::compute_dos_band_at_band(int         band_index,
                                                                  double      min_energy,
                                                                  double      max_energy,
                                                                  int         num_threads,
                                                                  std::size_t nb_points,
                                                                  bool        use_interp) const {
    auto   start       = std::chrono::high_resolution_clock::now();
    double energy_step = (max_energy - min_energy) / (nb_points - 1);

    std::vector<double> list_energies{};
    std::vector<double> list_dos{};
#pragma omp parallel for schedule(dynamic) num_threads(num_threads) reduction(merge : list_energies) reduction(merge : list_dos)
    for (std::size_t index_energy = 0; index_energy < nb_points; ++index_energy) {
        double energy = min_energy + index_energy * energy_step;
        double dos    = compute_dos_at_energy_and_band(energy, band_index);
        list_energies.push_back(energy);
        list_dos.push_back(dos);
        //         std::cout << "\rComputing density of state at energy " << index_energy << "/" << nb_points << std::flush;
    }
    auto end              = std::chrono::high_resolution_clock::now();
    auto total_time_count = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "\nDOS for 1 band computed in  " << total_time_count / 1000.0 << "s" << std::endl;
    return {list_energies, list_dos};
}

std::vector<std::vector<double>> MeshBZ::compute_dos_band_at_band_auto(int         band_index,
                                                                       std::size_t nb_points,
                                                                       int         num_threads,
                                                                       bool        use_interp) const {
    if (band_index < 0 || band_index >= static_cast<int>(m_min_band.size())) {
        throw std::out_of_range("Band index out of range in compute_dos_band_at_band_auto.");
    }

    const double margin_energy = 0.1;
    double       min_energy    = m_min_band[band_index] - margin_energy;
    double       max_energy    = m_max_band[band_index] + margin_energy;
    auto         start         = std::chrono::high_resolution_clock::now();
    double       energy_step   = (max_energy - min_energy) / (nb_points - 1);

    std::vector<double> list_energies{};
    std::vector<double> list_dos{};
#pragma omp parallel for schedule(dynamic) num_threads(num_threads) reduction(merge : list_energies) reduction(merge : list_dos)
    for (std::size_t index_energy = 0; index_energy < nb_points; ++index_energy) {
        double energy = min_energy + index_energy * energy_step;
        double dos    = compute_dos_at_energy_and_band(energy, band_index, use_interp);
        list_energies.push_back(energy);
        list_dos.push_back(dos);
    }
    auto end              = std::chrono::high_resolution_clock::now();
    auto total_time_count = std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count();
    std::cout << "\nDOS for 1 band computed in  " << total_time_count / 1000.0 << "s" << std::endl;
    return {list_energies, list_dos};
}

/**
 * @brief Draw a random tetrahedron index in the mesh, on a iso-energy surface.
 *
 * @param energy
 * @param idx_band
 * @param random_generator
 * @return std::size_t
 */
std::size_t MeshBZ::draw_random_tetrahedron_index_with_dos_probability(double        energy,
                                                                       std::size_t   idx_band,
                                                                       std::mt19937& random_generator) const {
    std::vector<double> list_dos;
    list_dos.reserve(m_list_tetrahedra.size());
    std::cout << "Computing DOS weights for tetrahedra at energy " << energy << " eV ..." << std::endl;
    for (auto&& tetra : m_list_tetrahedra) {
        std::cout << "\rTetra " << tetra.get_index() << "/" << m_list_tetrahedra.size() << std::flush;
        double dos = tetra.compute_tetra_dos_energy_band(energy, idx_band);
        list_dos.push_back(dos);
    }
    std::cout << "\nDrawing tetrahedron with DOS weights ..." << std::endl;
    std::discrete_distribution<std::size_t> distribution(list_dos.begin(), list_dos.end());
    return distribution(random_generator);
}

/**
 * @brief Draw a random k-vector in the mesh, on a iso-energy surface.
 * The k-vector is drawn with a probability locally proportional to the DOS.
 *
 * @param energy
 * @param idx_band
 * @param random_generator
 * @return vector3
 */
vector3 MeshBZ::draw_random_k_point_at_energy(double energy, std::size_t idx_band, std::mt19937& random_generator) const {
    if (energy < m_min_band[idx_band] || energy > m_max_band[idx_band]) {
        throw std::runtime_error("Energy is out of range");
    }
    const std::size_t index_tetra = draw_random_tetrahedron_index_with_dos_probability(energy, idx_band, random_generator);
    std::cout << "Selected tetrahedron index: " << index_tetra << std::endl;
    if (index_tetra >= m_list_tetrahedra.size()) {
        throw std::runtime_error("Selected tetrahedron index is out of range");
    }
    return m_list_tetrahedra[index_tetra].draw_random_uniform_point_at_energy(energy, idx_band, random_generator);
}

void MeshBZ::export_k_points_to_file(const std::string& filename) const {
    std::ofstream file(filename);
    if (!file.is_open()) {
        throw std::invalid_argument("Could not open file " + filename + " for writing.");
    }
    for (auto&& k_point : m_list_vertices) {
        file << k_point.get_position().x() << "," << k_point.get_position().y() << "," << k_point.get_position().z() << std::endl;
    }
    file.close();
}

// helper: half-width in reduced units.
static inline double bz_halfwidth_reduced() { return 1.0; }  // <- your case

bool MeshBZ::is_inside_mesh_geometry(const vector3& k) const {
    const double     s   = si_to_reduced_scale();   // converts SI (1/m) -> reduced (unitless)
    const double     hw  = bz_halfwidth_reduced();  // 1.0 for [-1,1], 0.5 for [-0.5,0.5]
    constexpr double eps = 1e-12;

    const double kx = k.x() * s;
    const double ky = k.y() * s;
    const double kz = k.z() * s;

    const double ax = std::fabs(kx);
    const double ay = std::fabs(ky);
    const double az = std::fabs(kz);

    const bool cond1 = (ax <= hw + eps) && (ay <= hw + eps) && (az <= hw + eps);
    const bool cond2 = (ax + ay + az) <= (1.5 * hw + eps);

    return cond1 && cond2;
}

void MeshBZ::precompute_G_shifts() {
    vector3      b1 = {-1.0, 1.0, 1.0};
    vector3      b2 = {1.0, -1.0, 1.0};
    vector3      b3 = {1.0, 1.0, -1.0};
    const double s  = si_to_reduced_scale();
    b1 /= s;
    b2 /= s;
    b3 /= s;

    const int maxShell = 5;  // adjust as needed

    // shell 0
    m_Gshifts.push_back({0, 0, 0});

    // by increasing |n1|+|n2|+|n3|
    for (int L1 = 1; L1 <= maxShell; ++L1) {
        for (int n1 = -L1; n1 <= L1; ++n1) {
            for (int n2 = -L1; n2 <= L1; ++n2) {
                for (int n3 = -L1; n3 <= L1; ++n3) {
                    if (n1 == 0 && n2 == 0 && n3 == 0) continue;
                    if (std::abs(n1) + std::abs(n2) + std::abs(n3) == L1) {
                        m_Gshifts.push_back(n1 * b1 + n2 * b2 + n3 * b3);
                    }
                }
            }
        }
    }
}

vector3 MeshBZ::retrieve_k_inside_mesh_geometry(const vector3& k) const {
    for (const auto& G : m_Gshifts) {
        const vector3 kG = k + G;
        if (is_inside_mesh_geometry(kG)) {
            return kG;
        }
    }
    std::cout << "No k-point inside the mesh geometry found for k: " << k << std::endl;
    throw std::runtime_error("No k-point inside the mesh geometry found.");
}

// --- O(1) WS-BZ folding (public API) ---
/**
 * @brief Initialize the reciprocal basis and reduced-frame parameters for O(1) folding.
 * @param b1_SI First reciprocal primitive vector (SI, 1/m)
 * @param b2_SI Second reciprocal primitive vector (SI, 1/m)
 * @param b3_SI Third reciprocal primitive vector (SI, 1/m)
 * @param halfwidth_reduced Half-width in reduced coords (0.5 for [-0.5,0.5])
 * @param si_to_reduced Scale factor from SI (1/m) to reduced coords used by plane tests
 */
void MeshBZ::init_reciprocal_basis(const Eigen::Vector3d& b1_SI,
                                   const Eigen::Vector3d& b2_SI,
                                   const Eigen::Vector3d& b3_SI,
                                   double                 halfwidth_reduced,
                                   double                 si_to_reduced) {
    m_recip_B.col(0) = b1_SI;
    m_recip_B.col(1) = b2_SI;
    m_recip_B.col(2) = b3_SI;
    m_recip_Bi       = m_recip_B.inverse();

    m_bz_halfwidth = halfwidth_reduced;  // e.g. 0.5 for [-0.5,0.5]
    m_si2red       = si_to_reduced;      // must match your is_inside_mesh_geometry() scale
}

/**
 * @brief Fold k into the Wigner–Seitz BZ (truncated octahedron of bcc). Pure, no side effects.
 * @param k_SI Input wavevector (SI, 1/m)
 * @return Folded wavevector inside the first BZ (SI, 1/m)
 */
vector3 MeshBZ::fold_ws_bcc(const vector3& k_SI) const noexcept {
    // Convert to Eigen for the tiny linear algebra steps
    Eigen::Vector3d ke(k_SI.x(), k_SI.y(), k_SI.z());

    // A) Nearest-lattice wrap (Babai rounding) into the primitive parallelepiped
    Eigen::Vector3d r  = m_recip_Bi * ke;    // reduced coords in basis of reciprocal vectors
    Eigen::Array3d  n  = r.array().round();  // nearest reciprocal-lattice node
    Eigen::Vector3d k0 = ke - m_recip_B * n.matrix();

    // B) Apply WS (truncated-octahedron) plane tests in your reduced frame
    Eigen::Vector3d kr = m_si2red * k0;

    const double hw      = m_bz_halfwidth;
    const double sum_lim = 1.5 * hw;
    const double eps     = 1e-12 * std::max(1.0, hw);

    // A few corrections always suffice after Babai; 3 passes is plenty.
    for (int it = 0; it < 3; ++it) {
        const double ax = std::abs(kr.x()), ay = std::abs(kr.y()), az = std::abs(kr.z());
        bool         moved = false;

        // 6 square faces: |x|,|y|,|z| ≤ hw
        if (ax > hw + eps) {
            kr.x() -= (kr.x() > 0 ? 1.0 : -1.0) * 2.0 * hw;
            moved = true;
        }
        if (ay > hw + eps) {
            kr.y() -= (kr.y() > 0 ? 1.0 : -1.0) * 2.0 * hw;
            moved = true;
        }
        if (az > hw + eps) {
            kr.z() -= (kr.z() > 0 ? 1.0 : -1.0) * 2.0 * hw;
            moved = true;
        }

        // 8 hex faces: |x| + |y| + |z| ≤ 1.5*hw
        if ((ax + ay + az) > (sum_lim + eps)) {
            const int    idx    = (ax >= ay && ax >= az) ? 0 : (ay >= az ? 1 : 2);
            const double excess = (ax + ay + az) - sum_lim;
            if (idx == 0)
                kr.x() -= (kr.x() > 0 ? 1.0 : -1.0) * excess;
            else if (idx == 1)
                kr.y() -= (kr.y() > 0 ? 1.0 : -1.0) * excess;
            else
                kr.z() -= (kr.z() > 0 ? 1.0 : -1.0) * excess;
            moved = true;
        }

        if (!moved) break;  // inside WS
    }

    // Back to SI and convert to your vector3
    Eigen::Vector3d kf = kr / m_si2red;
    return vector3{kf.x(), kf.y(), kf.z()};
}

/**
 * @brief Check if k is inside the WS BZ using the same plane tests as is_inside_mesh_geometry().
 * @param k_SI Input wavevector (SI, 1/m)
 * @return true if inside, false otherwise
 */
bool MeshBZ::inside_ws_bcc(const vector3& k_SI) const noexcept {
    Eigen::Vector3d kr = m_si2red * Eigen::Vector3d(k_SI.x(), k_SI.y(), k_SI.z());
    const double    hw = m_bz_halfwidth, eps = 1e-12 * std::max(1.0, hw);
    const double    ax = std::abs(kr.x()), ay = std::abs(kr.y()), az = std::abs(kr.z());
    // use bitwise & so all comparisons are evaluated (branchless)
    return (ax <= hw + eps) & (ay <= hw + eps) & (az <= hw + eps) & ((ax + ay + az) <= (1.5 * hw + eps));
}

// bool is_in_first_BZ(const Vector3D<double>& k, bool one_eighth = false) {
//     bool cond_1      = fabs(k.X) <= 1.0 && fabs(k.Y) <= 1.0 && fabs(k.Z) <= 1.0;
//     bool cond_2      = fabs(k.X) + fabs(k.Y) + fabs(k.Z) <= 3.0 / 2.0;
//     bool cond_eighth = (k.X >= 0.0 && k.Y >= 0.0 && k.Z >= 0.0);
//     return cond_1 && cond_2 && (one_eighth ? cond_eighth : true);
// }

// def IsInIrreducibleWedge(k):
//     return (k[2] >= 0.0 and k[2] <= k[1] and k[1] <= k[0] and k[0] <= 1.0) and \
//         (np.sum(k) <= 3.0/2.0)

bool MeshBZ::is_irreducible_wedge(const vector3& k_SI) const noexcept {
    const double x = k_SI.x() * si_to_reduced_scale();
    const double y = k_SI.y() * si_to_reduced_scale();
    const double z = k_SI.z() * si_to_reduced_scale();
    // std::cout << "Checking irreducible wedge for k = (" << x << ", " << y << ", " << z << ")" << std::endl;
    constexpr double eps = 1e-12;
    return (x >= -eps) && (y >= -eps) && (z >= -eps) && (x <= y + eps) && (y <= z + eps) && (z <= 1.0 + eps) && ((x + y + z) <= 1.5 + eps);
}

/**
 * @brief Find the index of the vertex in the irreducible wedge that represents k_SI.
 * In this version, we first first fold k_SI into the first IW, then search for the closest vertex.
 *
 *
 * @param k_SI
 * @return std::size_t
 */
std::size_t MeshBZ::get_index_irreducible_wedge(const vector3& k_SI) const noexcept {
    vector3 k_folded = {std::fabs(k_SI.x()), std::fabs(k_SI.y()), std::fabs(k_SI.z())};
    // Test the 6 permutations of (|kx|, |ky|, |kz|)
    std::array<vector3, 6> permutations = {vector3{k_folded.x(), k_folded.y(), k_folded.z()},
                                           vector3{k_folded.x(), k_folded.z(), k_folded.y()},
                                           vector3{k_folded.y(), k_folded.x(), k_folded.z()},
                                           vector3{k_folded.y(), k_folded.z(), k_folded.x()},
                                           vector3{k_folded.z(), k_folded.x(), k_folded.y()},
                                           vector3{k_folded.z(), k_folded.y(), k_folded.x()}};
    bool                   found        = false;
    for (auto&& perm : permutations) {
        if (is_irreducible_wedge(perm)) {
            k_folded = perm;
            found    = true;
            break;
        }
    }
    std::cout << std::setprecision(6) << std::fixed;
    // std::cout << k_folded*si_to_reduced_scale() << std::endl;
    if (!found) {
        std::cout << "Could not fold k = " << k_SI << " into the irreducible wedge." << std::endl;
        throw std::runtime_error("Could not fold k into the irreducible wedge.");
    }
    // Now search for the closest vertex in the IW
    double       min_dist = std::numeric_limits<double>::max();
    std::size_t  idx_min  = 0;
    const double s        = si_to_reduced_scale();
    for (const auto& vtx : m_list_vertices) {
        if (is_irreducible_wedge(vtx.get_position())) {
            double dist = (vtx.get_position() - k_folded).norm_squared();
            if (dist < min_dist) {
                min_dist = dist;
                idx_min  = vtx.get_index();
            }
        }
    }
    // Scientific notation for very small distances
    // std::cout << "Min dist in IW: " << std::scientific << std::sqrt(min_dist) * si_to_reduced_scale() << std::endl;
    return idx_min;
}

#include <fstream>
#include <iomanip>
#include <map>
#include <stdexcept>
#include <string>

static inline void bz_write_vtk_scalars(std::ofstream&             out,
                                        const std::string&         name,
                                        const std::vector<double>& vals,
                                        const char*                loc_keyword,  // "POINT_DATA" or "CELL_DATA" already emitted
                                        std::size_t                expected_count) {
    if (vals.size() != expected_count) {
        throw std::runtime_error("VTK export: scalar field '" + name + "' has size " + std::to_string(vals.size()) + ", expected " +
                                 std::to_string(expected_count));
    }
    out << "SCALARS " << name << " double 1\n";
    out << "LOOKUP_TABLE default\n";
    out << std::setprecision(17);
    for (double v : vals)
        out << v << "\n";
}

static inline void bz_write_vtk_vectors(std::ofstream&              out,
                                        const std::string&          name,
                                        const std::vector<vector3>& vecs,
                                        const char*                 loc_keyword,
                                        std::size_t                 expected_count) {
    if (vecs.size() != expected_count) {
        throw std::runtime_error("VTK export: vector field '" + name + "' has size " + std::to_string(vecs.size()) + ", expected " +
                                 std::to_string(expected_count));
    }
    out << "VECTORS " << name << " double\n";
    out << std::setprecision(17);
    for (const auto& v : vecs) {
        out << v.x() << " " << v.y() << " " << v.z() << "\n";
    }
}

void MeshBZ::export_to_vtk(const std::string&        filename,
                           const MapStringToDoubles& point_scalars,
                           const MapStringToVectors& point_vectors,
                           const MapStringToDoubles& cell_scalars,
                           const MapStringToVectors& cell_vectors) const {
    const std::size_t n_points = m_list_vertices.size();
    const std::size_t n_cells  = m_list_tetrahedra.size();

    std::ofstream out(filename);
    if (!out) throw std::runtime_error("Cannot open VTK file '" + filename + "' for writing.");

    // --- VTK legacy header (ASCII, UnstructuredGrid) ---
    out << "# vtk DataFile Version 4.2\n";
    out << "BZ mesh export\n";
    out << "ASCII\n";
    out << "DATASET UNSTRUCTURED_GRID\n";

    // --- POINTS ---
    out << "POINTS " << n_points << " double\n";
    out << std::setprecision(17);
    for (const auto& v : m_list_vertices) {
        const auto& p = v.get_position();
        out << p.x() << " " << p.y() << " " << p.z() << "\n";
    }

    // --- CELLS (tetra) ---
    // For legacy VTK: total_indices = n_cells * (1 + 4) because each line: "4 i0 i1 i2 i3"
    const std::size_t total_idx = n_cells * (1 + 4);
    out << "CELLS " << n_cells << " " << total_idx << "\n";
    for (const auto& t : m_list_tetrahedra) {
        const auto ids = t.get_list_indices_vertices();  // assumes 0-based vertex ids
        out << "4 " << ids[0] << " " << ids[1] << " " << ids[2] << " " << ids[3] << "\n";
    }

    // --- CELL_TYPES (tetra = 10) ---
    out << "CELL_TYPES " << n_cells << "\n";
    for (std::size_t i = 0; i < n_cells; ++i)
        out << "10\n";

    // --- Optional per-vertex data ---
    if (!point_scalars.empty() || !point_vectors.empty()) {
        out << "POINT_DATA " << n_points << "\n";
        for (const auto& [name, vals] : point_scalars) {
            bz_write_vtk_scalars(out, name, vals, "POINT_DATA", n_points);
        }
        for (const auto& [name, vecs] : point_vectors) {
            bz_write_vtk_vectors(out, name, vecs, "POINT_DATA", n_points);
        }
    }

    // --- Optional per-cell data ---
    if (!cell_scalars.empty() || !cell_vectors.empty()) {
        out << "CELL_DATA " << n_cells << "\n";
        for (const auto& [name, vals] : cell_scalars) {
            bz_write_vtk_scalars(out, name, vals, "CELL_DATA", n_cells);
        }
        for (const auto& [name, vecs] : cell_vectors) {
            bz_write_vtk_vectors(out, name, vecs, "CELL_DATA", n_cells);
        }
    }
    out.close();
}




void MeshBZ::export_energies_and_gradients_to_vtk(const std::string& filename) const {
    std::map<std::string, std::vector<double>> point_scalars;
    std::map<std::string, std::vector<vector3>> point_vectors;

    // Per-vertex band energies
    for (std::size_t b = 0; b < m_list_vertices[0].get_number_bands(); ++b) {
        std::string               name = "band_energy_" + std::to_string(b);
        std::vector<double>       vals;
        vals.reserve(m_list_vertices.size());
        for (const auto& v : m_list_vertices) {
            vals.push_back(v.get_energy_at_band(b));
        }
        point_scalars[name] = vals;
    }

    // Per-vertex band energy gradients
    for (std::size_t b = 0; b < m_list_vertices[0].get_number_bands(); ++b) {
        std::string               name = "band_grad_" + std::to_string(b);
        std::vector<vector3>      vecs;
        vecs.reserve(m_list_vertices.size());
        for (const auto& v : m_list_vertices) {
            vecs.push_back(v.get_energy_gradient_at_band(b));
        }
        point_vectors[name] = vecs;
    }
    export_to_vtk(filename, point_scalars, point_vectors, {}, {});
}

}  // namespace bz_mesh/**
 * @file iso_triangle.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-16
 *
 * @copyright Copyright (c) 2022
 *
 */

#include <array>
#include <random>
#include <vector>

#include "vector.hpp"

namespace bz_mesh {

/**
 * @brief This class represent the iso energy triangle within a Tetra.
 *
 */
class IsoTriangle {
 private:
    /**
     * @brief The positions of the 3 vertices of the triangle.
     *
     */
    std::array<vector3, 3> m_list_vertices{};

    /**
     * @brief Iso energy the triangle was constructed with.
     *
     */
    double m_iso_energy;

    /**
     * @brief List of the edges vectors of the tetrahedra.
     * Stored as follows: [v01, v02, v12]
     * where for example v12 = m_list_vertices[1] - m_list_vertices[2].
     *
     */
    std::array<vector3, 3> m_list_edges{};

    /**
     * @brief Signed volume of the tetrahedra.
     * The sign depends on the "orientation" of the tetrahedra.
     *
     */
    double m_surface;

 public:
    IsoTriangle() = delete;

    /**
     * @brief Construct a new Iso Triangle object from the list of vertices and the iso energy.
     *
     * @param VtxA
     * @param VtxB
     * @param VtxC
     * @param iso_energy
     */
    IsoTriangle(const vector3& VtxA, const vector3& VtxB, const vector3& VtxC, double iso_energy)
        : m_list_vertices{VtxA, VtxB, VtxC},
          m_iso_energy(iso_energy),
          m_list_edges{VtxA - VtxB, VtxA - VtxC, VtxB - VtxC},
          m_surface{0.5 * (cross_product(m_list_edges[1], m_list_edges[2]).norm())} {}

    /**
     * @brief Get the iso energy of the triangle.
     *
     * @return double
     */
    double get_iso_energy() const { return m_iso_energy; }

    /**
     * @brief Get the surface of the triangle.
     *
     * @return double
     */
    double get_signed_surface() const { return m_surface; }

    /**
     * @brief Draw a random point in the triangle. Uniform distribution.
     * See https://math.stackexchange.com/questions/538458/how-to-sample-points-on-a-triangle-surface-in-3d
     *
     * @param gen
     * @return vector3
     */
    vector3 draw_random_uniform_point_in_triangle(std::mt19937& gen) const {
        std::uniform_real_distribution<> dis_double(0.0, 1.0);
        double                           random_a = dis_double(gen);
        double                           random_b = dis_double(gen);
        double                           lambda_1 = (1.0 - sqrt(random_a));
        double                           lambda_2 = sqrt(random_a) * (1.0 - random_b);
        double                           lambda_3 = sqrt(random_a) * random_b;
        //   return get_center();
        return m_list_vertices[0] * lambda_1 + m_list_vertices[1] * lambda_2 + m_list_vertices[2] * lambda_3;
    }
};

}  // namespace bz_mesh/**
 * @file mesh_tetra.cpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "mesh_tetra.hpp"

#include <algorithm>
#include <array>
#include <cmath>
#include <iomanip>
#include <vector>

#include "Constants.hpp"
#include "bbox_mesh.hpp"
#include "iso_triangle.hpp"

namespace bz_mesh {

bbox_mesh Tetra::compute_bounding_box() const {
    std::array<double, 4> coordinates_x;
    std::array<double, 4> coordinates_y;
    std::array<double, 4> coordinates_z;
    for (int i = 0; i < 4; ++i) {
        coordinates_x[i] = m_list_vertices[i]->get_position().x();
        coordinates_y[i] = m_list_vertices[i]->get_position().y();
        coordinates_z[i] = m_list_vertices[i]->get_position().z();
    }
    auto min_max_x = std::minmax_element(coordinates_x.begin(), coordinates_x.end());
    auto min_max_y = std::minmax_element(coordinates_y.begin(), coordinates_y.end());
    auto min_max_z = std::minmax_element(coordinates_z.begin(), coordinates_z.end());
    return bbox_mesh(*min_max_x.first, *min_max_x.second, *min_max_y.first, *min_max_y.second, *min_max_z.first, *min_max_z.second);
}

const bbox_mesh& Tetra::get_bounding_box() const { return m_bbox; }

/**
 * @brief Construct a new Tetra by passing directly the array of the four pointers to the vertices.
 *
 * @param list_vertices
 */
Tetra::Tetra(std::size_t index, const std::array<Vertex*, 4>& list_vertices)
    : m_index(index),
      m_list_vertices(list_vertices),
      m_nb_bands{m_list_vertices[0]->get_number_bands()} {
    m_list_edges[0] = compute_edge(1, 0);
    m_list_edges[1] = compute_edge(2, 0);
    m_list_edges[2] = compute_edge(3, 0);
    m_list_edges[3] = compute_edge(2, 1);
    m_list_edges[4] = compute_edge(3, 1);
    m_list_edges[5] = compute_edge(3, 2);
    m_signed_volume = compute_signed_volume();
    m_bbox          = compute_bounding_box();
    m_barycenter    = compute_barycenter();
}

vector3 Tetra::compute_barycenter() const {
    return (m_list_vertices[0]->get_position() + m_list_vertices[1]->get_position() + m_list_vertices[2]->get_position() +
            m_list_vertices[3]->get_position()) /
           4.0;
}

/**
 * @brief Compute the gradient of the energy within the tetrahedron.
 *
 * @param values_at_vertices
 * @return vector3
 */
vector3 Tetra::compute_gradient_at_tetra(const array4d& values_at_vertices) const {
    // Edges from vertex 0 to the others: a = v1 - v0, b = v2 - v0, c = v3 - v0
    const vector3 a = m_list_edges[0];  // V0V1
    const vector3 b = m_list_edges[1];  // V0V2
    const vector3 c = m_list_edges[2];  // V0V3

    // Value differences relative to vertex 0
    const double du1 = values_at_vertices[1] - values_at_vertices[0];
    const double du2 = values_at_vertices[2] - values_at_vertices[0];
    const double du3 = values_at_vertices[3] - values_at_vertices[0];

    // det(R) = a · (b × c)  (note: det = 6 * signed_volume)
    const double     det = dot(a, cross_product(b, c));
    constexpr double eps = 1e-14;
    if (std::abs(det) < eps) {
        // Degenerate tetrahedron — return zero gradient (or handle as you prefer)
        return vector3{0.0, 0.0, 0.0};
    }

    // R^{-T} = (1/det) * [ b×c, c×a, a×b ]  (columns)
    // ∇u = R^{-T} * Δu
    const vector3 grad = (cross_product(b, c) * du1 + cross_product(c, a) * du2 + cross_product(a, b) * du3) / det;

    return grad;
}

void Tetra::compute_gradient_energy_at_bands() {
    m_gradient_energy_per_band.clear();
    std::size_t m_nb_bands = m_list_vertices[0]->get_number_bands();
    m_gradient_energy_per_band.reserve(m_nb_bands);
    for (std::size_t band_index = 0; band_index < m_nb_bands; band_index++) {
        const std::array<double, 4> energies_at_vertices = get_band_energies_at_vertices(band_index);
        // const array4d              values_at_vertices   = {energies_at_vertices[0],
        //                                                    energies_at_vertices[1],
        //                                                    energies_at_vertices[2],
        //                                                    energies_at_vertices[3]};
        m_gradient_energy_per_band.push_back(compute_gradient_at_tetra(energies_at_vertices));
    }
}

/**
 * @brief Compute the minimum and maximum energies of the bands within the tetrahedron.
 *  *
 */
void Tetra::compute_min_max_energies_at_bands() {
    m_nb_bands = m_list_vertices[0]->get_number_bands();
    for (std::size_t idx_band = 0; idx_band < m_nb_bands; ++idx_band) {
        auto energies = get_band_energies_at_vertices(idx_band);
        auto minmax   = std::minmax_element(energies.begin(), energies.end());
        m_min_energy_per_band.push_back(*minmax.first);
        m_max_energy_per_band.push_back(*minmax.second);
    }
}

/**
 * @brief Compute the signed volume of the tetrahedron.
 *
 * @return double
 */
double Tetra::compute_signed_volume() const {
    // std::cout << m_list_edges[0] << std::endl;
    // std::cout << m_list_edges[1] << std::endl;
    return (1.0 / 6.0) * scalar_triple_product(m_list_edges[0], m_list_edges[1], m_list_edges[2]);
}

/**
 * @brief Return the values of the energy of the index_band valence band at the 4 vertices of the tetrahedra.
 *
 * @param index_band
 * @return std::vector<double>
 */
std::array<double, 4> Tetra::get_band_energies_at_vertices(std::size_t index_band) const {
    return {m_list_vertices[0]->get_energy_at_band(index_band),
            m_list_vertices[1]->get_energy_at_band(index_band),
            m_list_vertices[2]->get_energy_at_band(index_band),
            m_list_vertices[3]->get_energy_at_band(index_band)};
}

/**
 * @brief Compute the edge vector between two vertices of the tetrahedra.
 * The result is: vtx_1 - vtx_2.
 *
 * @param index_vtx_1
 * @param index_vtx_2
 * @return vector3
 */
vector3 Tetra::compute_edge(std::size_t index_vtx_1, std::size_t index_vtx_2) const {
    if (index_vtx_1 > 3 || index_vtx_2 > 3) {
        throw std::invalid_argument("In Tetra::compute_edge, the index of vertex must be between 0 and 3.");
    }
    return m_list_vertices[index_vtx_1]->get_position() - m_list_vertices[index_vtx_2]->get_position();
}

/**
 * @brief Compute the barycentric coordinate of a given location within the tetrahedra.
 * The returned array of size 4 contains the barycentric coordinates with respect to the vertices in the following order :
 *  0, 1, 2 and 3, respectively.
 *
 * @warning warning message: Do not use this function to check if the location lies in the tetrahedra,
 * The computation relies on the hypothesis that the location do lies in it. Use Tetra::is_location_inside instead.
 *
 * @param location
 * @return std::array<double, 4>
 */
std::array<double, 4> Tetra::compute_barycentric_coordinates(const vector3& location) const {
    const vector3 v_loc1            = location - m_list_vertices[0]->get_position();
    const double  tetra_determinant = 6.0 * m_signed_volume;
    const double  lambda_2          = scalar_triple_product(v_loc1, m_list_edges[1], m_list_edges[2]) / tetra_determinant;
    const double  lambda_3          = scalar_triple_product(v_loc1, m_list_edges[2], m_list_edges[0]) / tetra_determinant;
    const double  lambda_4          = scalar_triple_product(v_loc1, m_list_edges[0], m_list_edges[1]) / tetra_determinant;
    const double  lambda_1          = 1.0 - lambda_2 - lambda_3 - lambda_4;
    return {lambda_1, lambda_2, lambda_3, lambda_4};
}

/**
 * @brief Compute the linear interpolation of the energy of the band band_index at the point location.
 *
 * @param location
 * @param band_index
 * @return double
 */
double Tetra::interpolate_energy_at_band(const vector3& location, std::size_t band_index) const {
    const auto                  barycentric_coord    = compute_barycentric_coordinates(location);
    const std::array<double, 4> energies_at_vertices = get_band_energies_at_vertices(band_index);
    return energies_at_vertices[0] * barycentric_coord[0] + energies_at_vertices[1] * barycentric_coord[1] +
           energies_at_vertices[2] * barycentric_coord[2] + energies_at_vertices[3] * barycentric_coord[3];
}

/**
 * @brief Check if a given location lies inside the tetrahedra.
 *
 * @param location
 * @return true
 * @return false
 */
bool Tetra::is_location_inside(const vector3& location) const {
    const vector3 v_loc1            = location - m_list_vertices[0]->get_position();
    const vector3 v_loc2            = location - m_list_vertices[1]->get_position();
    const double  tetra_determinant = 6.0 * m_signed_volume;
    const double  lambda_1          = scalar_triple_product(v_loc2, m_list_edges[4], m_list_edges[3]) / tetra_determinant;
    const double  lambda_2          = scalar_triple_product(v_loc1, m_list_edges[1], m_list_edges[2]) / tetra_determinant;
    const double  lambda_3          = scalar_triple_product(v_loc1, m_list_edges[2], m_list_edges[0]) / tetra_determinant;
    const double  lambda_4          = scalar_triple_product(v_loc1, m_list_edges[0], m_list_edges[1]) / tetra_determinant;
    return (lambda_1 >= 0 && lambda_2 >= 0 && lambda_3 >= 0 && lambda_4 >= 0);
}

/**
 * @brief Compute the euclidean position from barycentric coordinates.
 *
 * @param barycentric_coordinates
 * @return vector3
 */
vector3 Tetra::compute_euclidean_coordinates(const std::array<double, 4>& barycentric_coordinates) const {
    return (
        barycentric_coordinates[0] * m_list_vertices[0]->get_position() + barycentric_coordinates[1] * m_list_vertices[1]->get_position() +
        barycentric_coordinates[2] * m_list_vertices[2]->get_position() + barycentric_coordinates[3] * m_list_vertices[3]->get_position());
}

/**
 * @brief Compute the euclidean position from barycentric coordinates, with a given vertices order,
 * that might be different from the vertices of the tetrahedra.
 *
 * @param barycentric_coordinates
 * @param indices_vertex
 * @return vector3
 */
vector3 Tetra::compute_euclidean_coordinates_with_indices(const std::array<double, 4>& barycentric_coordinates,
                                                          const std::array<int, 4>&    indices_vertex) const {
    return (barycentric_coordinates[0] * m_list_vertices[indices_vertex[0]]->get_position() +
            barycentric_coordinates[1] * m_list_vertices[indices_vertex[1]]->get_position() +
            barycentric_coordinates[2] * m_list_vertices[indices_vertex[2]]->get_position() +
            barycentric_coordinates[3] * m_list_vertices[indices_vertex[3]]->get_position());
}

/**
 * @brief Precompute a list of indices a, b, c, d such as, for the conduction band with index index_band,
 * we have Vtx_a <= Vtx_b <= Vtx_c <= Vtx_d in term of energy.
 *
 * This function is written explicitely instead of using std::sort functions, because the sorting is done
 * with the minimum number of operations for a 4 values sorting. Other solution might be tested later.
 *
 * @param index_band
 * @return std::array<int, 4>
 */
void Tetra::pre_compute_sorted_slots_per_band() {
    m_sorted_slots_per_band.clear();
    m_sorted_slots_per_band.reserve(m_nb_bands);
    for (std::size_t band_index = 0; band_index < m_nb_bands; band_index++) {
        std::array<double, 4> energies_at_vertices = get_band_energies_at_vertices(band_index);
        std::array<int, 4>    sorted_index         = {0, 1, 2, 3};
        if (energies_at_vertices[0] > energies_at_vertices[1]) {
            std::swap(energies_at_vertices[0], energies_at_vertices[1]);
            std::swap(sorted_index[0], sorted_index[1]);
        }
        if (energies_at_vertices[2] > energies_at_vertices[3]) {
            std::swap(energies_at_vertices[2], energies_at_vertices[3]);
            std::swap(sorted_index[2], sorted_index[3]);
        }
        if (energies_at_vertices[0] > energies_at_vertices[2]) {
            std::swap(energies_at_vertices[0], energies_at_vertices[2]);
            std::swap(sorted_index[0], sorted_index[2]);
        }
        if (energies_at_vertices[1] > energies_at_vertices[3]) {
            std::swap(energies_at_vertices[1], energies_at_vertices[3]);
            std::swap(sorted_index[1], sorted_index[3]);
        }
        if (energies_at_vertices[1] > energies_at_vertices[2]) {
            std::swap(energies_at_vertices[1], energies_at_vertices[2]);
            std::swap(sorted_index[1], sorted_index[2]);
        }
        m_sorted_slots_per_band.push_back(sorted_index);
    }
}

/**
 * @brief Compute the iso-energy surface within the tetrahedra for a given energy of a given band.
 * The surface is returned as a list of points (3 when the surface is a triangle, 4 when it is a quadrangle).
 *
 * The case of energy being smaller than the minimum energy of the tetrahedra is not taken into account.
 * Same thing for the case of energy being greater than the maximum energy of the tetrahedra.
 * Those two cases are handle by the caller function. This is done to avoid computing the sorted index which is computationallly intensive.
 * The minimum and maximum energies are stored in the member variables
 * m_min_energy_at_vertices and m_max_energy_at_vertices at the construction of the tetrahedra.
 *
 * This is very important because those 2 trivial cases represent usually more than 95% of the cases.
 *
 *
 * @param iso_energy
 * @param band_index
 * @return std::vector<vector3>
 */
std::vector<vector3> Tetra::compute_band_iso_energy_surface(double iso_energy, std::size_t band_index) const {
    std::array<double, 4>     energies_at_vertices = get_band_energies_at_vertices(band_index);
    const std::array<int, 4>& indices_sort         = get_index_vertices_with_sorted_energy_at_band(band_index);
    double                    e_0                  = energies_at_vertices[indices_sort[0]];
    double                    e_1                  = energies_at_vertices[indices_sort[1]];
    double                    e_2                  = energies_at_vertices[indices_sort[2]];
    double                    e_3                  = energies_at_vertices[indices_sort[3]];

    bool check_order = (e_0 <= e_1 && e_1 <= e_2 && e_2 <= e_3);
    if (!check_order) {
        std::cerr << "Error: the order of the energies is not correct" << std::endl;
        throw std::runtime_error("Error: the order of the energies is not correct");
    }

    if (iso_energy < e_1 && iso_energy >= e_0) {
        double  lA_U = (iso_energy - e_0) / (e_1 - e_0);
        vector3 U    = compute_euclidean_coordinates_with_indices({1.0 - lA_U, lA_U, 0.0, 0.0}, indices_sort);
        double  lA_V = (iso_energy - e_0) / (e_2 - e_0);
        vector3 V    = compute_euclidean_coordinates_with_indices({1.0 - lA_V, 0.0, lA_V, 0.0}, indices_sort);
        double  lA_W = (iso_energy - e_0) / (e_3 - e_0);
        vector3 W    = compute_euclidean_coordinates_with_indices({1.0 - lA_W, 0.0, 0.0, lA_W}, indices_sort);
        return {U, V, W};
    }
    if (iso_energy < e_2 && iso_energy >= e_1) {
        double  lA_U = (iso_energy - e_0) / (e_2 - e_0);
        vector3 U    = compute_euclidean_coordinates_with_indices({1.0 - lA_U, 0.0, lA_U, 0.0}, indices_sort);
        double  lA_V = (iso_energy - e_0) / (e_3 - e_0);
        vector3 V    = compute_euclidean_coordinates_with_indices({1.0 - lA_V, 0.0, 0.0, lA_V}, indices_sort);
        double  lA_W = (e_2 - iso_energy) / (e_2 - e_1);
        vector3 W    = compute_euclidean_coordinates_with_indices({0.0, lA_W, 1.0 - lA_W, 0.0}, indices_sort);
        double  lA_X = (iso_energy - e_1) / (e_3 - e_1);
        vector3 X    = compute_euclidean_coordinates_with_indices({0.0, 1.0 - lA_X, 0.0, lA_X}, indices_sort);
        return {U, V, W, X};
    }
    if (iso_energy >= e_2) {
        double  lC_U = (e_3 - iso_energy) / (e_3 - e_2);
        vector3 U    = compute_euclidean_coordinates_with_indices({0.0, 0.0, lC_U, 1.0 - lC_U}, indices_sort);
        double  lB_V = (e_3 - iso_energy) / (e_3 - e_1);
        vector3 V    = compute_euclidean_coordinates_with_indices({0.0, lB_V, 0.0, 1.0 - lB_V}, indices_sort);
        double  lA_W = (e_3 - iso_energy) / (e_3 - e_0);
        vector3 W    = compute_euclidean_coordinates_with_indices({lA_W, 0.0, 0.0, 1.0 - lA_W}, indices_sort);
        return {U, V, W};
    } else {
        std::cout << "DATA OUT : " << iso_energy << " " << e_0 << " " << e_1 << " " << e_2 << " " << e_3 << std::endl;
        throw std::runtime_error("ISO SURFACE CASE UNKNOWN IN DOS COMPUTATION... ABORT.");
    }
    return {};
}

// Area of triangle (A,B,C) in 3D: 0.5 * || (B-A) × (C-A) ||
[[nodiscard]] inline double triangle_area(const vector3& A, const vector3& B, const vector3& C) noexcept {
    const vector3 AB = B - A;
    const vector3 AC = C - A;
    return 0.5 * cross_product(AB, AC).norm();
}

// Returns vertices ordered cyclically in the plane they lie on
inline std::vector<vector3> order_cyclic(const std::vector<vector3>& pts) {
    if (pts.size() < 3) return pts;

    // Compute centroid
    vector3 centroid = std::accumulate(pts.begin(), pts.end(), vector3{0, 0, 0});
    centroid /= static_cast<double>(pts.size());

    // Compute polygon normal from first 3 distinct points
    vector3 n   = cross_product(pts[1] - pts[0], pts[2] - pts[0]);
    double  len = n.norm();
    if (len > 0.0) n /= len;  // normalize

    // Choose an in-plane axis u
    vector3 u    = pts[0] - centroid;
    double  ulen = u.norm();
    if (ulen > 0.0)
        u /= ulen;
    else
        u = vector3{1, 0, 0};  // fallback

    // v = n × u (second in-plane axis)
    vector3 v = cross_product(n, u);

    struct VertexAngle {
        vector3 p;
        double  angle;
    };
    std::vector<VertexAngle> with_angles;
    with_angles.reserve(pts.size());

    for (auto& p : pts) {
        vector3 d     = p - centroid;
        double  x     = dot(d, u);
        double  y     = dot(d, v);
        double  angle = std::atan2(y, x);  // -pi .. pi
        with_angles.push_back({p, angle});
    }

    std::sort(with_angles.begin(), with_angles.end(), [](auto& a, auto& b) { return a.angle < b.angle; });

    std::vector<vector3> ordered;
    ordered.reserve(pts.size());
    for (auto& wa : with_angles)
        ordered.push_back(wa.p);

    return ordered;
}

/**
 * @brief Compute the surface of the tetrahedra for a given energy of a given band.
 * The iso-surface is computed by the function compute_band_iso_energy_surface, and then
 * the area of the surface is computed.
 *
 * If the surface is a triangle, the area is computed by the class IsoTriangle class function "get_signed_area".
 * If the surface is a quadrangle, the area is computed by splitting the quadrangle into 2 triangles and then computing the area of each
 * triangle.
 *
 * A more direct way to compute the area in both cases should be tested for performances improvement.
 *  *
 * @param energy
 * @param band_index
 * @return double
 */
double Tetra::compute_tetra_iso_surface_energy_band(double energy, std::size_t band_index) const {
    std::vector<vector3> vertices_iso_surface = compute_band_iso_energy_surface(energy, band_index);
    if (vertices_iso_surface.size() == 3) {
        return triangle_area(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2]);
    } else if (vertices_iso_surface.size() == 4) {
        vertices_iso_surface = order_cyclic(vertices_iso_surface);
        return triangle_area(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[3]) +
               triangle_area(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2]);
    } else {
        return 0.0;
    }
}

double Tetra::compute_tetra_iso_surface_energy_band2(double energy, std::size_t band_index) const {
    std::vector<vector3> vertices_iso_surface = compute_band_iso_energy_surface(energy, band_index);
    if (vertices_iso_surface.empty()) {
        return 0.0;
    } else if (vertices_iso_surface.size() == 3) {
        IsoTriangle triangle(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], energy);
        return fabs(triangle.get_signed_surface());
    } else {
        vertices_iso_surface = order_cyclic(vertices_iso_surface);
        IsoTriangle triangle1(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[3], energy);
        IsoTriangle triangle2(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], energy);
        return fabs(triangle1.get_signed_surface()) + fabs(triangle2.get_signed_surface());
    }
}

inline double polygon_area(const std::vector<vector3>& pts) {
    auto pts_ordered = order_cyclic(pts);
    if (pts_ordered.size() < 3) return 0.0;

    vector3 sum{0, 0, 0};
    for (size_t i = 0; i < pts_ordered.size(); ++i) {
        const vector3& p0 = pts_ordered[i];
        const vector3& p1 = pts_ordered[(i + 1) % pts_ordered.size()];
        sum += cross_product(p0, p1);
    }
    return 0.5 * sum.norm();
}

/**
 * @brief Main function to compute the DOS of the energy energy of the band with index band_index within the tetrahedra.
 *
 * One could try to store the value eps_12, eps_13, eps_14 for each band at the construction step, to avoid computing them each time the
 * function is called.  Returns DOS contribution in states / (eV · m^3)
 * Assumes: k in m^-1; A in m^-2; |∇_k E| in eV·m
 *
 * @param energy
 * @param band_index
 * @return double
 */
double Tetra::compute_tetra_dos_energy_band(double energy_eV, std::size_t band_index) const {
    if (energy_eV < m_min_energy_per_band[band_index] || energy_eV > m_max_energy_per_band[band_index]) {
        return 0.0;
    }

    const double A = polygon_area(compute_band_iso_energy_surface(energy_eV, band_index));  // m^-2

    const double grad = m_gradient_energy_per_band[band_index].norm();  // eV·m
    if (A <= 0.0 || grad <= 0.0) return 0.0;

    constexpr double pref = 1.0 / (8.0 * M_PI * M_PI * M_PI);  // 1/(2π)^3 = 1/(8π^3)

    return pref * (A / grad);
}
void Tetra::precompute_dos_on_energy_grid_per_band(double energy_step, double energy_threshold) {
    m_nb_bands = m_list_vertices[0]->get_number_bands();
    m_dos_per_band.assign(m_nb_bands, UniformDos{});

    for (std::size_t b = 0; b < m_nb_bands; ++b) {
        auto&        T    = m_dos_per_band[b];
        const double Emin = m_min_energy_per_band[b];
        const double Emax = m_max_energy_per_band[b];

        // keep index alignment; mark invalid instead of skipping
        if (!(Emax > Emin) || Emin > energy_threshold) {
            T.valid = false;
            continue;
        }

        // integer number of steps; enforce a small minimum
        std::size_t nb_steps = static_cast<std::size_t>(std::ceil((Emax - Emin) / energy_step));
        if (nb_steps < 5) {
            nb_steps = 5;
        }
        const double dx = (Emax - Emin) / static_cast<double>(nb_steps);

        T.valid  = true;
        T.E0     = Emin;
        T.Emax   = Emax;
        T.inv_dx = 1.0 / dx;
        T.N      = static_cast<uint32_t>(nb_steps + 1);

        T.D.resize(T.N);
        T.D[0]       = 0.0;
        T.D[T.N - 1] = 0.0;

        for (std::size_t idx_energy = 1; idx_energy < nb_steps; ++idx_energy) {
            const double e = Emin + idx_energy * dx;
            T.D[idx_energy] = static_cast<float>(compute_tetra_dos_energy_band(e, b));
            // DEBUG
            // std::cout << e << "," << T.D[idx_energy] / 1e23 << std::endl;
        }
        // std::cout << std::endl;
    }
}

/**
 * @brief Interpolate the density of states (DOS) at a given energy for a specific band.
 * The DOS is precomputed on a uniform energy grid during the tetrahedron initialization.
 * If the energy is outside the precomputed range, the function returns 0.0.
 * The interpolation is linear between the two nearest grid points.
 *
 * @param energy
 * @param band_index
 * @return double
 */
double Tetra::interpolate_dos_at_energy_per_band(double energy, std::size_t band_index) const noexcept {
    return (band_index < m_dos_per_band.size()) ? m_dos_per_band[band_index].sample_or_zero(energy) : 0.0;
}

/**
 * @brief Draw a random point on the iso-energy surface within the tetrahedra.
 *
 * @param iso_energy
 * @param band_index
 * @param rng
 * @return vector3
 */
vector3 Tetra::draw_random_uniform_point_at_energy(double iso_energy, std::size_t band_index, std::mt19937& rng) const {
    std::cout << "Draw random point at energy: " << iso_energy << " in band: " << band_index << std::endl;
    if (iso_energy < m_min_energy_per_band[band_index] || iso_energy > m_max_energy_per_band[band_index]) {
        std::cout << "Band index: " << band_index << std::endl;
        std::cout << "Energie bound: " << m_min_energy_per_band[band_index] << " " << m_max_energy_per_band[band_index] << std::endl;
        std::cout << "iso_energy: " << iso_energy << std::endl;
        throw std::invalid_argument("Energy is not in the band for this tetrahedron. Cannot draw a random point at this energy.");
    }
    const std::vector<vector3> vertices_iso_surface = compute_band_iso_energy_surface(iso_energy, band_index);
    if (vertices_iso_surface.empty()) {
        throw std::invalid_argument("Energy is not in the band for this tetrahedron. Cannot draw a random point at this energy.");
    } else if (vertices_iso_surface.size() == 3) {
        IsoTriangle triangle(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], iso_energy);
        auto        point = triangle.draw_random_uniform_point_in_triangle(rng);
        return point;
    } else {
        // If the iso-energy shape is a quadrilateral, the point is drawn uniformly in the quadrilateral.
        // To do so, we randomly select on of the triangle, with a probability following the area of the triangle.
        // Then we draw a point in the selected triangle, and return the point.
        IsoTriangle  triangle1(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[3], iso_energy);
        IsoTriangle  triangle2(vertices_iso_surface[0], vertices_iso_surface[1], vertices_iso_surface[2], iso_energy);
        const double surface_triangle1 = triangle1.get_signed_surface();
        const double surface_triangle2 = triangle2.get_signed_surface();
        std::uniform_real_distribution<double> dist(0.0, surface_triangle1 + surface_triangle2);
        return dist(rng) < surface_triangle1 ? triangle1.draw_random_uniform_point_in_triangle(rng)
                                             : triangle2.draw_random_uniform_point_in_triangle(rng);
    }
}

bool Tetra::is_energy_inside_band(double energy, std::size_t index_band) const {
    return (energy >= m_min_energy_per_band[index_band] && energy <= m_max_energy_per_band[index_band]);
}

bool Tetra::does_intersect_band_energy_range(double e_min, double e_max, std::size_t index_band) const {
    return !(e_max < m_min_energy_per_band[index_band] || e_min > m_max_energy_per_band[index_band]);
}

std::array<double, 8> Tetra::get_tetra_electron_phonon_rates(int band_index) const {
    std::array<double, 8> mean_rates;
    std::fill(mean_rates.begin(), mean_rates.end(), 0.0);
    for (std::size_t i = 0; i < 4; i++) {
        if (band_index >= static_cast<int>(m_list_vertices[i]->get_number_bands())) {
            throw std::invalid_argument("In Tetra::get_tetra_electron_phonon_rates, the band index is out of range.");
        }
        const std::array<double, 8>& rates = m_list_vertices[i]->get_electron_phonon_rates(band_index);
        std::transform(mean_rates.begin(), mean_rates.end(), rates.begin(), mean_rates.begin(), std::plus<double>());
    }
    std::transform(mean_rates.begin(), mean_rates.end(), mean_rates.begin(), [](double val) { return val / 4.0; });
    return mean_rates;
}

}  // namespace bz_mesh/**
 * @file bz_mesh.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>
#include <Eigen/Sparse>
#include <filesystem>
#include <regex>
#include <sstream>
#include <unordered_map>

#include "Material.h"
#include "iso_triangle.hpp"
#include "mesh_tetra.hpp"
#include "mesh_vertex.hpp"
#include "octree_bz.hpp"
#include "vector.hpp"

namespace bz_mesh {

using EigenIntSparseMatrix = Eigen::SparseMatrix<int, Eigen::RowMajor>;
using TripletInt           = Eigen::Triplet<int>;

using MapStringToDoubles = std::map<std::string, std::vector<double>>;
using MapStringToVectors = std::map<std::string, std::vector<vector3>>;

enum class BandType { valence, conduction };

class MeshBZ {
 protected:
    /**
     * @brief The material of the Brillouin zone.
     *
     */
    EmpiricalPseudopotential::Material m_material;

    /**
     * @brief G vector on which the BZ is centered.
     *
     */
    vector3 m_center = {0.0, 0.0, 0.0};

    /**
     * @brief The tags of the nodes in the mesh.
     * These tags are used to identify the vertices in the GMSH files when load is done.
     */
    std::vector<std::size_t> m_node_tags;

    /**
     * @brief List of the vertices of the BZ mesh. Each vertices represent a vector k within the Brillouin Zone.
     *
     */
    std::vector<Vertex> m_list_vertices;

    /**
     * @brief List of the elements (tetrahedra) of the mesh.
     *
     */
    std::vector<Tetra> m_list_tetrahedra;

    /**
     * @brief Stores for each vertex index the list of tetrahedra indices that contains this vertex.
     * For example, m_vertex_to_tetrahedra[5] = {0, 2, 3} means that the vertex with index 5 is part of the tetrahedra with indices 0, 2
     * and 3.
     *
     * This is used to speed up the search of the tetrahedra containing a given vertex.
     */
    std::vector<std::vector<std::size_t>> m_vertex_to_tetrahedra;

    /**
     * @brief Factor applied to each tetra/vertex when we use only a part of the 1st BZ.
     * For example m_reduced_facotr = 48 when we use the irreducible wedge.
     *
     */
    double m_reduce_bz_factor = 1.0;

    /**
     * @brief Octree used to search for the tetrahedra that are overlapping with a given point.
     *
     */
    std::unique_ptr<Octree_mesh> m_search_tree;

    /**
     * @brief The indexes of the valence bands within the Vertex list of energies.
     * For example, if indices_valence_bands = [0, 1, 2] it means that
     * the m_band_energies[0], m_band_energies[1], m_band_energies[2] correspond to valence bands.
     *
     */
    std::vector<int> m_indices_valence_bands{};

    /**
     * @brief The indexes of the conduction bands within the Vertex list of energies.
     * For example, if indices_conduction_bands = [3, 4, 5] it means that
     * the values m_band_energies[3], m_band_energies[4], m_band_energies[5] correspond to conduction bands.
     *
     */
    std::vector<int> m_indices_conduction_bands{};

    /**
     * @brief The value m_min_band[i] is the minimum energy of the band with index i.
     *
     */
    std::vector<double> m_min_band{};

    /**
     * @brief The value m_max_band[i] is the maximum energy of the band with index i.
     *
     */
    std::vector<double> m_max_band{};

    /**
     * @brief Total volume of the BZ mesh in m^3.
     *
     */
    double m_total_volume = 0.0;

    /**
     * @brief Spin degeneracy factor (2 when spin-orbit coupling is not considered).
     *
     */
    double m_spin_degeneracy = 2.0;

    /**
     * @brief Possible G vectors to fold back k vectors within the first BZ.
     *
     */
    std::vector<vector3> m_Gshifts;

    // --- O(1) WS-BZ folding (internal state) ---
    /**
     * @brief Reciprocal primitive basis (columns) in SI [1/m] and its inverse.
     */
    Eigen::Matrix3d m_recip_B  = Eigen::Matrix3d::Identity();
    Eigen::Matrix3d m_recip_Bi = Eigen::Matrix3d::Identity();

    /**
     * @brief Scale from SI k (1/m) to the reduced frame used by plane tests.
     * Keep this consistent with is_inside_mesh_geometry().
     */
    double m_si2red = 1.0;

    /**
     * @brief Half-width in the reduced frame (e.g. 0.5 for [-0.5,0.5]).
     */
    double m_bz_halfwidth = 0.5;

 public:
    MeshBZ() = default;
    MeshBZ(const EmpiricalPseudopotential::Material& material) : m_material(material) {};
    MeshBZ(const MeshBZ&) = default;

    void export_k_points_to_file(const std::string& filename) const;
    void export_to_vtk(const std::string&        filename,
                       const MapStringToDoubles& point_scalars = {},
                       const MapStringToVectors& point_vectors = {},
                       const MapStringToDoubles& cell_scalars  = {},
                       const MapStringToVectors& cell_vectors  = {}) const;
    void export_energies_and_gradients_to_vtk(const std::string& filename) const;

    vector3 get_vertex_position(std::size_t idx_vtx) const { return m_list_vertices[idx_vtx].get_position(); }

    vector3 get_center() const { return m_center; }
    void    shift_bz_center(const vector3& shift);

    double        get_reduce_bz_factor() const { return m_reduce_bz_factor; }
    void          set_reduce_bz_factor(double factor) { m_reduce_bz_factor = factor; }
    inline double si_to_reduced_scale() const;

    bbox_mesh           compute_bounding_box() const;
    void                build_search_tree();
    std::vector<Tetra*> get_list_p_tetra() {
        std::vector<Tetra*> tetra_pointers;
        tetra_pointers.reserve(m_list_tetrahedra.size());
        std::transform(m_list_tetrahedra.begin(), m_list_tetrahedra.end(), std::back_inserter(tetra_pointers), [](Tetra& tetra) {
            return &tetra;
        });
        return tetra_pointers;
    }
    Tetra* find_tetra_at_location(const vector3& location) const;

    void read_mesh_geometry_from_msh_file(const std::string& filename, bool normalize_by_fourier_factor = true);
    void read_mesh_bands_from_msh_file(const std::string& filename, int nb_bands_to_load = -1);
    void read_mesh_bands_from_multi_band_files(const std::string& dir_bands, int nb_bands_to_load = 100);
    void add_new_band_energies_to_vertices(const std::vector<double>& energies_at_vertices);
    void keep_only_bands(const int nb_valence_bands, const int nb_conduction_bands);
    void compute_min_max_energies_at_tetras();
    void compute_energy_gradient_at_tetras();
    void auto_shift_conduction_band_energies();
    void auto_set_positive_valence_band_energies();
    void set_bands_in_right_order();
    void recompute_min_max_energies();
    void precompute_dos_tetra(double energy_step = 0.01, double energy_threshold = 100.0);

    void set_energy_gradient_at_vertices_by_averaging_tetras();

    std::size_t      get_number_vertices() const { return m_list_vertices.size(); }
    std::size_t      get_number_elements() const { return m_list_tetrahedra.size(); }
    double           get_volume() const { return m_total_volume; }
    std::vector<int> get_indices_valence_bands() const { return m_indices_valence_bands; }
    std::vector<int> get_indices_conduction_bands() const { return m_indices_conduction_bands; }
    int              get_nb_bands() const { return m_indices_valence_bands.size() + m_indices_conduction_bands.size(); }

    vector3 interpolate_energy_gradient_at_location(const vector3& location, const std::size_t& idx_band) const;

    void                     precompute_G_shifts();
    bool                     is_inside_mesh_geometry(const vector3& k) const;
    vector3                  retrieve_k_inside_mesh_geometry(const vector3& k) const;
    void                     init_reciprocal_basis(const Eigen::Vector3d& b1_SI,
                                                   const Eigen::Vector3d& b2_SI,
                                                   const Eigen::Vector3d& b3_SI,
                                                   double                 halfwidth_reduced,
                                                   double                 si_to_reduced);
    vector3                  fold_ws_bcc(const vector3& k_SI) const noexcept;
    bool                     inside_ws_bcc(const vector3& k_SI) const noexcept;
    bool                     is_irreducible_wedge(const vector3& k_SI) const noexcept;
    std::size_t              get_index_irreducible_wedge(const vector3& k_SI) const noexcept;
    std::vector<std::size_t> get_all_equivalent_indices_in_bz(const vector3& k_SI) const noexcept;

    vector3                         get_k_at_index(std::size_t index) const { return m_list_vertices[index].get_position(); }
    std::size_t                     get_nearest_k_index(const vector3& k) const;
    const std::vector<std::size_t>& get_tetrahedra_of_vertex(std::size_t vertex_index) const {
        return m_vertex_to_tetrahedra[vertex_index];
    }

    std::size_t               get_number_bands() const { return m_min_band.size(); }
    std::pair<double, double> get_min_max_energy_at_band(const int& band_index) const {
        return std::make_pair(m_min_band[band_index], m_max_band[band_index]);
    }

    const std::vector<Vertex>& get_list_vertices() const { return m_list_vertices; }
    const std::vector<Tetra>&  get_list_elements() const { return m_list_tetrahedra; }

    double      compute_mesh_volume() const;
    double      compute_iso_surface(double iso_energy, int band_index) const;
    double      compute_dos_at_energy_and_band(double iso_energy, int band_index, bool use_interp = false) const;
    std::size_t draw_random_tetrahedron_index_with_dos_probability(double        energy,
                                                                   std::size_t   idx_band,
                                                                   std::mt19937& random_generator) const;

    vector3 draw_random_k_point_at_energy(double energy, std::size_t idx_band, std::mt19937& random_generator) const;

    std::vector<std::vector<double>> compute_dos_band_at_band(int         band_index,
                                                              double      min_energy,
                                                              double      max_energy,
                                                              int         num_threads,
                                                              std::size_t nb_points,
                                                              bool        use_interp = false) const;

    std::vector<std::vector<double>> compute_dos_band_at_band_auto(int         band_index,
                                                                   std::size_t nb_points,
                                                                   int         num_threads,
                                                                   bool        use_interp = false) const;
};

}  // namespace bz_mesh/**
 * @file Octree_mesh.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-08-25
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <memory>
#include <vector>

#include "mesh_tetra.hpp"
#include "vector.hpp"
#include "bbox_mesh.hpp"

namespace bz_mesh {



class Octree_mesh {
 protected:
    /**
     * @brief Maximum number of elements in a leaf node.
     * If the number of elements in a node is greater than this value, the node is split into 8 children.
     */
    static constexpr int max_number_of_elements_per_node = 32;

    /**
     * @brief Minimum size of a node.
     * If the size of a node is smaller than this value, the node is not split anymore.
     */
    static constexpr double min_size_of_a_node = 1e8;

    /**
     * @brief Bounding box of the node.
     */
    bbox_mesh m_node_box;

    /**
     * @brief A leaf node is a node that has no children.
     *
     */
    bool m_is_leaf = false;

    /**
     * @brief List of pointers to elements overlapping in the node.
     */
    std::vector<Tetra *> m_list_tetras;

    /**
     * @brief List of children of the node.
     */
    std::vector<std::unique_ptr<Octree_mesh>> m_list_sub_nodes;

    std::vector<Tetra *> find_overlapping_tetras(const std::vector<Tetra *> &list_p_tetras, const bbox_mesh &bounding_box);
    bool                    is_inside(const vector3 &location) const { return m_node_box.is_inside(location); }

 public:
    Octree_mesh(){};
    Octree_mesh(const std::vector<Tetra *> &list_tetras, const bbox_mesh &bounding_box);

    Tetra *find_tetra_at_location(const vector3 &location) const;
};

}  // namespace bz_mesh
/**
 * @file mesh_vertex.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <algorithm>
#include <iostream>
#include <map>
#include <string>
#include <vector>

#include "vector.hpp"

namespace bz_mesh {

class Vertex {
 private:
    /**
     * @brief Index of the vertex within the mesh.
     *
     */
    std::size_t m_index;

    /**
     * @brief Position of the k-vector.
     *
     */
    vector3 m_position;

    /**
     * @brief The energy of the band with index b_idx at this vertex
     * is stored as m_band_energies[b_idx].
     * For example, m_band_energies[3] is the energy of the band 3 at the k-point with position m_position.
     *
     */
    std::vector<double> m_band_energies;

    /**
     * @brief The energy gradient at each band at this vertex.
     * The energy gradient is stored as a vector3 for each band.
     * For example, m_energy_gradient_at_bands[3] is the energy gradient of the band 3 at the k-point with position m_position.
     *
     */
    std::vector<vector3> m_energy_gradient_at_bands = {};

    /**
     * @brief Electron-phonon rates for each band.
     * The rates are stored as an array of 8 values:
     * [ALO, ALA, ATO, ATA, ELO, ELA, ETO, ETA] (ALO: absorption longitudinal optical, ALA: absorption longitudinal acoustic, ...)
     *
     */
    std::vector<std::array<double, 8>> m_electron_phonon_rates = {};

 public:
    /**
     * @brief Default constructor of a new Vertex object.
     *
     */
    Vertex() : m_index{0}, m_position{} {}

    /**
     * @brief Construct a new Vertex object with a given index.
     *
     * @param index
     */
    explicit Vertex(std::size_t index) : m_index(index), m_position{} {}

    /**
     * @brief Construct a new Vertex object with a given index and position.
     *
     * @param index
     * @param postion
     */
    Vertex(std::size_t index, const vector3& position) : m_index(index), m_position{position} {}

    /**
     * @brief Construct a new Vertex object with a given index and position (x, y, z).
     *
     * @param index
     * @param x
     * @param y
     * @param z
     */
    Vertex(std::size_t index, double x, double y, double z) : m_index(index), m_position{x, y, z} {}

    /**
     * @brief Get the index of the vertex.
     *
     * @return std::size_t
     */
    std::size_t get_index() const { return m_index; }

    /**
     * @brief Get the position of the vertex.
     *
     * @return vector3
     */
    const vector3& get_position() const { return m_position; }

    /**
     * @brief Set the position of the vertex.
     *
     * @param position
     */
    void set_position(const vector3& position) { m_position = position; }

    /**
     * @brief Shift the position of the vertex by a given vector.
     *
     * @param shift
     */
    void shift_position(const vector3& shift) { m_position += shift; }

    /**
     * @brief Add an energy at the end of the list of energy. (One energy per band).
     *
     * @param energy
     */
    void add_band_energy_value(double energy) { m_band_energies.push_back(energy); }

    void remove_band_energy(std::size_t band_index) {
        if (band_index >= m_band_energies.size()) {
            throw std::invalid_argument("The energy of band " + std::to_string(band_index) +
                                        " cannot be removed because it does not exists.");
        }
        m_band_energies.erase(m_band_energies.begin() + band_index);
    }

    /**
     * @brief Set the band energy at a given band index.
     *
     * @param index_band
     * @param new_energy
     */
    void set_band_energy(std::size_t index_band, double new_energy) {
        if (index_band >= m_band_energies.size()) {
            throw std::invalid_argument("The energy of band " + std::to_string(index_band) +
                                        " cannot be modify because it does not exist.");
        }
        m_band_energies[index_band] = new_energy;
    }

    /**
     * @brief Swap the energy of two bands.
     *
     * @param old_index
     * @param new_index
     */
    void swap_bands(std::size_t old_index, std::size_t new_index) {
        if (old_index >= m_band_energies.size() || new_index >= m_band_energies.size()) {
            throw std::invalid_argument("The energy of band " + std::to_string(old_index) + " or " + std::to_string(new_index) +
                                        " cannot be swapped because it does not exists.");
        }
        std::swap(m_band_energies[old_index], m_band_energies[new_index]);
    }

    /**
     * @brief Get the number of band energies stored in the Vertex object.
     *
     * @return std::size_t
     */
    std::size_t get_number_bands() const { return m_band_energies.size(); }

    /**
     * @brief Get the energy at band index.
     *
     * @param band_index
     * @return double
     */
    double get_energy_at_band(std::size_t band_index) const { return m_band_energies[band_index]; }

    /**
     * @brief Get the list of band energies.
     *
     * @return const std::vector<double>&
     */
    const std::vector<double>& get_band_energies() const { return m_band_energies; }

    const std::vector<vector3>& get_energy_gradient_at_bands() const { return m_energy_gradient_at_bands; }

    const vector3& get_energy_gradient_at_band(std::size_t band_index) const { return m_energy_gradient_at_bands[band_index]; }
    void           set_energy_gradient_at_bands(const std::vector<vector3>& gradients) { m_energy_gradient_at_bands = gradients; }
    void           set_energy_gradient_at_band(std::size_t band_index, const vector3& gradient) {
        if (band_index >= m_energy_gradient_at_bands.size()) {
            throw std::invalid_argument("The energy gradient of band " + std::to_string(band_index) +
                                        " cannot be modify because it does not exist.");
        }
        m_energy_gradient_at_bands[band_index] = gradient;
    }
    void resize_energy_gradient_at_bands(std::size_t new_size) { m_energy_gradient_at_bands.resize(new_size); }
    void push_back_energy_gradient_at_band(const vector3& gradient) { m_energy_gradient_at_bands.push_back(gradient); }

    /**
     * @brief Add the electron-phonon rates for a given band.
     *
     * @param rates
     */
    void add_electron_phonon_rates(const std::array<double, 8>& rates) { m_electron_phonon_rates.push_back(rates); }

    /**
     * @brief Get the electron-phonon rates for a given band.
     *
     * @param band_index
     * @return const std::array<double, 8>&
     */
    const std::array<double, 8>& get_electron_phonon_rates(std::size_t band_index) const { return m_electron_phonon_rates[band_index]; }

    const std::vector<std::array<double, 8>>& get_electron_phonon_rates_all_bands() const { return m_electron_phonon_rates; }
};

}  // namespace bz_mesh/**
 * @file vector.hpp
 * @author Rémi Helleboid (remi@helleboid.net)
 * @brief Vector class header.
 * @version 0.1
 * @date 2021-07-10
 *
 * @copyright Copyright (c) 2021
 *
 */

#pragma once

#include <algorithm>
#include <cmath>
#include <iostream>
#include <optional>
#include <vector>

namespace bz_mesh {

enum class permutaion_type { XY, XZ, YZ, XYZ, YZX, ZXY };

class alignas(32) vector3 {
 private:
    double m_x;
    double m_y;
    double m_z;

 public:
    vector3() : m_x(0.0), m_y(0.0), m_z(0.0) {}
    vector3(double x, double y) : m_x(x), m_y(y), m_z(0.0) {}
    vector3(double x, double y, double z) : m_x(x), m_y(y), m_z(z) {}
    vector3(const vector3 &)            = default;
    vector3 &operator=(const vector3 &) = default;
    vector3(vector3 &&)                 = default;
    vector3 &operator=(vector3 &&)      = default;
    ~vector3()                          = default;

    double x() const { return m_x; }
    double y() const { return m_y; }
    double z() const { return m_z; }

    void set_x(double x) { m_x = x; }
    void set_y(double y) { m_y = y; }
    void set_z(double z) { m_z = z; }
    void set_coordinates(double x, double y, double z) {
        m_x = x;
        m_y = y;
        m_z = z;
    }

    vector3 to_2d() const { return vector3{m_x, m_y, 0.0}; }

    double norm() const { return std::sqrt(m_x * m_x + m_y * m_y + m_z * m_z); }
    double norm_squared() const { return (m_x * m_x + m_y * m_y + m_z * m_z); }

    void re_normalize() {
        const double v_norm = norm();
        if (v_norm == 0.0) return;  // avoid division by zero
        m_x /= v_norm;
        m_y /= v_norm;
        m_z /= v_norm;
    }

    /**
     * @brief Apply a reflection on the vector.
     * (x_reflection, y_reflection, z_reflection) should typically be in {-1, 1}.
     */
    void apply_reflection(int x_reflection, int y_reflection, int z_reflection) {
        m_x = x_reflection * m_x;
        m_y = y_reflection * m_y;
        m_z = z_reflection * m_z;
    }

    /**
     * @brief Apply a permutation on the vector (6 possibilities).
     * XY, XZ, YZ are simple swaps; XYZ is identity; YZX and ZXY are 3-cycles.
     */
    void apply_permutation(permutaion_type permutation) {
        switch (permutation) {
            case permutaion_type::XY:
                std::swap(m_x, m_y);
                break;
            case permutaion_type::XZ:
                std::swap(m_x, m_z);
                break;
            case permutaion_type::YZ:
                std::swap(m_y, m_z);
                break;
            case permutaion_type::XYZ:
                // identity
                break;
            case permutaion_type::YZX: {
                // (x, y, z) -> (y, z, x)
                const double ox = m_x, oy = m_y, oz = m_z;
                m_x = oy;
                m_y = oz;
                m_z = ox;
                break;
            }
            case permutaion_type::ZXY: {
                // (x, y, z) -> (z, x, y)
                const double ox = m_x, oy = m_y, oz = m_z;
                m_x = oz;
                m_y = ox;
                m_z = oy;
                break;
            }
        }
    }

    double dot(const vector3 &rhs) const { return (m_x * rhs.m_x + m_y * rhs.m_y + m_z * rhs.m_z); }

    friend double dot(const vector3 &lhs, const vector3 &rhs) { return (lhs.m_x * rhs.m_x + lhs.m_y * rhs.m_y + lhs.m_z * rhs.m_z); }

    friend vector3 middle(const vector3 &lhs, const vector3 &rhs) {
        constexpr double one_half = 1.0 / 2.0;
        return vector3{one_half * (rhs.m_x + lhs.m_x), one_half * (rhs.m_y + lhs.m_y), one_half * (rhs.m_z + lhs.m_z)};
    }

    friend vector3 point_pair_to_vector(const vector3 &lhs, const vector3 &rhs) {
        return vector3{rhs.m_x - lhs.m_x, rhs.m_y - lhs.m_y, rhs.m_z - lhs.m_z};
    }

    friend double distance(const vector3 &lhs, const vector3 &rhs) { return point_pair_to_vector(lhs, rhs).norm(); }

    friend inline vector3 cross_product(const vector3 &lhs, const vector3 &rhs) {
        return vector3(lhs.m_y * rhs.m_z - lhs.m_z * rhs.m_y, lhs.m_z * rhs.m_x - lhs.m_x * rhs.m_z, lhs.m_x * rhs.m_y - lhs.m_y * rhs.m_x);
    }

    friend inline double scalar_triple_product(const vector3 &v1, const vector3 &v2, const vector3 &v3) {
        return v1.dot(cross_product(v2, v3));
    }

    friend inline double compute_cos_angle(const vector3 &V1, const vector3 &V2) {
        const double dot_product  = V1.dot(V2);
        const double norm_product = V1.norm() * V2.norm();
        return (norm_product < 1.0e-13) ? 1.0 : dot_product / norm_product;
    }

    friend inline bool is_point_between_two_others(const vector3 &A, const vector3 &B, const vector3 &P, double epsilon = 1e-9) {
        const double d_AB  = distance(A, B);
        const double d_sum = distance(A, P) + distance(P, B);
        return (d_AB <= d_sum + epsilon && d_AB >= d_sum - epsilon);
    }

    friend double double_scalar_product_2d(const vector3 &v1, const vector3 &v2) {
        // 2D determinant using (x,y) components
        return v1.m_x * v2.m_y - v1.m_y * v2.m_x;
    }

    /**
     * @brief Compute the intersection between two 2D segments [A B] and [C D] (using x,y only).
     * Returns std::nullopt if parallel/colinear or if intersection lies outside either segment.
     */
    friend std::optional<vector3> compute_line_line_intersection(const vector3 &A, const vector3 &B, const vector3 &C, const vector3 &D) {
        constexpr double eps = 1e-14;
        const vector3    r   = B - A;  // segment 1
        const vector3    s   = D - C;  // segment 2
        const vector3    qmp = C - A;  // from A to C

        const double rxs = double_scalar_product_2d(r, s);
        if (std::fabs(rxs) < eps) {
            // Parallel (or colinear) in 2D
            return {};
        }

        // Barycentric parameters:
        // A + t*r  intersects  C + u*s
        const double t = double_scalar_product_2d(qmp, s) / rxs;
        const double u = double_scalar_product_2d(qmp, r) / rxs;

        if (t >= -eps && t <= 1.0 + eps && u >= -eps && u <= 1.0 + eps) {
            const vector3 P = A + t * r;
            return {P};
        }
        return {};
    }

    vector3 &operator+=(const vector3 &lhs) {
        m_x += lhs.m_x;
        m_y += lhs.m_y;
        m_z += lhs.m_z;
        return *this;
    }

    vector3 &operator-=(const vector3 &lhs) {
        m_x -= lhs.m_x;
        m_y -= lhs.m_y;
        m_z -= lhs.m_z;
        return *this;
    }

    vector3 &operator*=(const double lambda) {
        m_x *= lambda;
        m_y *= lambda;
        m_z *= lambda;
        return *this;
    }

    vector3 &operator/=(const double lambda) {
        m_x /= lambda;
        m_y /= lambda;
        m_z /= lambda;
        return *this;
    }

    friend vector3 operator+(const vector3 &lhs, const vector3 &rhs) {
        vector3 v = lhs;
        v += rhs;
        return v;
    }

    friend vector3 operator-(const vector3 &lhs, const vector3 &rhs) {
        vector3 v = lhs;
        v -= rhs;
        return v;
    }

    friend vector3 operator*(const vector3 &lhs, const double lambda) {
        vector3 v = lhs;
        v *= lambda;
        return v;
    }

    friend vector3 operator*(const double lambda, const vector3 &lhs) {
        vector3 v = lhs;
        v *= lambda;
        return v;
    }

    friend vector3 operator/(const vector3 &lhs, const double lambda) {
        vector3 v = lhs;
        v /= lambda;
        return v;
    }

    friend std::ostream &operator<<(std::ostream &os, const vector3 &vect) {
        os << vect.m_x << ',' << vect.m_y << ',' << vect.m_z;
        return os;
    }
};

static_assert(std::is_trivially_copyable_v<vector3>, "vector3 must be trivially copyable");
static_assert(std::is_standard_layout_v<vector3>, "vector3 must be standard-layout");

}  // namespace bz_mesh/**
 * @file bz_states.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "bz_states.hpp"

#include <Eigen/Dense>
#include <filesystem>
#include <fstream>

#include "Hamiltonian.h"
#include "bz_mesh.hpp"
#include "omp.h"

namespace bz_mesh {

void BZ_States::compute_eigenstates(int nb_threads) {
    double     normalization_factor = 2.0 * M_PI / m_material.get_lattice_constant_meter();
    const bool m_nonlocal_epm       = false;
    const bool keep_eigenvectors    = true;
    m_eigenvalues_k.resize(m_list_vertices.size());
    m_eigenvectors_k.resize(m_list_vertices.size());
    std::vector<EmpiricalPseudopotential::Hamiltonian> hamiltonian_per_thread;
    for (int i = 0; i < nb_threads; i++) {
        hamiltonian_per_thread.push_back(EmpiricalPseudopotential::Hamiltonian(m_material, m_basisVectors));
    }
#pragma omp parallel for schedule(dynamic) num_threads(nb_threads)
    for (std::size_t idx_k = 0; idx_k < m_list_vertices.size(); ++idx_k) {
        if (omp_get_thread_num() == 0) {
            std::cout << "\rComputing eigenstates for k = " << idx_k << "/" << m_list_vertices.size() << std::flush;
        }
        auto k_point    = Vector3D<double>(m_list_vertices[idx_k].get_position().x(),
                                        m_list_vertices[idx_k].get_position().y(),
                                        m_list_vertices[idx_k].get_position().z());
        k_point         = k_point * 1.0 / normalization_factor;
        auto idx_thread = omp_get_thread_num();
        hamiltonian_per_thread[idx_thread].SetMatrix(k_point, m_nonlocal_epm);
        hamiltonian_per_thread[idx_thread].Diagonalize(keep_eigenvectors);
        m_eigenvalues_k[idx_k]  = hamiltonian_per_thread[idx_thread].eigenvalues();
        m_eigenvectors_k[idx_k] = hamiltonian_per_thread[idx_thread].get_eigenvectors();
        auto nb_rows            = m_eigenvectors_k[idx_k].rows();
        m_eigenvectors_k[idx_k].conservativeResize(nb_rows, m_nb_bands);
    }
    std::cout << std::endl;
}

void BZ_States::compute_shifted_eigenstates(const Vector3D<double>& q_shift, int nb_threads) {
    m_q_shift                       = q_shift;
    double     normalization_factor = 2.0 * M_PI / m_material.get_lattice_constant_meter();
    m_q_shift                      = m_q_shift * normalization_factor;
    const bool m_nonlocal_epm       = false;
    const bool keep_eigenvectors    = true;
    m_eigenvalues_k_plus_q.resize(m_list_vertices.size());
    m_eigenvectors_k_plus_q.resize(m_list_vertices.size());
    std::vector<EmpiricalPseudopotential::Hamiltonian> hamiltonian_per_thread;
    for (int i = 0; i < nb_threads; i++) {
        hamiltonian_per_thread.push_back(EmpiricalPseudopotential::Hamiltonian(m_material, m_basisVectors));
    }
#pragma omp parallel for schedule(dynamic) num_threads(nb_threads)
    for (std::size_t idx_k = 0; idx_k < m_list_vertices.size(); ++idx_k) {
        if (omp_get_thread_num() == 0) {
            std::cout << "\rComputing eigenstates for k = " << idx_k << "/" << m_list_vertices.size() << std::flush;
        }
        auto k_point = Vector3D<double>(m_list_vertices[idx_k].get_position().x(),
                                        m_list_vertices[idx_k].get_position().y(),
                                        m_list_vertices[idx_k].get_position().z());
        k_point      = k_point * 1.0 / normalization_factor;
        k_point += q_shift;
        auto idx_thread = omp_get_thread_num();
        hamiltonian_per_thread[idx_thread].SetMatrix(k_point, m_nonlocal_epm);
        hamiltonian_per_thread[idx_thread].Diagonalize(keep_eigenvectors);
        m_eigenvalues_k_plus_q[idx_k]  = hamiltonian_per_thread[idx_thread].eigenvalues();
        m_eigenvectors_k_plus_q[idx_k] = hamiltonian_per_thread[idx_thread].get_eigenvectors();
        auto nb_rows                   = m_eigenvectors_k[idx_k].rows();
        m_eigenvectors_k_plus_q[idx_k].conservativeResize(nb_rows, m_nb_bands);
    }
    std::cout << std::endl;
}

/**
 * @brief Compute the dielectric function for a given list of energies and a given smearing.
 * The integration is performed by summing the contribution of each tetrahedron to the dielectric function.
 *
 * @param energies
 * @param eta_smearing
 * @param nb_threads
 */
void BZ_States::compute_dielectric_function(const std::vector<double>& list_energies, double eta_smearing, int nb_threads) {


    m_list_energies                         = list_energies;
    const int   index_first_conduction_band = 4;
    std::size_t nb_tetra                    = m_list_tetrahedra.size();
    m_dielectric_function_real.resize(list_energies.size());
    constexpr double one_fourth = 1.0 / 4.0;

    std::vector<double> dielectric_function_real_at_energies(list_energies.size(), 0.0);
    double              total_volume = 0.0;
#pragma omp parallel for schedule(dynamic) num_threads(nb_threads) reduction(+:total_volume)
    for (std::size_t idx_tetra = 0; idx_tetra < nb_tetra; ++idx_tetra) {
        if (omp_get_thread_num() == 0) {
            std::cout << "\rComputing dielectric function for tetrahedron " << idx_tetra << "/" << nb_tetra << std::flush;
        }
        std::array<std::size_t, 4>    list_idx_vertices = m_list_tetrahedra[idx_tetra].get_list_indices_vertices();
        const std::array<Vertex*, 4>& list_vertices     = m_list_tetrahedra[idx_tetra].get_list_vertices();
        double                        volume_tetra      = std::fabs(m_list_tetrahedra[idx_tetra].compute_signed_volume());
        total_volume += volume_tetra;
        // std::cout << "Volume tetra = " << volume_tetra << std::endl;
        std::vector<double> sum_dielectric_function_real_tetra_at_energies(list_energies.size(), 0.0);
        // Loop over the vertices of the tetrahedron
        for (std::size_t idx_vertex = 0; idx_vertex < 4; ++idx_vertex) {
            std::size_t index_k = list_idx_vertices[idx_vertex];
            for (int idx_conduction_band = index_first_conduction_band; idx_conduction_band < m_nb_bands; ++idx_conduction_band) {
                for (int idx_valence_band = 0; idx_valence_band < index_first_conduction_band; ++idx_valence_band) {
                    double overlap_integral = pow(std::fabs(m_eigenvectors_k_plus_q[index_k]
                                                                .col(idx_conduction_band)
                                                                .adjoint()
                                                                .dot(m_eigenvectors_k[index_k].col(idx_valence_band))),
                                                  2);
                    double delta_energy = m_eigenvalues_k_plus_q[index_k][idx_conduction_band] - m_eigenvalues_k[index_k][idx_valence_band];
                    for (std::size_t index_energy = 0; index_energy < list_energies.size(); ++index_energy) {
                        double energy = list_energies[index_energy];
                        double factor_1 =
                            (delta_energy - energy) / ((delta_energy - energy) * (delta_energy - energy) + eta_smearing * eta_smearing);
                        double factor_2 =
                            (delta_energy + energy) / ((delta_energy + energy) * (delta_energy + energy) + eta_smearing * eta_smearing);
                        double total_factor = factor_1 + factor_2;
                        sum_dielectric_function_real_tetra_at_energies[index_energy] += overlap_integral * total_factor;
                    }
                }
            }
        }
        for (std::size_t index_energy = 0; index_energy < list_energies.size(); ++index_energy) {
            sum_dielectric_function_real_tetra_at_energies[index_energy] *= volume_tetra * one_fourth;
            dielectric_function_real_at_energies[index_energy] += sum_dielectric_function_real_tetra_at_energies[index_energy];
        }
    }
    std::cout << "\n";
    std::cout << "Total volume (k-space) integrated: " << total_volume << std::endl;

    double a          = m_material.get_lattice_constant_meter();  // (m), for Si cubic cell
    double Omega_cell = a * a * a;                                // if your grid is on the simple cubic cell
    double V_BZ       = std::pow(2.0 * M_PI, 3) / Omega_cell;
    std::cout << "Expected BZ volume: " << V_BZ << "\n";
    std::cout << "Integrated volume: " << total_volume << "\n";
    std::cout << "Ratio (integrated / expected): " << (total_volume / V_BZ) << "\n";

    double q_squared = m_q_shift.Length() * m_q_shift.Length();

    // // prefactor in SI, with J→eV conversion
    // double prefactor = (EmpiricalPseudopotential::Constants::q_e * EmpiricalPseudopotential::Constants::q_e) /
    //                    (EmpiricalPseudopotential::Constants::eps_0 * q_squared) / EmpiricalPseudopotential::Constants::q_e *
    //                    (2.0 / std::pow(2.0 * M_PI, 3));

    double coulomb_prefactor_eV = (EmpiricalPseudopotential::Constants::q_e * EmpiricalPseudopotential::Constants::q_e) /
                                   (EmpiricalPseudopotential::Constants::eps_0 * q_squared)  // J·m
                                  / EmpiricalPseudopotential::Constants::q_e;                                                      // → eV·m
    double prefactor = coulomb_prefactor_eV * (2.0 / std::pow(2.0 * M_PI, 3));

    for (std::size_t index_energy = 0; index_energy < list_energies.size(); ++index_energy) {
        m_dielectric_function_real[index_energy] = 1.0 + prefactor * dielectric_function_real_at_energies[index_energy];
    }

    std::cout << "EPS[0] = " << m_dielectric_function_real[0] << std::endl;
}

// Export the dielectric function to a file in the format (energy, dielectric function) (csv format).
void BZ_States::export_dielectric_function(const std::string& prefix) const {
    std::ofstream dielectric_function_file(prefix + "_dielectric_function.csv");
    dielectric_function_file << "Energy (eV),Dielectric function" << std::endl;
    for (std::size_t index_energy = 0; index_energy < m_dielectric_function_real.size(); ++index_energy) {
        dielectric_function_file << m_list_energies[index_energy] << "," << m_dielectric_function_real[index_energy] << std::endl;
    }
    dielectric_function_file.close();
}

void BZ_States::export_full_eigenstates() const {
    std::filesystem::remove_all("eigenstates");
    std::filesystem::create_directory("eigenstates");
    std::filesystem::create_directory("eigenstates/eigenvectors");
    std::filesystem::create_directory("eigenstates/eigenvalues");
    for (std::size_t idx_k = 0; idx_k < m_list_vertices.size(); ++idx_k) {
        std::ofstream eigenvalues_file("eigenstates/eigenvalues/eigenvalues_" + std::to_string(idx_k) + ".txt");
        eigenvalues_file << m_eigenvalues_k[idx_k].transpose() << std::endl;
        eigenvalues_file.close();
        std::ofstream shiftedeigenvalues_file("eigenstates/eigenvalues/shiftedeigenvalues_" + std::to_string(idx_k) + ".txt");
        shiftedeigenvalues_file << m_eigenvalues_k_plus_q[idx_k].transpose() << std::endl;
        shiftedeigenvalues_file.close();

        std::ofstream eigenvectors_file("eigenstates/eigenvectors/eigenvectors_" + std::to_string(idx_k) + ".txt");
        eigenvectors_file << m_eigenvectors_k[idx_k] << std::endl;
        eigenvectors_file.close();
        std::ofstream shiftedeigenvectors_file("eigenstates/eigenvectors/shiftedeigenvectors_" + std::to_string(idx_k) + ".txt");
        shiftedeigenvectors_file << m_eigenvectors_k_plus_q[idx_k] << std::endl;
        shiftedeigenvectors_file.close();
    }
}

// void BZ_States::populate_vtx_dielectric_function(const std::vector<double>& energies, double eta_smearing);

}  // namespace bz_mesh/**
 * @file dielectric_mesh.cpp
 * @author your name (you@domain.com)
 * @brief
 * @version 0.1
 * @date 2024-05-17
 *
 * @copyright Copyright (c) 2024
 *
 */

#include "dielectric_mesh.hpp"

#include <regex>

#include "gmsh.h"

namespace bz_mesh {

void DielectricMesh::read_dielectric_file(const std::string& filename) {
    std::cout << "Opening file " << filename << std::endl;
    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::open(filename);
    std::vector<int> viewTags;
    gmsh::view::getTags(viewTags);
    int nb_energies = viewTags.size();
    if (nb_energies % 2 != 0) {
        // The number of viewTags should be even because we have the real and imaginary part of the dielectric function for each energy.
        std::cerr << "The number of energies is not even. The file is corrupted." << std::endl;
        return;
    }
    nb_energies /= 2;
    int                              count_energy = 0;
    std::vector<double>              energies;
    std::vector<std::vector<double>> real_dielectric;
    std::vector<std::vector<double>> imag_dielectric;
    for (auto&& tag : viewTags) {
        const int   index_view  = gmsh::view::getIndex(tag);
        std::string name_object = "View[" + std::to_string(index_view) + "].Name";
        std::string name_view;
        try {
            gmsh::option::getString(name_object, name_view);
        } catch (const std::exception& e) {
            std::cerr << e.what() << '\n';
        }

        std::string energy_str = name_view.substr(name_view.find_last_of("_") + 1, name_view.size());
        double      energy     = std::stod(energy_str);
        if (count_energy % 2 == 0) {
            energies.push_back(energy);
        }

        // If the name of the view starts with "eps_r" we store the data in the real part of the dielectric function.
        // If the name of the view starts with "eps_i" we store the data in the imaginary part of the dielectric function.
        std::regex re_real("eps_r");
        std::regex re_imag("eps_i");

        std::smatch              match_real;
        std::smatch              match_imag;
        std::string              type;
        std::vector<std::size_t> tags;
        double                   time;
        int                      numComp;
        std::vector<double>      data_view;
        gmsh::view::getHomogeneousModelData(tag, 0, type, tags, data_view, time, numComp);
        // std::cout << "View " << name_view << " has " << data_view.size() << " values." << std::endl;
        if (std::regex_search(name_view, match_real, re_real)) {
            real_dielectric.push_back(data_view);
        } else if (std::regex_search(name_view, match_imag, re_imag)) {
            imag_dielectric.push_back(data_view);
        }
        count_energy++;
    }
    std::cout << "Number of energies: " << nb_energies << std::endl;
    std::cout << "Number of energies in the real part: " << energies.size() << std::endl;
    std::cout << "Number of dielectric functions in the real part: " << real_dielectric.size() << std::endl;
    std::cout << "Number of dielectric functions in the imaginary part: " << imag_dielectric.size() << std::endl;
    if (energies.size() != nb_energies) {
        std::cerr << "The number of energies is not the same in the real and imaginary part of the dielectric function." << std::endl;
        return;
    }
    gmsh::finalize();
    m_energies = energies;
    m_dielectric_function.resize(m_list_vertices.size());
    for (std::size_t idx_node = 0; idx_node < m_list_vertices.size(); ++idx_node) {
        m_dielectric_function[idx_node].resize(energies.size());
        for (std::size_t idx_energy = 0; idx_energy < energies.size(); ++idx_energy) {
            m_dielectric_function[idx_node][idx_energy] =
                std::complex<double>(real_dielectric[idx_energy][idx_node], imag_dielectric[idx_energy][idx_node]);
        }
    }
    std::cout << "Size of the dielectric function: " << m_dielectric_function.size() << " x " << m_dielectric_function[0].size()
              << std::endl;
    std::cout << "Dielectric function read." << std::endl;
}

std::pair<std::size_t, double> DielectricMesh::find_closest_energy(double energy) const {
    if (m_energies.empty()) {
        return std::make_pair(0, 0.0);
    }
    if (energy < m_energies.front()) {
        return std::make_pair(0, 0.0);
    }
    if (energy > m_energies.back()) {
        return std::make_pair(m_energies.size() - 1, 0.0);
    }
    auto it = std::lower_bound(m_energies.begin(), m_energies.end(), energy);
    if (it == m_energies.begin()) {
        return std::make_pair(0, 0.0);
    }
    if (it == m_energies.end()) {
        return std::make_pair(m_energies.size() - 1, 0.0);
    }
    std::size_t idx = std::distance(m_energies.begin(), it);
    double      t   = (energy - m_energies[idx - 1]) / (m_energies[idx] - m_energies[idx - 1]);
    return std::make_pair(idx - 1, t);
}

complex_d DielectricMesh::interpolate_dielectric_function(const vector3& k, double energy) const {
    auto   k_positive{vector3{std::abs(k.x()), std::abs(k.y()), std::abs(k.z())}};
    Tetra* p_tetra = find_tetra_at_location(k_positive);
    if (p_tetra == nullptr) {
        std::cerr << "Tetra not found at location " << k_positive << std::endl;
        return 0.0;
    }
    std::array<double, 4> barycentric_coordinates = p_tetra->compute_barycentric_coordinates(k_positive);

    std::array<std::size_t, 4>          list_indices_vertices = p_tetra->get_list_indices_vertices();
    std::pair<std::size_t, double>      closest_energy        = find_closest_energy(energy);
    std::size_t                         idx_energy            = closest_energy.first;
    double                              t                     = closest_energy.second;
    std::vector<std::complex<double>> dielectric_function_low(4);
    std::vector<std::complex<double>> dielectric_function_high(4);
    for (std::size_t idx_vertex = 0; idx_vertex < 4; ++idx_vertex) {
        std::cout << "Vertex: " << list_indices_vertices[idx_vertex] << std::endl;
        dielectric_function_low[idx_vertex]  = m_dielectric_function[idx_energy][list_indices_vertices[idx_vertex]];
        dielectric_function_high[idx_vertex] = m_dielectric_function[idx_energy + 1][list_indices_vertices[idx_vertex]];
    }
    std::complex<double> dielectric_function_interpolated_low =
        p_tetra->interpolate_at_position(barycentric_coordinates, dielectric_function_low);
    std::complex<double> dielectric_function_interpolated_high =
        p_tetra->interpolate_at_position(barycentric_coordinates, dielectric_function_high);

    std::cout << "Idx energy: " << idx_energy << std::endl;
    std::cout << "Energy: " << energy << std::endl;
    std::cout << "Closest energy: " << m_energies[idx_energy] << std::endl;
    std::cout << "Interpolated energy: " << (1 - t) * m_energies[idx_energy] + t * m_energies[idx_energy + 1] << std::endl;
    return (1 - t) * dielectric_function_interpolated_low + t * dielectric_function_interpolated_high;
}

}  // namespace bz_mesh/**
 * @file mesh_tetra.hpp
 * @author Rémi Helleboid (remi.helleboid@st.com)
 * @brief
 * @version 0.1
 * @date 2022-07-14
 *
 * @copyright Copyright (c) 2022
 *
 */
#pragma once

#include <array>
#include <complex>
#include <functional>
#include <iostream>
#include <numeric>
#include <string>
#include <vector>

#include "bbox_mesh.hpp"
#include "mesh_vertex.hpp"

namespace bz_mesh {

using array4d = std::array<double, 4>;

struct UniformDos {
    bool               valid{false};
    double             E0{0.0};
    double             Emax{0.0};
    double             inv_dx{0.0};  // 1 / dx
    uint32_t           N{0};         // number of knots = nb_steps + 1
    std::vector<float> D;            // try float to halve bandwidth; use double if needed

    inline double sample_or_zero(double E) const noexcept {
        if (!valid || E < E0 || E > Emax) {
            return 0.0;
        }
        const double t   = (E - E0) * inv_dx;
        int          idx = static_cast<int>(t);  // floor
        // clamp to [0, N-2]
        const int last = static_cast<int>(N) - 2;
        if (idx < 0) idx = 0;
        if (idx > last) idx = last;

        const float  d0   = D[static_cast<size_t>(idx)];
        const float  d1   = D[static_cast<size_t>(idx + 1)];
        const double frac = t - static_cast<double>(idx);
        // one FMA; cast once to double to keep precision in math path
        return std::fma(frac, static_cast<double>(d1 - d0), static_cast<double>(d0));
    }
};

class Tetra {
 private:
    /**
     * @brief Element index.
     *
     */
    std::size_t m_index;

    /**
     * @brief The 4 vertices of the tetrahedra are stored as an array of pointers on Vertices object.
     *
     */
    std::array<Vertex*, 4> m_list_vertices{nullptr, nullptr, nullptr, nullptr};

    /**
     * @brief List of the edges vectors of the tetrahedra.
     * Stored as follows: [v01, v02, v03, v12, v13, v23]
     * where for example v13 = m_list_vertices[1] - m_list_vertices[3].
     *
     */
    std::array<vector3, 6> m_list_edges{};

    /**
     * @brief Bounding box of the tetrahedra.
     *
     */
    bbox_mesh m_bbox;

    /**
     * @brief Barycenter of the tetrahedra.
     *
     */
    vector3 m_barycenter;

    /**
     * @brief Signed volume of the tetrahedra.
     * The sign depends on the "orientation" of the tetrahedra.
     *
     */
    double m_signed_volume = 0.0;

    /**
     * @brief Number of conduction bands.
     *
     */
    std::size_t m_nb_bands = 0;

    /**
     * @brief The value min_energy_per_band[k] is the minimum energy of the k-th band on the tetrahedra.
     * It is pre-computed and stored for optimization purposes.
     *
     */
    std::vector<double> m_min_energy_per_band;

    /**
     * @brief The value max_energy_per_band[k] is the maximum energy of the k-th band on the tetrahedra.
     * It is pre-computed and stored for optimization purposes.
     *
     */
    std::vector<double> m_max_energy_per_band;

    /**
     * @brief G>radient of the energy at the vertices of the tetrahedra for each band.
     * It is pre-computed and stored for optimization purposes.
     *
     */
    std::vector<vector3> m_gradient_energy_per_band;

    /**
     * @brief For each band, store the indices of the vertices sorted by increasing energy.
     * For example, if for band k, vertex 2 has the lowest energy, then vertex 0, then vertex 3, then vertex 1,
     * then m_sorted_slots_per_band[k] = {2, 0, 3, 1}.
     *
     */
    std::vector<std::array<int, 4>> m_sorted_slots_per_band;

    /**
     * @brief Precomputed DOS on a uniform energy grid for each band.
     *
     */
    std::vector<UniformDos> m_dos_per_band;

 public:
    /**
     * @brief There is not default constructor for Tetra class.
     *
     */
    Tetra() = delete;

    Tetra(std::size_t index, const std::array<Vertex*, 4>& list_vertices);

    const bbox_mesh& get_bounding_box() const;
    bbox_mesh        compute_bounding_box() const;
    void             compute_min_max_energies_at_bands();
    vector3          get_barycenter() const { return m_barycenter; }

    std::size_t                   get_index() const { return m_index; }
    const std::array<Vertex*, 4>& get_list_vertices() const { return m_list_vertices; }
    std::array<std::size_t, 4>    get_list_indices_vertices() const {
        return {m_list_vertices[0]->get_index(),
                   m_list_vertices[1]->get_index(),
                   m_list_vertices[2]->get_index(),
                   m_list_vertices[3]->get_index()};
    }
    std::array<vector3, 6> get_list_edges() const { return m_list_edges; }
    std::size_t            get_nb_bands() const { return m_nb_bands; }

    std::array<double, 4> get_band_energies_at_vertices(std::size_t index_band) const;

    double  compute_signed_volume() const;
    double  get_signed_volume() const { return m_signed_volume; }
    vector3 compute_edge(std::size_t index_vtx_1, std::size_t index_vtx_2) const;
    void    compute_gradient_energy_at_bands();
    vector3 compute_gradient_at_tetra(const array4d& values_at_vertices) const;

    vector3               compute_barycenter() const;
    bool                  is_location_inside(const vector3& location) const;
    std::array<double, 4> compute_barycentric_coordinates(const vector3& location) const;
    vector3               compute_euclidean_coordinates(const std::array<double, 4>& barycentric_coordinates) const;
    vector3               compute_euclidean_coordinates_with_indices(const std::array<double, 4>& barycentric_coordinates,
                                                                     const std::array<int, 4>&    indices_vertex) const;

    void                      pre_compute_sorted_slots_per_band();
    const std::array<int, 4>& get_index_vertices_with_sorted_energy_at_band(std::size_t index_band) const {
        return m_sorted_slots_per_band[index_band];
    }

    void   precompute_dos_on_energy_grid_per_band(double energy_step, double energy_threshold);
    double interpolate_dos_at_energy_per_band(double energy, std::size_t band_index) const noexcept;

    vector3 get_gradient_energy_at_band(std::size_t band_index) const { return m_gradient_energy_per_band[band_index]; }

    bool                 is_energy_inside_band(double energy, std::size_t index_band) const;
    bool                 does_intersect_band_energy_range(double e_min, double e_max, std::size_t index_band) const;
    std::vector<vector3> compute_band_iso_energy_surface(double iso_energy, std::size_t band_index) const;
    double               compute_tetra_iso_surface_energy_band(double energy, std::size_t band_index) const;
    double               compute_tetra_iso_surface_energy_band2(double energy, std::size_t band_index) const;
    double               compute_tetra_dos_energy_band(double energy, std::size_t band_index) const;
    vector3              draw_random_uniform_point_at_energy(double iso_energy, std::size_t band_index, std::mt19937& rng) const;

    std::array<double, 8> get_tetra_electron_phonon_rates(int band_index) const;

    double interpolate_scalar_at_position(const std::array<double, 4>& barycentric_coordinates,
                                          const std::vector<double>&   scalar_field) const;
    double interpolate_energy_at_band(const vector3& location, std::size_t band_index) const;

    vector3 interpolate_vector_at_position(const std::array<double, 4>& barycentric_coordinates,
                                           const std::vector<vector3>&  vector_field) const;
    template <typename T>
    T interpolate_at_position(const std::array<double, 4>& barycentric_coordinates, const std::vector<T>& field) const {
        T interpolated_value = T::Zero();
        for (std::size_t idx_vtx = 0; idx_vtx < 4; ++idx_vtx) {
            interpolated_value += barycentric_coordinates[idx_vtx] * field[idx_vtx];
        }
        return interpolated_value;
    }
    std::complex<double> interpolate_at_position(const std::array<double, 4>&             barycentric_coordinates,
                                                 const std::vector<std::complex<double>>& field) const {
        std::complex<double> interpolated_value = 0.0;
        for (std::size_t idx_vtx = 0; idx_vtx < 4; ++idx_vtx) {
            interpolated_value += barycentric_coordinates[idx_vtx] * field[idx_vtx];
        }

        return interpolated_value;
    }
};

}  // namespace bz_mesh/**
 * @file bz_states.cpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#include "impact_ionization.hpp"

#include <Eigen/Dense>
#include <filesystem>
#include <fstream>

#include "BandStructure.h"
#include "Constants.hpp"
#include "Hamiltonian.h"
#include "Material.h"
#include "Options.h"
#include "bz_mesh.hpp"
#include "bz_states.hpp"
#include "omp.h"

namespace bz_mesh {

ImpactIonization::ImpactIonization(const EmpiricalPseudopotential::Material& material, const std::string& initial_mesh_path) {
    std::filesystem::path path(initial_mesh_path);
    if (!std::filesystem::exists(path)) {
        std::cerr << "Error: file " << initial_mesh_path << " does not exist." << std::endl;
        exit(1);
    }
    std::ifstream file(initial_mesh_path);
    if (!file.is_open()) {
        std::cerr << "Error: could not open file " << initial_mesh_path << std::endl;
        exit(1);
    }
    m_material          = material;
    m_initial_mesh_path = initial_mesh_path;
}

void ImpactIonization::read_dielectric_file(const std::string& filename) {
    bool normalize_by_fourier_factor = false;
    m_dielectric_mesh.read_mesh_geometry_from_msh_file(filename, normalize_by_fourier_factor);
    m_dielectric_mesh.build_search_tree();
    m_dielectric_mesh.read_dielectric_file(filename);
}

void ImpactIonization::interp_test_dielectric_function(std::string filename) {
    double        eps = 1e-6;
    double        x0  = eps;
    double        y0  = eps;
    double        z0  = eps;
    double        x1  = 3.0;
    double        y1  = 3.0;
    double        z1  = 3.0;
    int           nx  = 20;
    int           ny  = 20;
    int           nz  = 20;
    double        dx  = (x1 - x0) / nx;
    double        dy  = (y1 - y0) / ny;
    double        dz  = (z1 - z0) / nz;
    std::ofstream file(filename);
    for (int i = 0; i < nx; ++i) {
        for (int j = 0; j < ny; ++j) {
            for (int k = 0; k < nz; ++k) {
                double    x = x0 + i * dx;
                double    y = y0 + j * dy;
                double    z = z0 + k * dz;
                vector3   position(x, y, z);
                complex_d epsilon = m_dielectric_mesh.interpolate_dielectric_function(position, 0.0102);
                file << x << ", " << y << ", " << z << ", " << epsilon.real() << ", " << epsilon.imag() << std::endl;
                std::cout << "Position: " << position << " epsilon: " << epsilon << std::endl;
            }
        }
    }
    file.close();
}

void ImpactIonization::compute_eigenstates(int nb_threads) {
    int                nb_bands_to_use = 16;
    bz_mesh::BZ_States my_bz_mesh(m_material);
    my_bz_mesh.set_nb_bands(nb_bands_to_use);
    EmpiricalPseudopotential::BandStructure band_structure{};
    int                                     nb_nearest_neighbors = 10;
    bool                                    nonlocal_epm         = false;
    bool                                    enable_soc           = false;
    band_structure.Initialize(m_material, nb_bands_to_use, {}, nb_nearest_neighbors, nonlocal_epm, enable_soc);
    auto basis = band_structure.get_basis_vectors();
    my_bz_mesh.set_basis_vectors(basis);

    my_bz_mesh.read_mesh_geometry_from_msh_file(m_initial_mesh_path);

    const vector3 b1 = {-1.0, 1.0, 1.0};
    const vector3 b2 = {1.0, -1.0, 1.0};
    const vector3 b3 = {1.0, 1.0, -1.0};

    // std::cout << "k: " << k << std::endl;
    double factor = 2.0 * M_PI / m_material.get_lattice_constant_meter();
    // test k + G
    std::vector<int> list_n_k = {0, 1, -1, 2, -2, 3, -3, 4, -4};
    // std::vector<int> list_n_k = {0, 1, -1, 2, -2};

    std::cout << "Max radius G0 BZ: " << m_max_radius_G0_BZ << std::endl;
    for (auto&& n_k_x : list_n_k) {
        for (auto&& n_k_y : list_n_k) {
            for (auto&& n_k_z : list_n_k) {
                vector3 G_BZ = n_k_x * b1 + n_k_y * b2 + n_k_z * b3;
                if (G_BZ.norm() > m_max_radius_G0_BZ) {
                    continue;
                }
                std::cout << "G_BZ: " << G_BZ << " --> " << G_BZ.norm() << std::endl;
                G_BZ = G_BZ * factor;

                auto ptr_BZ_states = std::make_unique<BZ_States>(m_material);
                ptr_BZ_states->set_nb_bands(nb_bands_to_use);
                ptr_BZ_states->set_basis_vectors(basis);
                ptr_BZ_states->read_mesh_geometry_from_msh_file(m_initial_mesh_path);
                ptr_BZ_states->shift_bz_center(G_BZ);
                ptr_BZ_states->compute_eigenstates(nb_threads);
                m_list_BZ_states.push_back(std::move(ptr_BZ_states));
            }
        }
    }
    std::cout << "Number of BZ states: " << m_list_BZ_states.size() << std::endl;
}

double ImpactIonization::compute_impact_ionization_rate(int idx_n1, std::size_t idx_k1) {
    constexpr int                     nb_valence_bands    = 3;
    constexpr int                     nb_conduction_bands = 4;
    constexpr int                     min_conduction_band = 4;
    const std::size_t                 nb_vtx              = m_list_BZ_states[0]->get_list_vertices().size();
    const std::vector<Vector3D<int>>& basis_vector_G      = m_list_BZ_states[0]->get_basis_vectors();

    std::cout << "Start computing impact ionization rate for band " << idx_n1 << " and k-point " << idx_k1 << std::endl;
    auto start_precompute = std::chrono::high_resolution_clock::now();
    std::cout << "Nb of Bz states: " << m_list_BZ_states.size() << std::endl;
    std::cout << "Nb cols: " << m_list_BZ_states[0]->get_eigen_states()[0].cols() << std::endl;

    // Sum_2_prime[idx_band][idx_node]
    std::vector<std::vector<complex_d>> Sum_2_prime(nb_conduction_bands);
    for (int idx_n2_prime = 0; idx_n2_prime < nb_conduction_bands; ++idx_n2_prime) {
        int n2_prime = idx_n2_prime + min_conduction_band;
        Sum_2_prime[idx_n2_prime].resize(nb_vtx);
        for (std::size_t idx_node = 0; idx_node < nb_vtx; ++idx_node) {
            const Eigen::MatrixXcd& A_2_prime   = m_list_BZ_states[0]->get_eigen_states()[idx_node];
            Sum_2_prime[idx_n2_prime][idx_node] = A_2_prime.col(n2_prime).sum();
        }
    }
    std::cout << "Sum_2_prime done" << std::endl;
    // Sum_2[idx_band][idx_node]
    std::vector<std::vector<complex_d>> Sum_2(nb_valence_bands);
    for (int idx_n2 = 0; idx_n2 < nb_valence_bands; ++idx_n2) {
        Sum_2_prime[idx_n2].resize(nb_vtx);
        for (std::size_t idx_node = 0; idx_node < nb_vtx; ++idx_node) {
            const Eigen::MatrixXcd& A_2   = m_list_BZ_states[0]->get_eigen_states()[idx_node];
            Sum_2_prime[idx_n2][idx_node] = A_2.col(idx_n2).sum();
        }
    }

    std::cout << "Sum_2 done" << std::endl;

    // Sum_2_prime[idx_band][idx_node] (n1, k1 are in an outter loop)
    std::vector<std::vector<complex_d>> Sum_1_prime_1(nb_conduction_bands);
    for (int idx_n1_prime = 0; idx_n1_prime < nb_conduction_bands; ++idx_n1_prime) {
        std::size_t n1_prime = idx_n1_prime + min_conduction_band;
        Sum_1_prime_1[idx_n1_prime].resize(nb_vtx);
        for (std::size_t idx_k1_prime = 0; idx_k1_prime < nb_vtx; ++idx_k1_prime) {
            const Eigen::MatrixXcd& A_1_prime = m_list_BZ_states[0]->get_eigen_states()[idx_k1_prime];
            const Eigen::MatrixXcd& A_1       = m_list_BZ_states[0]->get_eigen_states()[idx_k1];
            int                     nb_Gvect  = A_1_prime.rows();
            complex_d               sum       = 0.0;
            for (int idx_G1_prime = 0; idx_G1_prime < nb_Gvect; ++idx_G1_prime) {
                for (int idx_G1 = 0; idx_G1 < nb_Gvect; ++idx_G1) {
                    auto    G1_prime = basis_vector_G[idx_G1_prime];
                    auto    GG1      = basis_vector_G[idx_G1];
                    vector3 GA       = vector3(G1_prime.X + GG1.X, G1_prime.Y + GG1.Y, G1_prime.Z + GG1.Z);
                    vector3 GA_prime = vector3(G1_prime.X, G1_prime.Y, G1_prime.Z);
                    auto    k1       = m_list_BZ_states[0]->get_vertex_position(idx_k1);
                    auto    k1_prime = m_list_BZ_states[0]->get_vertex_position(idx_k1_prime);
                    // auto    q_a      = k1 - k1_prime + G1 + (-1 * G1_prime);
                    double  energy_w = m_list_BZ_states[0]->get_energies()[idx_n1] - m_list_BZ_states[0]->get_energies()[n1_prime];
                    // complex_d epsilon    = m_dielectric_mesh.interpolate_dielectric_function(q_a, energy_w);
                    // complex_d epsilon    = 1.0;
                    // complex_d factor_eps = EmpiricalPseudopotential::Constants::q_e * EmpiricalPseudopotential::Constants::q_e /
                    //                        (EmpiricalPseudopotential::Constants::eps_0 * epsilon * q_a.norm() * q_a.norm());
                    // sum += std::conj(A_1_prime(idx_G1_prime, n1_prime)) * A_1(idx_G1, idx_n1) * factor_eps;
                }
            }
            Sum_1_prime_1[idx_n1_prime][idx_k1_prime] = sum;
        }
    }

    auto end_precompute = std::chrono::high_resolution_clock::now();
    std::cout << "Precompute time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end_precompute - start_precompute).count()
              << " ms" << std::endl;
    std::cout << "DONE PRECOMPUTE\n Start computing matrix element" << std::endl;

    auto start_compute = std::chrono::high_resolution_clock::now();

    const std::vector<Vertex>& list_vertices = m_list_BZ_states[0]->get_list_vertices();

    for (int idx_n2 = 0; idx_n2 < nb_valence_bands; ++idx_n2) {
        for (int idx_n1_prime = 0; idx_n1_prime < nb_conduction_bands; ++idx_n1_prime) {
            std::size_t n1_prime = idx_n1_prime + min_conduction_band;
            for (int idx_n2_prime = 0; idx_n2_prime < nb_conduction_bands; ++idx_n2_prime) {
                std::size_t n2_prime = idx_n2_prime + min_conduction_band;
                for (std::size_t idx_k1_prime = 0; idx_k1_prime < nb_vtx; ++idx_k1_prime) {
                    std::cout << "idx_n1: " << idx_n1 << " idx_n1_prime: " << idx_n1_prime << " idx_n2: " << idx_n2
                              << " idx_n2_prime: " << idx_n2_prime << " idx_k1: " << idx_k1 << " idx_k1_prime: " << idx_k1_prime
                              << std::endl;
                    std::vector<double> FullMatrixElement(nb_vtx);
                    for (std::size_t idx_k2_prime = 0; idx_k2_prime < nb_vtx; ++idx_k2_prime) {
                        // std::cout << "\r" << idx_k1_prime << " / " << nb_vtx << " --> " << idx_k2_prime << " / " << nb_vtx << std::flush;
                        vector3 k_2_momentum = list_vertices[idx_k1].get_position() - list_vertices[idx_k1_prime].get_position() -
                                               list_vertices[idx_k2_prime].get_position();
                        if (k_2_momentum.norm() > m_max_radius_G0_BZ || k_2_momentum.norm() < 1e-12) {
                            continue;
                        }
                        std::size_t idx_k2 = 18;
                        complex_d   Ma =
                            Sum_2_prime[idx_n2_prime][idx_k2_prime] * Sum_1_prime_1[idx_n1_prime][idx_k1_prime] * Sum_2[idx_n2][idx_k2];
                        complex_d Mb =
                            Sum_2_prime[idx_n1_prime][idx_k1_prime] * Sum_1_prime_1[idx_n2_prime][idx_k2_prime] * Sum_2[idx_n2][idx_k2];
                        FullMatrixElement[idx_k2_prime] =
                            std::abs(Ma) * std::abs(Ma) + std::abs(Mb) * std::abs(Mb) + std::abs(Ma - Mb) * std::abs(Ma - Mb);
                    }
                }
            }
        }
    }
    std::cout << std::endl;
    auto end_compute = std::chrono::high_resolution_clock::now();
    std::cout << "Compute time: " << std::chrono::duration_cast<std::chrono::milliseconds>(end_compute - start_compute).count() << " ms"
              << std::endl;
    return 0.0;
}

}  // namespace bz_mesh/**
 * @file bz_dielectric.hpp
 * @author remzerrr (remi.helleboid@gmail.com)
 * @brief
 * @version 0.1
 * @date 2022-12-20
 *
 * @copyright Copyright (c) 2022
 *
 */

#pragma once

#include <Eigen/Dense>

#include "Material.h"
#include "bz_mesh.hpp"

namespace bz_mesh {

class BZ_States : public MeshBZ {
 protected:
    int m_nb_bands = 0;

    std::vector<Vector3D<int>> m_basisVectors;

    std::vector<Eigen::VectorXd> m_eigenvalues_k;
    std::vector<Eigen::VectorXd> m_eigenvalues_k_plus_q;

    std::vector<Eigen::MatrixXcd> m_eigenvectors_k;
    std::vector<Eigen::MatrixXcd> m_eigenvectors_k_plus_q;

    Vector3D<double>    m_q_shift;
    std::vector<double> m_list_energies;

    /**
     * @brief Real part of the dielectric function.
     * m_dielectric_function_real[idx_energy] is the real part of the dielectric function at the energy m_energies[idx_energy].
     *
     */
    std::vector<double> m_dielectric_function_real;

    // m_vtx_dielectric_function_real[idx_vtx][idx_energy] is the real part of the dielectric function at the energy m_energies[idx_energy]
    // and at the vertex m_vertices[idx_vtx].
    std::vector<std::vector<double>> m_vtx_dielectric_function_real;

    /**
     * @brief The index of the first q-point this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the q-points of the mesh.
     *
     * For a calculation on a single CPU the offset is 0.
     *
     */
    std::size_t m_offset_q_index = 0;

    /**
     * @brief Number of q-points this class is responsible for.
     * This is used to parallelize the computation of the dielectric function where
     * each instance of this class is responsible for a subset of the q-points.
     *
     * For a calculation on a single CPU this parameter is equal to the size of the m_vertices.size().
     *
     */
    std::size_t m_nb_kpoints = 0;

 public:
    BZ_States(const EmpiricalPseudopotential::Material& material) : MeshBZ(material) {}
    BZ_States(const BZ_States& other) = default;

    void                              set_nb_bands(int nb_bands) { m_nb_bands = nb_bands; }
    void                              set_basis_vectors(const std::vector<Vector3D<int>>& basis_vectors) { m_basisVectors = basis_vectors; }
    const std::vector<Vector3D<int>>& get_basis_vectors() const { return m_basisVectors; }
    void                              compute_eigenstates(int nb_threads = 1);
    void                              compute_shifted_eigenstates(const Vector3D<double>& q_shift, int nb_threads = 1);

    const std::vector<double>& get_energies() const { return m_list_energies; }
    void                       set_energies(const std::vector<double>& energies) { m_list_energies = energies; }

    const std::vector<Eigen::MatrixXcd>& get_eigen_states() const { return m_eigenvectors_k; }

    void compute_dielectric_function(const std::vector<double>& energies, double eta_smearing, int nb_threads = 1);
    void export_dielectric_function(const std::string& prefix) const;

    void populate_vtx_dielectric_function(const std::vector<double>& energies, double eta_smearing);

    std::complex<double> get_dielectric_function(const vector3& q, double energy) const {
        // TODO: implement this function
        return 1.0;
    }

    void export_full_eigenstates() const;
};

}  // namespace bz_mesh/**
 * @file elelectron_phonon.cpp
 * @brief Electron–phonon implementation (matches refactored header: m_phonon_dispersion[4], RateValues::add)
 * @date 2024-02-09
 */

#include "electron_phonon.hpp"

#include <Eigen/Dense>
#include <array>
#include <atomic>
#include <cassert>
#include <cmath>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <random>
#include <sstream>
#include <tuple>
#include <vector>

#include "Constants.hpp"
#include "Vector3D.h"
#include "bz_states.hpp"
#include "gmsh.h"
#include "omp.h"
#include "yaml-cpp/yaml.h"

namespace bz_mesh {

// ----- OpenMP custom reduction for std::array<double,8> -----
static inline void arr8_add(std::array<double, 8>& __restrict out, const std::array<double, 8>& __restrict in) noexcept {
    for (int i = 0; i < 8; ++i)
        out[i] += in[i];
}
#pragma omp declare reduction(merge : std::array<double, 8> : arr8_add(omp_out, omp_in)) initializer(omp_priv = std::array<double, 8>{})

// -------------------- Small inline helpers --------------------

inline double ElectronPhonon::bose_einstein_distribution(double energy_eV, double temperature_K) const {
    // N0 = 1 / (exp(E / kT) - 1)
    const double x = energy_eV / (EmpiricalPseudopotential::Constants::k_b_eV * temperature_K);
    return 1.0 / std::expm1(x);  // stable for small x
}

inline double ElectronPhonon::electron_overlap_integral(const vector3& k1, const vector3& k2) const {
    // Spherical j1-like: 3 (sin x - x cos x)/x^3 with x = |k1-k2| * R_WS
    constexpr double R_Wigner_Seitz = 2.122e-10;  // m
    const double     x              = (k1 - k2).norm() * R_Wigner_Seitz;

    if (std::abs(x) < 1e-6) {
        const double x2 = x * x;
        return 1.0 - 0.1 * x2;  // 1 - x^2/10 + O(x^4)
    }
    return 3.0 * (std::sin(x) - x * std::cos(x)) / (x * x * x);
}

inline double ElectronPhonon::hole_overlap_integral(int n1, const vector3& k1, int n2, const vector3& k2) const {
    const double cos_angle_k1_k2   = compute_cos_angle(k1, k2);
    const double cos_angle_k1_k2_2 = cos_angle_k1_k2 * cos_angle_k1_k2;
    auto         A_B_params        = m_hole_overlap_int_params.get_params(n1, n2);
    double       integral          = 0.5 * std::sqrt(A_B_params[0] + A_B_params[1] * cos_angle_k1_k2_2);
    return integral;
}

inline double ElectronPhonon::get_max_phonon_energy() const {
    double max_energy = std::numeric_limits<double>::lowest();
    for (const auto& disp : m_phonon_dispersion) {
        double max_w = disp.max_omega();  // ω_max [1/s]
        if (max_w > max_energy) max_energy = max_w;
    }
    return max_energy * EmpiricalPseudopotential::Constants::h_bar_eV;  // ħω → eV
}

/**
 * @brief Transport weight factor 1 - cos(θ) where θ is the angle between v0 and v1, the group velocities.
 *
 * @param v0
 * @param v1
 * @return double
 */
inline double ElectronPhonon::transport_weight_RTA(const vector3& v0, const vector3& v1) {
    const double norm_v0 = v0.norm_squared();
    const double norm_v1 = v1.norm_squared();
    if (norm_v0 < 1e-24 || norm_v1 < 1e-24) return 1.0;  // degeneracy/edge guard
    double cos_theta = v0.dot(v1) / std::sqrt(norm_v0 * norm_v1);
    if (cos_theta > 1.0) cos_theta = 1.0;
    if (cos_theta < -1.0) cos_theta = -1.0;
    return 1.0 - cos_theta;  // = 1 - cos θ
}

// --- Pairwise kernel: one (n1,k1) → (n2, bary(t)) transition, returns 8 channels ---
// Uses tetra barycenter for k2 and your DOS(Ef) per band at that tetra.
Rate8 ElectronPhonon::compute_transition_rates_pair(int         idx_n1,
                                                    std::size_t idx_k1,
                                                    int         idx_n2,
                                                    std::size_t idx_t /* tetra index */,
                                                    bool        push_nk_npkp /* optional sparse fill */) {
    Rate8 out{};

    const auto& vtx1  = m_list_vertices[idx_k1];
    const auto& tetra = m_list_tetrahedra[idx_t];

    const double  Ei_eV = vtx1.get_energy_at_band(idx_n1);
    const vector3 k1    = vtx1.get_position();
    const vector3 k2    = tetra.compute_barycenter();

    // Overlap once
    const double I  = electron_overlap_integral(k1, k2);
    const double I2 = I * I;

    // q = k2 - k1, fold to 1st BZ if needed (normal processes only)
    vector3 q = k2 - k1;
    if (!is_inside_mesh_geometry(q)) q = retrieve_k_inside_mesh_geometry(q);
    if (!is_inside_mesh_geometry(q)) return out;  // nothing to do

    const double qn = q.norm();

    // Row/col for optional sparse insert (compact conduction indexing assumed)
    Eigen::Index Nk = static_cast<Eigen::Index>(m_list_vertices.size());
    Eigen::Index Nt = static_cast<Eigen::Index>(m_list_tetrahedra.size());

    // If you compact bands for matrices, map full band → compact band index
    auto band_to_comp = [&](int n) -> int {
        auto it = std::find(m_indices_conduction_bands.begin(), m_indices_conduction_bands.end(), n);
        return (it == m_indices_conduction_bands.end()) ? -1 : int(it - m_indices_conduction_bands.begin());
    };
    const int          n1c = band_to_comp(idx_n1);
    const int          n2c = band_to_comp(idx_n2);
    const Eigen::Index row = (n1c >= 0) ? (Eigen::Index)n1c * Nk + (Eigen::Index)idx_k1 : -1;
    const Eigen::Index col = (n2c >= 0) ? (Eigen::Index)n2c * Nt + (Eigen::Index)idx_t : -1;

    constexpr double SMALL_OMEGA_CUTOFF = 1.0;  // [1/s]
    const double     pi                 = EmpiricalPseudopotential::Constants::pi;
    const double     qe                 = EmpiricalPseudopotential::Constants::q_e;       // J/eV
    const double     hbar_eV            = EmpiricalPseudopotential::Constants::h_bar_eV;  // eV·s

    double       inv_mrta_rate          = 0.0;
    vector3      vnk                    = vtx1.get_energy_gradient_at_band(idx_n1) * (1.0 / hbar_eV);   // m/s
    vector3      v_npkp                 = tetra.get_gradient_energy_at_band(idx_n2) * (1.0 / hbar_eV);  // m/s
    const double transport_weight_value = this->transport_weight_RTA(vnk, v_npkp);

    // Loop 4 branches: md=0..3 → (ac/op)×(L/T)
    for (int md = 0; md < 4; ++md) {
        const auto&           disp = m_phonon_dispersion[md];
        const PhononMode      mode = ((md >> 1) == 0) ? PhononMode::acoustic : PhononMode::optical;
        const PhononDirection dir  = ((md & 1) == 0) ? PhononDirection::longitudinal : PhononDirection::transverse;

        // ω(|q|) [1/s] — use your lookup or analytic
        const double omega = disp.omega_lookup(qn);
        if (omega <= SMALL_OMEGA_CUTOFF) continue;

        const double Eph_eV = hbar_eV * omega;
        const double N0     = bose_einstein_distribution(Eph_eV, m_temperature);

        // Deformation potential (J)
        const DeformationPotential& defpot  = (mode == PhononMode::acoustic) ? m_ac_defpot_e : m_op_defpot_e;
        const double                Delta_J = defpot.get_fischetti_deformation_potential(q, idx_n1) * qe;

        // Common prefactor
        const double pref = (pi / (m_rho * omega)) * (Delta_J * Delta_J) * I2 / m_reduce_bz_factor * m_spin_degeneracy;

        // --- Emission (Ef = Ei - ħω), bose = N0 + 1 ---
        {
            const double Ef_eV = Ei_eV - Eph_eV;
            if (tetra.is_energy_inside_band(Ef_eV, idx_n2)) {
                const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                if (dos_eV > 0.0) {
                    const double val = pref * (N0 + 1.0) * (dos_eV / qe);
                    const int    b   = rate_index(mode, dir, PhononEvent::emission);
                    out[static_cast<std::size_t>(b)] += val;
                    inv_mrta_rate += val * transport_weight_value;  // for 1/τ_tr
                }
            }
        }
        // --- Absorption (Ef = Ei + ħω), bose = N0 ---
        {
            const double Ef_eV = Ei_eV + Eph_eV;
            if (tetra.is_energy_inside_band(Ef_eV, idx_n2)) {
                const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                if (dos_eV > 0.0) {
                    const double val = pref * (N0) * (dos_eV / qe);
                    const int    b   = rate_index(mode, dir, PhononEvent::absorption);
                    out[static_cast<std::size_t>(b)] += val;
                    inv_mrta_rate += val * transport_weight_value;  // for 1/τ_tr
                }
            }
        }
    }
    m_phonon_rates_transport[idx_n1][idx_k1] += inv_mrta_rate;  // accumulate 1/τ_tr(E) on uniform grid
    return out;
}

RateValues ElectronPhonon::compute_electron_phonon_rate(int idx_n1, std::size_t idx_k1, bool populate_nk_npkp) {
    RateValues acc;

    const double Ei_eV   = m_list_vertices[idx_k1].get_energy_at_band(idx_n1);
    const double Eph_max = get_max_phonon_energy();
    const double Ef_min  = Ei_eV - Eph_max;
    const double Ef_max  = Ei_eV + Eph_max;

    std::size_t nnz = 0;

    for (int idx_n2 : m_indices_conduction_bands) {
        // Quick reject band window
        if (Ef_min > m_max_band[idx_n2] || Ef_max < m_min_band[idx_n2]) continue;

        for (std::size_t t = 0; t < m_list_tetrahedra.size(); ++t) {
            const auto& tetra = m_list_tetrahedra[t];
            if (!tetra.does_intersect_band_energy_range(Ef_min, Ef_max, idx_n2)) continue;

            const Rate8 r = compute_transition_rates_pair(idx_n1, idx_k1, idx_n2, t, /*push=*/populate_nk_npkp);
            nnz += (r != Rate8{});  // count non-zero contributions
            for (int i = 0; i < 8; ++i)
                acc.v[i] += r[i];
        }
    }
    // std::cout << "Computed rates for (n,k)=(" << idx_n1 << "," << idx_k1 << ") Ei=" << std::setprecision(6) << Ei_eV
    //           << " eV, non-zero contributions: " << nnz << " / " << m_indices_conduction_bands.size() * m_list_tetrahedra.size() << " = "
    //           << (100.0 * nnz / (m_indices_conduction_bands.size() * m_list_tetrahedra.size())) << "%\n";
    return acc;
}

// -------------------- Hole rates --------------------

RateValues ElectronPhonon::compute_hole_phonon_rate(int idx_n1, std::size_t idx_k1) {
    RateValues  rates_k1_n1;
    const auto& list_tetrahedra       = m_list_tetrahedra;
    const auto& indices_valence_bands = m_indices_valence_bands;

    const double  Ei_eV = m_list_vertices[idx_k1].get_energy_at_band(idx_n1);
    const vector3 k1    = m_list_vertices[idx_k1].get_position();

    constexpr double SMALL_OMEGA_CUTOFF = 1.0;

    for (int idx_n2 : indices_valence_bands) {
        for (const auto& tetra : list_tetrahedra) {
            const vector3 k2 = tetra.compute_barycenter();

            const double overlap  = hole_overlap_integral(idx_n1, k1, idx_n2, k2);
            const double overlap2 = overlap * overlap;

            vector3 q = k2 - k1;
            if (!is_inside_mesh_geometry(q)) q = retrieve_k_inside_mesh_geometry(q);
            if (!is_inside_mesh_geometry(q)) continue;

            const double q_norm = q.norm();

            for (int md = 0; md < 4; ++md) {
                const auto&           disp = m_phonon_dispersion[md];
                const PhononMode      mode = (md < 2) ? PhononMode::acoustic : PhononMode::optical;
                const PhononDirection dir  = (md & 1) ? PhononDirection::transverse : PhononDirection::longitudinal;

                const double omega = disp.omega_lookup(q_norm);
                if (omega <= SMALL_OMEGA_CUTOFF) continue;

                const double Eph_eV = EmpiricalPseudopotential::Constants::h_bar_eV * omega;
                const double N0     = bose_einstein_distribution(Eph_eV, m_temperature);

                const DeformationPotential& defpot = (mode == PhononMode::acoustic) ? m_ac_defpot_h : m_op_defpot_h;
                const double Delta_J = defpot.get_fischetti_deformation_potential(q, idx_n1) * EmpiricalPseudopotential::Constants::q_e;

                // Emission
                {
                    const double Ef_eV  = Ei_eV - Eph_eV;
                    const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                    if (dos_eV > 0.0) {
                        const double dos_per_J = dos_eV / EmpiricalPseudopotential::Constants::q_e;
                        double rate_value = (EmpiricalPseudopotential::Constants::pi / (m_rho * omega)) * (Delta_J * Delta_J) * overlap2 *
                                            (N0 + 1.0) * dos_per_J;
                        rate_value /= m_reduce_bz_factor;
                        rate_value *= m_spin_degeneracy;

                        rates_k1_n1.add(mode, dir, PhononEvent::emission, rate_value);
                    }
                }
                // Absorption
                {
                    const double Ef_eV  = Ei_eV + Eph_eV;
                    const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(idx_n2));
                    if (dos_eV > 0.0) {
                        const double dos_per_J = dos_eV / EmpiricalPseudopotential::Constants::q_e;
                        double       rate_value =
                            (EmpiricalPseudopotential::Constants::pi / (m_rho * omega)) * (Delta_J * Delta_J) * overlap2 * (N0)*dos_per_J;
                        rate_value /= m_reduce_bz_factor;
                        rate_value *= m_spin_degeneracy;

                        rates_k1_n1.add(mode, dir, PhononEvent::absorption, rate_value);
                    }
                }
            }  // md
        }  // tetra
    }  // bands

    return rates_k1_n1;
}

// -------------------- Mesh sweeps & exporters --------------------

void ElectronPhonon::compute_electron_phonon_rates_over_mesh(double energy_max, bool irreducible_wedge_only, bool populate_nk_npkp) {
    auto indices_conduction_bands = m_indices_conduction_bands;
    auto min_idx_conduction_band  = *std::min_element(indices_conduction_bands.begin(), indices_conduction_bands.end());
    auto max_idx_conduction_band  = *std::max_element(indices_conduction_bands.begin(), indices_conduction_bands.end());

    std::cout << "Min index conduction band: " << min_idx_conduction_band << "\n";
    std::cout << "Max index conduction band: " << max_idx_conduction_band << "\n";
    std::cout << "Computing electron-phonon rates over mesh for " << m_list_vertices.size() << " k-points.\n";

    // --- Decide band set for rows/cols (compact conduction example) ---
    const std::vector<int>& rows_bands = m_indices_conduction_bands;  // (n,k)
    const std::vector<int>& cols_bands = m_indices_conduction_bands;  // (n',k')

    if (populate_nk_npkp) {
        const std::size_t Nk      = m_list_vertices.size();
        const std::size_t Nt      = m_list_tetrahedra.size();
        const int         Nb_rows = static_cast<int>(rows_bands.size());
        const int         Nb_cols = static_cast<int>(cols_bands.size());

        const Eigen::Index nrows = static_cast<Eigen::Index>(static_cast<std::size_t>(Nb_rows) * Nk);
        const Eigen::Index ncols = static_cast<Eigen::Index>(static_cast<std::size_t>(Nb_cols) * Nt);
        std::cout << "Matrix size: " << nrows << " x " << ncols << " (" << (nrows * ncols) << " elements)\n";
        constexpr double percentage_reserve = 0.01;  // 1% of elements
        std::cout << "Reserving " << (nrows * ncols * percentage_reserve) << " elements per matrix.\n";

        m_rates_nk_npkp.clear();
        m_rates_nk_npkp.resize(8);  // indices 0..7 must equal rate_index(m,d,e)

        Eigen::VectorXi reserve_vec(nrows);
        reserve_vec.setConstant(std::max<Eigen::Index>(1, static_cast<Eigen::Index>(percentage_reserve * Nb_cols * Nt)));

        for (int M = 0; M < 2; ++M) {
            const PhononMode m = (M == 0) ? PhononMode::acoustic : PhononMode::optical;
            for (int D = 0; D < 2; ++D) {
                const PhononDirection d = (D == 0) ? PhononDirection::longitudinal : PhononDirection::transverse;
                for (int E = 0; E < 2; ++E) {
                    const PhononEvent e   = (E == 0) ? PhononEvent::absorption : PhononEvent::emission;  // matches your enum
                    const int         idx = rate_index(m, d, e);                                         // (M<<2)|(D<<1)|E  → [0..7]

                    Rates_nk_npkp_ctor R;
                    R.mode      = m;
                    R.direction = d;
                    R.event     = e;
                    R.matrix.resize(nrows, ncols);
                    R.matrix.reserve(reserve_vec);

                    m_rates_nk_npkp[idx] = std::move(R);
                }
            }
        }
    }  // if populate_nk_npkp

    std::cout << "Progress: 0%";
    std::atomic<std::size_t> counter{0};
    constexpr int            chunk_size = 32;

    m_phonon_rates_transport.clear();
    m_phonon_rates_transport.resize(static_cast<std::size_t>(m_indices_conduction_bands.size()));
    for (auto& vec : m_phonon_rates_transport) {
        vec.resize(m_list_vertices.size(), 0.0);
    }
    // Create a shuffled list of indices to balance load when using irreducible wedge only
    std::vector<std::size_t> random_indices(m_list_vertices.size());
    for (std::size_t i = 0; i < m_list_vertices.size(); ++i)
        random_indices[i] = i;
    if (irreducible_wedge_only) {
        constexpr int seed = 0;
        std::mt19937  g(seed);
        std::shuffle(random_indices.begin(), random_indices.end(), g);
    }

#pragma omp parallel for schedule(dynamic, chunk_size) num_threads(m_nb_threads)
    for (std::size_t idx = 0; idx < m_list_vertices.size(); ++idx) {
        // Use random index if irreducible wedge only
        const std::size_t idx_k1 = irreducible_wedge_only ? random_indices[idx] : idx;
        const bool        to_compute =
            (!irreducible_wedge_only) || (irreducible_wedge_only && is_irreducible_wedge(m_list_vertices[idx_k1].get_position()));

        const auto done = ++counter;
        if (omp_get_thread_num() == 0) {
            std::cout << "\rDone " << done << "/" << m_list_vertices.size() << " (" << std::fixed << std::setprecision(1)
                      << (100.0 * done / m_list_vertices.size()) << "%)" << std::flush;
        }

        // Valence bands (holes)
        for (std::size_t idx_n1 = 0; idx_n1 < static_cast<std::size_t>(min_idx_conduction_band); ++idx_n1) {
            if (!to_compute) continue;
            auto hole_rate = compute_hole_phonon_rate(static_cast<int>(idx_n1), idx_k1);
            (void)hole_rate;  // attach to vertices if/when needed
            // m_list_vertices[idx_k1].add_electron_phonon_rates(hole_rate.as_array());
        }

        // Conduction bands (electrons)
        for (std::size_t idx_n1 = static_cast<std::size_t>(min_idx_conduction_band);
             idx_n1 <= static_cast<std::size_t>(max_idx_conduction_band);
             ++idx_n1) {
            if (!to_compute) continue;

            if (m_list_vertices[idx_k1].get_energy_at_band(static_cast<int>(idx_n1)) > energy_max) {
                m_list_vertices[idx_k1].add_electron_phonon_rates(std::array<double, 8>{});
                continue;
            } else {
                auto rate = compute_electron_phonon_rate(static_cast<int>(idx_n1), idx_k1);
                m_list_vertices[idx_k1].add_electron_phonon_rates(rate.as_array());
            }
        }
    }

    std::cout << "\rComputed " << counter << " k-points out of " << m_list_vertices.size() << " (100%)\n";

    if (irreducible_wedge_only) {
        std::cout << "Set electron-phonon rates for all mesh vertices.\n";
#pragma omp parallel for schedule(dynamic) num_threads(m_nb_threads)
        for (std::size_t idx_k1 = 0; idx_k1 < m_list_vertices.size(); ++idx_k1) {
            if ((idx_k1 % 1000) == 0 && omp_get_thread_num() == 0) {
                std::cout << "\rSetting rates for all k-points: " << idx_k1 << "/" << m_list_vertices.size() << " (" << std::fixed
                          << std::setprecision(1) << (100.0 * idx_k1 / m_list_vertices.size()) << "%)" << std::flush;
            }
            if (!is_irreducible_wedge(m_list_vertices[idx_k1].get_position())) {
                std::size_t idx_k1_symm = get_index_irreducible_wedge(m_list_vertices[idx_k1].get_position());
                for (std::size_t idx_n1 = 0; idx_n1 <= static_cast<std::size_t>(max_idx_conduction_band); ++idx_n1) {
                    auto rates_symm = m_list_vertices[idx_k1_symm].get_electron_phonon_rates(idx_n1);
                    m_list_vertices[idx_k1].add_electron_phonon_rates(rates_symm);
                }
            }
        }
        std::cout << "\rSet rates for all k-points: " << m_list_vertices.size() << "/" << m_list_vertices.size() << " (100%)\n";
    }
}

void ElectronPhonon::compute_electron_phonon_rates_over_mesh_nk_npkp(bool irreducible_wedge_only) {
    auto indices_conduction_bands = m_indices_conduction_bands;
    auto min_idx_conduction_band  = *std::min_element(indices_conduction_bands.begin(), indices_conduction_bands.end());

    std::cout << "Min index conduction band: " << min_idx_conduction_band << "\n";
    std::cout << "Computing electron-phonon rates over mesh for " << m_list_vertices.size() << " k-points.\n";

    std::cout << "Progress: 0%";
    std::atomic<std::size_t> counter{0};

#pragma omp parallel for schedule(dynamic) num_threads(m_nb_threads)
    for (std::size_t idx_k1 = 0; idx_k1 < m_list_vertices.size(); ++idx_k1) {
        bool to_compute = is_irreducible_wedge(m_list_vertices[idx_k1].get_position()) && irreducible_wedge_only;

        auto done = ++counter;
        if ((done % 100) == 0 || (done == m_list_vertices.size() && omp_get_thread_num() == 0)) {
            std::cout << "\rDone " << done << "/" << m_list_vertices.size() << " (" << std::fixed << std::setprecision(1)
                      << (100.0 * done / m_list_vertices.size()) << "%)" << std::flush;
        }

        for (std::size_t idx_n1 = 0; idx_n1 < static_cast<std::size_t>(min_idx_conduction_band); ++idx_n1) {
            if (!to_compute) continue;
            (void)compute_hole_phonon_rate(static_cast<int>(idx_n1), idx_k1);
        }
    }
}

// -------------------- Sampling a final state --------------------

std::pair<int, std::size_t> ElectronPhonon::select_final_state(std::size_t     idx_band_initial,
                                                               std::size_t     idx_k_initial,
                                                               PhononMode      mode,
                                                               PhononDirection direction,
                                                               PhononEvent     event) const {
    using std::size_t;

    if (m_list_vertices.empty() || m_list_tetrahedra.empty()) throw std::runtime_error("select_final_state: empty mesh.");
    if (idx_k_initial >= m_list_vertices.size()) throw std::out_of_range("select_final_state: idx_k_initial OOB.");

    const int md = md_index(mode, direction);
    if (md < 0) throw std::runtime_error("select_final_state: invalid mode/direction.");
    const auto& disp = m_phonon_dispersion[md];  // ω(|q|) in s^-1

    // Initial state
    const double  Ei_eV = m_list_vertices[idx_k_initial].get_energy_at_band(static_cast<int>(idx_band_initial));
    const vector3 k1    = m_list_vertices[idx_k_initial].get_position();

    const double sign_ph = (event == PhononEvent::emission) ? -1.0 : +1.0;

    const size_t        nb_bands = m_list_vertices.front().get_number_bands();
    const size_t        nb_tetra = m_list_tetrahedra.size();
    std::vector<double> probs_flat(nb_bands * nb_tetra, 0.0);
    auto                P_ref = [&](int n2, size_t t) -> double& { return probs_flat[static_cast<size_t>(n2) * nb_tetra + t]; };

    const double pi      = EmpiricalPseudopotential::Constants::pi;
    const double qe      = EmpiricalPseudopotential::Constants::q_e;
    const double hbar_eV = EmpiricalPseudopotential::Constants::h_bar_eV;

    const double Eph_max_eV = get_max_phonon_energy();

    for (int n2 : m_indices_conduction_bands) {
        // Band window
        const double Ef_min = Ei_eV - Eph_max_eV;
        const double Ef_max = Ei_eV + Eph_max_eV;
        if (Ef_min > m_max_band[n2] || Ef_max < m_min_band[n2]) continue;

        for (size_t t = 0; t < nb_tetra; ++t) {
            const auto& tetra = m_list_tetrahedra[t];
            if (!tetra.does_intersect_band_energy_range(Ef_min, Ef_max, n2)) continue;

            const vector3 k2_bary = tetra.compute_barycenter();

            vector3 q = k2_bary - k1;
            if (!is_inside_mesh_geometry(q)) q = retrieve_k_inside_mesh_geometry(q);
            if (!is_inside_mesh_geometry(q)) continue;

            const double qn    = q.norm();
            const double omega = disp.omega_lookup(qn);
            if (!(omega > 0.0) || omega < 1e-12) continue;

            const double Eph_eV = hbar_eV * omega;
            const double N0     = bose_einstein_distribution(Eph_eV, m_temperature);
            const double bose   = (sign_ph < 0.0) ? (N0 + 1.0) : N0;

            const double Ef_eV  = Ei_eV + sign_ph * Eph_eV;
            const double dos_eV = tetra.interpolate_dos_at_energy_per_band(Ef_eV, static_cast<std::size_t>(n2));
            if (dos_eV <= 0.0) continue;

            const double dos_per_J = dos_eV / qe;

            const double I  = electron_overlap_integral(k1, k2_bary);
            const double I2 = I * I;

            const DeformationPotential& defpot  = (mode == PhononMode::acoustic) ? m_ac_defpot_e : m_op_defpot_e;
            const double                Delta_J = defpot.get_fischetti_deformation_potential(q, static_cast<int>(idx_band_initial)) * qe;

            double P = (pi / (m_rho * omega)) * (Delta_J * Delta_J) * I2 * bose * dos_per_J;
            P /= m_reduce_bz_factor;
            P *= m_spin_degeneracy;

            if (P > 0.0 && std::isfinite(P)) P_ref(n2, t) = P;
        }
    }

    double total = 0.0;
    for (double p : probs_flat)
        total += p;
    if (!(total > 0.0) || !std::isfinite(total))
        throw std::runtime_error("select_final_state: no admissible final states (total probability = 0).");

    // Thread-local RNG
    thread_local std::mt19937_64           rng([] {
        std::random_device rd;
        auto               s1 = static_cast<uint64_t>(rd());
        auto               s2 = static_cast<uint64_t>(rd());
        return (s1 << 32) ^ s2;
    }());
    std::uniform_real_distribution<double> U(0.0, 1.0);
    const double                           threshold = U(rng) * total;

    double acc = 0.0;
    for (size_t flat = 0; flat < probs_flat.size(); ++flat) {
        acc += probs_flat[flat];
        if (acc >= threshold) {
            const int    n2 = static_cast<int>(flat / nb_tetra);
            const size_t t  = static_cast<size_t>(flat % nb_tetra);
            return {n2, t};  // band, tetra index (k' = barycenter(t))
        }
    }
    // Fallback: last positive
    for (size_t flat = probs_flat.size(); flat-- > 0;) {
        if (probs_flat[flat] > 0.0) {
            const int    n2 = static_cast<int>(flat / nb_tetra);
            const size_t t  = static_cast<size_t>(flat % nb_tetra);
            return {n2, t};
        }
    }
    throw std::runtime_error("select_final_state: internal sampling error.");
}

// -------------------- Energy sweep exporter --------------------

void ElectronPhonon::compute_plot_electron_phonon_rates_vs_energy_over_mesh(int                nb_bands,
                                                                            double             max_energy,
                                                                            double             energy_step,
                                                                            const std::string& filename,
                                                                            bool /*irreducible_wedge_only*/) {
    if (energy_step <= 0.0) throw std::invalid_argument("energy_step must be > 0");
    if (max_energy < 0.0) throw std::invalid_argument("max_energy must be >= 0");

    if (m_list_vertices.empty()) throw std::runtime_error("No vertices in mesh.");
    const int total_bands = static_cast<int>(m_list_vertices.front().get_number_bands());
    if (total_bands <= 0) throw std::runtime_error("Mesh reports zero bands.");

    nb_bands = std::clamp(nb_bands, 0, total_bands);
    if (nb_bands == 0) throw std::runtime_error("nb_bands clamped to 0; nothing to process.");

    std::ofstream out(filename);
    if (!out) throw std::runtime_error("Cannot open " + filename + " for writing.");

    static constexpr std::array<const char*, 8>
        kLabels{"ac_L_ab", "ac_T_ab", "op_L_ab", "op_T_ab", "ac_L_em", "ac_T_em", "op_L_em", "op_T_em"};

    out << "# E[eV],DOS(E)";
    for (auto* s : kLabels)
        out << ',' << s;
    out << '\n';

    const std::size_t n_steps = static_cast<std::size_t>(std::floor(max_energy / energy_step)) + 1;

    for (std::size_t istep = 0; istep < n_steps; ++istep) {
        const double E = std::min(max_energy, istep * energy_step);
        std::cout << "\rEnergy: " << E << " / " << max_energy << std::flush;

        double                dos_sum = 0.0;
        std::array<double, 8> num{};  // accumulators
        num.fill(0.0);

        for (const auto& tetra : m_list_tetrahedra) {
            for (int b = 0; b < nb_bands; ++b) {
                const double dos_t = tetra.compute_tetra_dos_energy_band(E, static_cast<std::size_t>(b));
                if (!std::isfinite(dos_t))
                    throw std::runtime_error("DOS is NaN/Inf at E=" + std::to_string(E) + " band=" + std::to_string(b));
                if (dos_t <= 0.0) continue;

                dos_sum += dos_t;

                const std::array<double, 8> rates = tetra.get_tetra_electron_phonon_rates(static_cast<std::size_t>(b));
                for (int i = 0; i < 8; ++i) {
                    num[i] += rates[i] * dos_t;
                }
            }
        }

        std::array<double, 8> mean{};
        if (dos_sum > 0.0) {
            const double inv_dos = 1.0 / dos_sum;
            for (int i = 0; i < 8; ++i)
                mean[i] = num[i] * inv_dos;
        } else {
            mean.fill(0.0);
        }

        out << std::scientific << std::setprecision(10) << E << ',' << dos_sum;
        for (double v : mean)
            out << ',' << v;
        out << '\n';
    }

    std::cout << std::endl;
    out.close();
}

/**
 * @brief Interpolate the phonon scattering rate at a given location for a given band.
 *
 * @param location
 * @param idx_band
 * @return Rate8
 */
Rate8 ElectronPhonon::interpolate_phonon_scattering_rate_at_location(const vector3& location, const std::size_t& idx_band) const {
    // Find the tetrahedron containing the location
    const Tetra* tetra = find_tetra_at_location(location);
    if (!tetra) {
        throw std::runtime_error("Location is not inside any tetrahedron");
    }

    // Get the vertex indices of the tetrahedron
    const auto& vertex_indices = tetra->get_index_vertices_with_sorted_energy_at_band(idx_band);

    // Interpolate the scattering rates at the vertices
    Rate8            rates;
    constexpr double inv_num_vertices = 1.0 / 4.0;
    for (std::size_t i = 0; i < vertex_indices.size(); ++i) {
        const auto& vertex = m_list_vertices[vertex_indices[i]];
        for (std::size_t idx_mode = 0; idx_mode < rates.size(); ++idx_mode) {
            rates[idx_mode] += m_list_phonon_scattering_rates[vertex.get_index()][idx_band][idx_mode];
        }
    }
    for (std::size_t idx_mode = 0; idx_mode < rates.size(); ++idx_mode) {
        rates[idx_mode] *= inv_num_vertices;
    }
    return rates;
}

// -------------------- Phonon dispersion dump --------------------

void ElectronPhonon::plot_phonon_dispersion(const std::string& filename) const {
    std::ofstream file(filename);
    for (auto&& vtx : m_list_vertices) {
        auto k = vtx.get_position();
        file << k.x() << " " << k.y() << " " << k.z() << " ";
        for (int md = 0; md < 4; ++md) {
            auto q = k;
            q /= m_material.get_fourier_factor();
            const auto&  disp = m_phonon_dispersion[md];
            const double e_ph = disp.omega_lookup(q.norm()) * EmpiricalPseudopotential::Constants::h_bar_eV;
            file << e_ph << " ";
        }
        file << '\n';
    }
}

// -------------------- Gmsh export --------------------

void ElectronPhonon::add_electron_phonon_rates_to_mesh(const std::string& initial_filename, const std::string& final_filename) {
    // If the file exists, remove it to avoid appending to an old file
    if (std::ifstream(final_filename)) {
        std::remove(final_filename.c_str());
    }

    gmsh::initialize();
    gmsh::option::setNumber("General.Verbosity", 0);
    gmsh::model::add("bz_mesh");
    gmsh::open(initial_filename);

    std::string model_file_name;
    gmsh::model::getCurrent(model_file_name);

    std::vector<std::size_t> node_tags;
    std::vector<double>      nodeCoords;
    std::vector<double>      nodeParams;
    gmsh::model::mesh::reclassifyNodes();
    gmsh::model::mesh::getNodes(node_tags, nodeCoords, nodeParams, -1, -1, false, false);

    auto indices_conduction_bands = m_indices_conduction_bands;
    auto max_idx_conduction_band  = *std::max_element(indices_conduction_bands.begin(), indices_conduction_bands.end());
    int  nb_bands                 = static_cast<int>(m_indices_conduction_bands.size() + m_indices_valence_bands.size());

    for (int idx_val_band = 0; idx_val_band < max_idx_conduction_band; ++idx_val_band) {
        std::vector<double> rates_ac_lo_em(m_list_vertices.size());
        std::vector<double> rates_ac_lo_ab(m_list_vertices.size());
        std::vector<double> rates_ac_tr_em(m_list_vertices.size());
        std::vector<double> rates_ac_tr_ab(m_list_vertices.size());
        std::vector<double> rates_opt_lo_em(m_list_vertices.size());
        std::vector<double> rates_opt_lo_ab(m_list_vertices.size());
        std::vector<double> rates_opt_tr_em(m_list_vertices.size());
        std::vector<double> rates_opt_tr_ab(m_list_vertices.size());

        for (std::size_t idx_k1 = 0; idx_k1 < m_list_vertices.size(); ++idx_k1) {
            auto rates              = m_list_vertices[idx_k1].get_electron_phonon_rates(static_cast<std::size_t>(idx_val_band));
            rates_ac_lo_em[idx_k1]  = rates[0];
            rates_ac_lo_ab[idx_k1]  = rates[1];
            rates_ac_tr_em[idx_k1]  = rates[2];
            rates_ac_tr_ab[idx_k1]  = rates[3];
            rates_opt_lo_em[idx_k1] = rates[4];
            rates_opt_lo_ab[idx_k1] = rates[5];
            rates_opt_tr_em[idx_k1] = rates[6];
            rates_opt_tr_ab[idx_k1] = rates[7];
        }

        std::string name_rate_ac_lo_em  = "ac_lo_em_" + std::to_string(idx_val_band);
        std::string name_rate_ac_lo_ab  = "ac_lo_ab_" + std::to_string(idx_val_band);
        std::string name_rate_ac_tr_em  = "ac_tr_em_" + std::to_string(idx_val_band);
        std::string name_rate_ac_tr_ab  = "ac_tr_ab_" + std::to_string(idx_val_band);
        std::string name_rate_opt_lo_em = "opt_lo_em_" + std::to_string(idx_val_band);
        std::string name_rate_opt_lo_ab = "opt_lo_ab_" + std::to_string(idx_val_band);
        std::string name_rate_opt_tr_em = "opt_tr_em_" + std::to_string(idx_val_band);
        std::string name_rate_opt_tr_ab = "opt_tr_ab_" + std::to_string(idx_val_band);

        int data_tag_ac_lo_em  = gmsh::view::add(name_rate_ac_lo_em);
        int data_tag_ac_lo_ab  = gmsh::view::add(name_rate_ac_lo_ab);
        int data_tag_ac_tr_em  = gmsh::view::add(name_rate_ac_tr_em);
        int data_tag_ac_tr_ab  = gmsh::view::add(name_rate_ac_tr_ab);
        int data_tag_opt_lo_em = gmsh::view::add(name_rate_opt_lo_em);
        int data_tag_opt_lo_ab = gmsh::view::add(name_rate_opt_lo_ab);
        int data_tag_opt_tr_em = gmsh::view::add(name_rate_opt_tr_em);
        int data_tag_opt_tr_ab = gmsh::view::add(name_rate_opt_tr_ab);

        gmsh::view::addHomogeneousModelData(data_tag_ac_lo_em, 0, model_file_name, "NodeData", node_tags, rates_ac_lo_em);
        gmsh::view::addHomogeneousModelData(data_tag_ac_lo_ab, 0, model_file_name, "NodeData", node_tags, rates_ac_lo_ab);
        gmsh::view::addHomogeneousModelData(data_tag_ac_tr_em, 0, model_file_name, "NodeData", node_tags, rates_ac_tr_em);
        gmsh::view::addHomogeneousModelData(data_tag_ac_tr_ab, 0, model_file_name, "NodeData", node_tags, rates_ac_tr_ab);
        gmsh::view::addHomogeneousModelData(data_tag_opt_lo_em, 0, model_file_name, "NodeData", node_tags, rates_opt_lo_em);
        gmsh::view::addHomogeneousModelData(data_tag_opt_lo_ab, 0, model_file_name, "NodeData", node_tags, rates_opt_lo_ab);
        gmsh::view::addHomogeneousModelData(data_tag_opt_tr_em, 0, model_file_name, "NodeData", node_tags, rates_opt_tr_em);
        gmsh::view::addHomogeneousModelData(data_tag_opt_tr_ab, 0, model_file_name, "NodeData", node_tags, rates_opt_tr_ab);

        gmsh::option::setNumber("PostProcessing.SaveMesh", 1);  // Save mesh only once
        gmsh::view::write(data_tag_ac_lo_em, final_filename, true);
        gmsh::option::setNumber("PostProcessing.SaveMesh", 0);
        gmsh::view::write(data_tag_ac_lo_ab, final_filename, true);
        gmsh::view::write(data_tag_ac_tr_em, final_filename, true);
        gmsh::view::write(data_tag_ac_tr_ab, final_filename, true);
        gmsh::view::write(data_tag_opt_lo_em, final_filename, true);
        gmsh::view::write(data_tag_opt_lo_ab, final_filename, true);
        gmsh::view::write(data_tag_opt_tr_em, final_filename, true);
        gmsh::view::write(data_tag_opt_tr_ab, final_filename, true);
    }
    gmsh::finalize();
}

// -------------------- Load parameters (YAML) --------------------

void ElectronPhonon::load_phonon_parameters(const std::string& filename) {
    YAML::Node config = YAML::LoadFile(filename);
    if (config.IsNull()) {
        throw std::runtime_error("File " + filename + " is empty");
    }

    // std::cout << "File " << filename << " contains:\n" << config << std::endl;

    auto               list_materials = config["materials"];
    const std::string& my_material    = m_material.get_name();

    auto same_material = [&](const YAML::Node& node) { return node["name"].as<std::string>() == my_material; };
    auto it_material   = std::find_if(list_materials.begin(), list_materials.end(), same_material);
    if (it_material == list_materials.end()) {
        throw std::runtime_error("Material " + my_material + " not found in file " + filename);
    }
    auto material = *it_material;

    double radiusWS      = material["Radius-WS"].as<double>();
    m_radii_wigner_seitz = radiusWS;

    // Dispersion → m_phonon_dispersion[md]
    auto dispersion = material["dispersion"];
    for (const auto& type : {"longitudinal", "transverse"}) {
        auto dispType = dispersion[type];
        for (const auto& wave : {"acoustic", "optic"}) {
            auto   waveType = dispType[wave];
            double w0       = waveType["w0"].as<double>();
            double vs       = waveType["vs"].as<double>();
            double c        = waveType["c"].as<double>();
            // std::cout << "w0: " << w0 << " vs: " << vs << " c: " << c << std::endl;

            PhononDirection direction = (std::string(type) == "longitudinal") ? PhononDirection::longitudinal : PhononDirection::transverse;
            PhononMode      mode      = (std::string(wave) == "acoustic") ? PhononMode::acoustic : PhononMode::optical;

            PhononDispersion phononDispersion(mode, direction, w0, vs, c);
            double           q_max_norm = 1.5 / m_si2red;
            std::size_t      points     = 200;
            // std::cout << "Max q norm in reduced units: " << q_max_norm << std::endl;
            phononDispersion.build_lookup(q_max_norm, points);

            const int md = md_index(mode, direction);
            if (md < 0) throw std::runtime_error("load_phonon_parameters: bad mode/direction index.");
            m_phonon_dispersion[md] = std::move(phononDispersion);
        }
    }

    // Deformation potentials
    auto node_deformationPotential = material["deformation-potential"];
    for (const auto& carrierType : {"electron", "hole"}) {
        auto   carrier          = node_deformationPotential[carrierType];
        double energy_threshold = carrier["energy-threshold"].as<double>();
        for (const auto& wave : {"acoustic", "optic"}) {
            auto   waveType = carrier[wave];
            double A        = waveType["A"].as<double>();
            double B        = waveType["B"].as<double>();

            PhononMode           mode = (std::string(wave) == "acoustic") ? PhononMode::acoustic : PhononMode::optical;
            DeformationPotential deformationPotential(mode, A, B, energy_threshold);
            if (std::string(carrierType) == "electron") {
                if (mode == PhononMode::acoustic)
                    m_ac_defpot_e = deformationPotential;
                else
                    m_op_defpot_e = deformationPotential;
            } else {
                if (mode == PhononMode::acoustic)
                    m_ac_defpot_h = deformationPotential;
                else
                    m_op_defpot_h = deformationPotential;
            }
        }
    }
}

// -------------------- CSV import/export of rates --------------------

void ElectronPhonon::export_rate_values(const std::string& filename) const {
    std::ofstream file(filename);
    for (auto&& vertex : m_list_vertices) {
        std::vector<std::array<double, 8>> all_rates = vertex.get_electron_phonon_rates_all_bands();
        for (std::size_t idx_band = 0; idx_band < all_rates.size(); ++idx_band) {
            double energy = vertex.get_energy_at_band(idx_band);
            file << idx_band << "," << energy << ",";
            for (std::size_t idx_rate = 0; idx_rate < all_rates[idx_band].size(); ++idx_rate) {
                double rate = all_rates[idx_band][idx_rate];
                file << rate << ((idx_rate + 1 < all_rates[idx_band].size()) ? "," : "");
            }
            file << '\n';
        }
    }
    file.close();
}

void ElectronPhonon::read_phonon_scattering_rates_from_file(const std::filesystem::path& path) {
    std::cout << "Reading phonon scattering rates (CSV) from file " << path.string() << " ...\n";

    std::ifstream in(path);
    if (!in.is_open()) throw std::runtime_error("Could not open file " + path.string());

    m_list_phonon_scattering_rates.clear();
    m_list_phonon_scattering_rates.resize(m_list_vertices.size());

    std::string line;
    std::size_t line_no = 0;

    for (std::size_t idx_vtx = 0; idx_vtx < m_list_vertices.size(); ++idx_vtx) {
        const auto&       vertex   = m_list_vertices[idx_vtx];
        const std::size_t nbands   = vertex.get_number_bands();
        auto&             per_band = m_list_phonon_scattering_rates[idx_vtx];
        per_band.resize(nbands);

        for (std::size_t idx_band = 0; idx_band < nbands; ++idx_band) {
            do {
                if (!std::getline(in, line)) {
                    std::cout << "Line no: " << line_no << " " << line << std::endl;
                    throw std::runtime_error("Unexpected EOF at vertex " + std::to_string(idx_vtx) + ", band " + std::to_string(idx_band));
                }
                ++line_no;
            } while (line.empty() || line[0] == '#' || line[0] == ';');

            for (char& c : line)
                if (c == ',') c = ' ';
            std::istringstream iss(line);

            std::size_t band_idx_file{};
            double      energy_file{};
            Rate8       rates{};

            // Keep your CSV layout if you still emit ALO..ETA in this order elsewhere
            if (!(iss >> band_idx_file >> energy_file >> rates[0] >> rates[1] >> rates[2] >> rates[3] >> rates[4] >> rates[5] >> rates[6] >>
                  rates[7])) {
                throw std::runtime_error("Malformed CSV line " + std::to_string(line_no));
            }
            if (band_idx_file == nbands) {
                // More bands in the file than in the mesh: ignore extra bands
                break;
            }
            per_band[idx_band] = rates;
        }
    }
    in.close();

    std::cout << "Finished reading phonon scattering rates for " << m_list_vertices.size() << " vertices.\n";
}

// -------------------- Simple reductions --------------------

inline double ElectronPhonon::sum_modes(const Rate8& r) const noexcept {
    double s = 0.0;
    for (int i = 0; i < 8; ++i)
        s += r[i];
    return s;
}

double ElectronPhonon::compute_P_Gamma() const {
    double pgamma_max = 0.0;
    for (const auto& perVertex : m_list_phonon_scattering_rates) {
        for (const auto& rate8 : perVertex) {
            const double tot = sum_modes(rate8);
            if (tot > pgamma_max) pgamma_max = tot;
        }
    }
    return pgamma_max;
}

}  // namespace bz_mesh
